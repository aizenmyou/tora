/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.3-SNAPSHOT
 *
 *     -  From the grammar source file : OracleDMLKeys.g
 *     -                            On : 2017-07-10 20:58:45
 *     -                for the parser : OracleDML_OracleDMLKeysParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include "antlr3compilerwarning.hpp"
#include "OracleDML_OracleDMLKeys.hpp"

// Include delegator definition header files
//
#include "OracleDML.hpp" 
#include <memory>

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;

//typedef CommonTreeAdaptor adaptor;
//TreeAdaptor adaptor = new CommonTreeAdaptor();

//void setTreeAdaptor(TreeAdaptor adaptor)
//{
//	this.adaptor = adaptor;
//	<grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
//}
//TreeAdaptor getTreeAdaptor()
//{
//	return adaptor;
//}
/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "OracleDMLKeys.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* OracleDML_OracleDMLKeys::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new OracleDML_OracleDMLKeys parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
OracleDML_OracleDMLKeys::OracleDML_OracleDMLKeys( StreamType* instream, OracleDML* gOracleDML)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gOracleDML);
}

/** \brief Create a new OracleDML_OracleDMLKeys parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
OracleDML_OracleDMLKeys::OracleDML_OracleDMLKeys( StreamType* instream, RecognizerSharedStateType* state, OracleDML* gOracleDML)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gOracleDML);
}

void OracleDML_OracleDMLKeys::init(StreamType* instream, OracleDML* gOracleDML)
{
	/* Allocate TreeAdaptorType 
	 */
	// Install the pointers back to lexers that will delegate us to perform certain functions
	// for them.
	//
	m_gOracleDML = gOracleDML;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( OracleDMLTokenNames );

}

void
OracleDML_OracleDMLKeys::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
OracleDML_OracleDMLKeys::~OracleDML_OracleDMLKeys()
{
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
ANTLR_UINT8**	OracleDML_OracleDMLKeys::getTokenNames()
{
        return OracleDMLTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CREATE_in_create_key367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CREATE_in_create_key367( FOLLOW_SQL92_RESERVED_CREATE_in_create_key367_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_replace_key394_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_replace_key394( FOLLOW_REGULAR_ID_in_replace_key394_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_package_key422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_package_key422( FOLLOW_REGULAR_ID_in_package_key422_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_body_key449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_body_key449( FOLLOW_REGULAR_ID_in_body_key449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key474_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key474( FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key474_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exit_key491_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exit_key491( FOLLOW_REGULAR_ID_in_exit_key491_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key516_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key516( FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key516_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key536_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key536( FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key536_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serveroutput_key558_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serveroutput_key558( FOLLOW_REGULAR_ID_in_serveroutput_key558_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_off_key580_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_off_key580( FOLLOW_REGULAR_ID_in_off_key580_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constant_key607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constant_key607( FOLLOW_REGULAR_ID_in_constant_key607_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_subtype_key634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_subtype_key634( FOLLOW_REGULAR_ID_in_subtype_key634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key654( FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nextval_key677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nextval_key677( FOLLOW_REGULAR_ID_in_nextval_key677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GOTO_in_goto_key697_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GOTO_in_goto_key697( FOLLOW_SQL92_RESERVED_GOTO_in_goto_key697_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_execute_key719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_execute_key719( FOLLOW_REGULAR_ID_in_execute_key719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_immediate_key747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_immediate_key747( FOLLOW_REGULAR_ID_in_immediate_key747_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_return_key774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_return_key774( FOLLOW_REGULAR_ID_in_return_key774_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key799( FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key799_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_function_key822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_function_key822( FOLLOW_REGULAR_ID_in_function_key822_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pragma_key844_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pragma_key844( FOLLOW_REGULAR_ID_in_pragma_key844_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exception_init_key871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exception_init_key871( FOLLOW_REGULAR_ID_in_exception_init_key871_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_type_key899_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_type_key899( FOLLOW_REGULAR_ID_in_type_key899_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_record_key927_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_record_key927( FOLLOW_REGULAR_ID_in_record_key927_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indexed_key949_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indexed_key949( FOLLOW_REGULAR_ID_in_indexed_key949_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_INDEX_in_index_key969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_INDEX_in_index_key969( FOLLOW_PLSQL_RESERVED_INDEX_in_index_key969_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_notfound_key992_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_notfound_key992( FOLLOW_PERCENT_in_percent_notfound_key992_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_notfound_key994_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_notfound_key994( FOLLOW_REGULAR_ID_in_percent_notfound_key994_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_found_key1022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_found_key1022( FOLLOW_PERCENT_in_percent_found_key1022_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_found_key1024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_found_key1024( FOLLOW_REGULAR_ID_in_percent_found_key1024_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_isopen_key1052_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_isopen_key1052( FOLLOW_PERCENT_in_percent_isopen_key1052_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_isopen_key1054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_isopen_key1054( FOLLOW_REGULAR_ID_in_percent_isopen_key1054_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_rowcount_key1082_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_rowcount_key1082( FOLLOW_PERCENT_in_percent_rowcount_key1082_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_rowcount_key1084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_rowcount_key1084( FOLLOW_REGULAR_ID_in_percent_rowcount_key1084_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_rowtype_key1112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_rowtype_key1112( FOLLOW_PERCENT_in_percent_rowtype_key1112_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_rowtype_key1114_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_rowtype_key1114( FOLLOW_REGULAR_ID_in_percent_rowtype_key1114_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_type_key1143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_type_key1143( FOLLOW_PERCENT_in_percent_type_key1143_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_type_key1145_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_type_key1145( FOLLOW_REGULAR_ID_in_percent_type_key1145_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_out_key1173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_out_key1173( FOLLOW_REGULAR_ID_in_out_key1173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inout_key1200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inout_key1200( FOLLOW_REGULAR_ID_in_inout_key1200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_extend_key1228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_extend_key1228( FOLLOW_REGULAR_ID_in_extend_key1228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_raise_key1250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_raise_key1250( FOLLOW_REGULAR_ID_in_raise_key1250_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_while_key1277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_while_key1277( FOLLOW_REGULAR_ID_in_while_key1277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_loop_key1299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_loop_key1299( FOLLOW_REGULAR_ID_in_loop_key1299_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_commit_key1327_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_commit_key1327( FOLLOW_REGULAR_ID_in_commit_key1327_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_work_key1349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_work_key1349( FOLLOW_REGULAR_ID_in_work_key1349_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_IF_in_if_key1374_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_IF_in_if_key1374( FOLLOW_PLSQL_RESERVED_IF_in_if_key1374_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key1394_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key1394( FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key1394_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_authid_key1417_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_authid_key1417( FOLLOW_REGULAR_ID_in_authid_key1417_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_definer_key1444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_definer_key1444( FOLLOW_REGULAR_ID_in_definer_key1444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_external_key1471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_external_key1471( FOLLOW_REGULAR_ID_in_external_key1471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_language_key1498_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_language_key1498( FOLLOW_REGULAR_ID_in_language_key1498_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_java_key1525_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_java_key1525( FOLLOW_REGULAR_ID_in_java_key1525_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_name_key1553_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_name_key1553( FOLLOW_REGULAR_ID_in_name_key1553_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_deterministic_key1581_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_deterministic_key1581( FOLLOW_REGULAR_ID_in_deterministic_key1581_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parallel_enable_key1609_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parallel_enable_key1609( FOLLOW_REGULAR_ID_in_parallel_enable_key1609_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_result_cache_key1637_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_result_cache_key1637( FOLLOW_REGULAR_ID_in_result_cache_key1637_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pipelined_key1665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pipelined_key1665( FOLLOW_REGULAR_ID_in_pipelined_key1665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_aggregate_key1692_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_aggregate_key1692( FOLLOW_REGULAR_ID_in_aggregate_key1692_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1717_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1717( FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1717_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compile_key1739_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compile_key1739( FOLLOW_REGULAR_ID_in_compile_key1739_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_debug_key1767_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_debug_key1767( FOLLOW_REGULAR_ID_in_debug_key1767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reuse_key1794_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reuse_key1794( FOLLOW_REGULAR_ID_in_reuse_key1794_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_settings_key1821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_settings_key1821( FOLLOW_REGULAR_ID_in_settings_key1821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_specification_key1843_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_specification_key1843( FOLLOW_REGULAR_ID_in_specification_key1843_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DROP_in_drop_key1868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DROP_in_drop_key1868( FOLLOW_SQL92_RESERVED_DROP_in_drop_key1868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trigger_key1891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trigger_key1891( FOLLOW_REGULAR_ID_in_trigger_key1891_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_force_key1914_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_force_key1914( FOLLOW_REGULAR_ID_in_force_key1914_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_validate_key1941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_validate_key1941( FOLLOW_REGULAR_ID_in_validate_key1941_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ref_key1969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ref_key1969( FOLLOW_REGULAR_ID_in_ref_key1969_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_array_key1997_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_array_key1997( FOLLOW_REGULAR_ID_in_array_key1997_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varray_key2020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varray_key2020( FOLLOW_REGULAR_ID_in_varray_key2020_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pls_integer_key2043_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pls_integer_key2043( FOLLOW_REGULAR_ID_in_pls_integer_key2043_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serially_reusable_key2071_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serially_reusable_key2071( FOLLOW_REGULAR_ID_in_serially_reusable_key2071_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_autonomous_transaction_key2099_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_autonomous_transaction_key2099( FOLLOW_REGULAR_ID_in_autonomous_transaction_key2099_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inline_key2127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inline_key2127( FOLLOW_REGULAR_ID_in_inline_key2127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_restrict_references_key2155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_restrict_references_key2155( FOLLOW_REGULAR_ID_in_restrict_references_key2155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exceptions_key2183_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exceptions_key2183( FOLLOW_REGULAR_ID_in_exceptions_key2183_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_save_key2212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_save_key2212( FOLLOW_REGULAR_ID_in_save_key2212_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_forall_key2235_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_forall_key2235( FOLLOW_REGULAR_ID_in_forall_key2235_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_continue_key2263_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_continue_key2263( FOLLOW_REGULAR_ID_in_continue_key2263_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indices_key2291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indices_key2291( FOLLOW_REGULAR_ID_in_indices_key2291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_VALUES_in_values_key2311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_VALUES_in_values_key2311( FOLLOW_SQL92_RESERVED_VALUES_in_values_key2311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CASE_in_case_key2331_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CASE_in_case_key2331( FOLLOW_SQL92_RESERVED_CASE_in_case_key2331_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bulk_key2354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bulk_key2354( FOLLOW_REGULAR_ID_in_bulk_key2354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_collect_key2382_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_collect_key2382( FOLLOW_REGULAR_ID_in_collect_key2382_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_committed_key2409_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_committed_key2409( FOLLOW_REGULAR_ID_in_committed_key2409_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_use_key2437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_use_key2437( FOLLOW_REGULAR_ID_in_use_key2437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_level_key2459_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_level_key2459( FOLLOW_REGULAR_ID_in_level_key2459_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_isolation_key2482_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_isolation_key2482( FOLLOW_REGULAR_ID_in_isolation_key2482_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serializable_key2509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serializable_key2509( FOLLOW_REGULAR_ID_in_serializable_key2509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_segment_key2536_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_segment_key2536( FOLLOW_REGULAR_ID_in_segment_key2536_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_write_key2559_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_write_key2559( FOLLOW_REGULAR_ID_in_write_key2559_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_wait_key2587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_wait_key2587( FOLLOW_REGULAR_ID_in_wait_key2587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2615( FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corrupt_xid_key2643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corrupt_xid_key2643( FOLLOW_REGULAR_ID_in_corrupt_xid_key2643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_batch_key2671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_batch_key2671( FOLLOW_REGULAR_ID_in_batch_key2671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_session_key2699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_session_key2699( FOLLOW_REGULAR_ID_in_session_key2699_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_role_key2722_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_role_key2722( FOLLOW_REGULAR_ID_in_role_key2722_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constraint_key2745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constraint_key2745( FOLLOW_REGULAR_ID_in_constraint_key2745_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constraints_key2768_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constraints_key2768( FOLLOW_REGULAR_ID_in_constraints_key2768_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_call_key2791_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_call_key2791( FOLLOW_REGULAR_ID_in_call_key2791_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_explain_key2819_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_explain_key2819( FOLLOW_REGULAR_ID_in_explain_key2819_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_merge_key2842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_merge_key2842( FOLLOW_REGULAR_ID_in_merge_key2842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_plan_key2870_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_plan_key2870( FOLLOW_REGULAR_ID_in_plan_key2870_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_system_key2893_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_system_key2893( FOLLOW_REGULAR_ID_in_system_key2893_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_subpartition_key2916_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_subpartition_key2916( FOLLOW_REGULAR_ID_in_subpartition_key2916_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_partition_key2944_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_partition_key2944( FOLLOW_REGULAR_ID_in_partition_key2944_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_matched_key2972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_matched_key2972( FOLLOW_REGULAR_ID_in_matched_key2972_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reject_key2995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reject_key2995( FOLLOW_REGULAR_ID_in_reject_key2995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_log_key3023_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_log_key3023( FOLLOW_REGULAR_ID_in_log_key3023_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unlimited_key3051_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unlimited_key3051( FOLLOW_REGULAR_ID_in_unlimited_key3051_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_limit_key3079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_limit_key3079( FOLLOW_REGULAR_ID_in_limit_key3079_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_errors_key3107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_errors_key3107( FOLLOW_REGULAR_ID_in_errors_key3107_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key3130_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key3130( FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key3130_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_urowid_key3158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_urowid_key3158( FOLLOW_REGULAR_ID_in_urowid_key3158_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key3186_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key3186( FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key3186_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_min_normal_key3209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_min_normal_key3209( FOLLOW_REGULAR_ID_in_binary_double_min_normal_key3209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_max_normal_key3232_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_max_normal_key3232( FOLLOW_REGULAR_ID_in_binary_float_max_normal_key3232_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_positiven_key3255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_positiven_key3255( FOLLOW_REGULAR_ID_in_positiven_key3255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_abbr_key3283_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_abbr_key3283( FOLLOW_REGULAR_ID_in_timezone_abbr_key3283_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key3311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key3311( FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key3311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key3334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key3334( FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key3334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_key3357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_key3357( FOLLOW_REGULAR_ID_in_binary_double_key3357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bfile_key3385_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bfile_key3385( FOLLOW_REGULAR_ID_in_bfile_key3385_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_infinity_key3413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_infinity_key3413( FOLLOW_REGULAR_ID_in_binary_double_infinity_key3413_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_region_key3436_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_region_key3436( FOLLOW_REGULAR_ID_in_timezone_region_key3436_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key3464_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key3464( FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key3464_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_naturaln_key3492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_naturaln_key3492( FOLLOW_REGULAR_ID_in_naturaln_key3492_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_simple_integer_key3520_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_simple_integer_key3520( FOLLOW_REGULAR_ID_in_simple_integer_key3520_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key3548_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key3548( FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key3548_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_byte_key3571_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_byte_key3571( FOLLOW_REGULAR_ID_in_byte_key3571_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_infinity_key3599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_infinity_key3599( FOLLOW_REGULAR_ID_in_binary_float_infinity_key3599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_key3622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_key3622( FOLLOW_REGULAR_ID_in_binary_float_key3622_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_range_key3650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_range_key3650( FOLLOW_REGULAR_ID_in_range_key3650_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nclob_key3678_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nclob_key3678( FOLLOW_REGULAR_ID_in_nclob_key3678_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_clob_key3706_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_clob_key3706( FOLLOW_REGULAR_ID_in_clob_key3706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3734_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3734( FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3734_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3762_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3762( FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3762_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rowid_key3790_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rowid_key3790( FOLLOW_REGULAR_ID_in_rowid_key3790_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_nan_key3818_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_nan_key3818( FOLLOW_REGULAR_ID_in_binary_double_nan_key3818_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3841_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3841( FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3841_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3869_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3869( FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3869_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_signtype_key3892_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_signtype_key3892( FOLLOW_REGULAR_ID_in_signtype_key3892_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_blob_key3920_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_blob_key3920( FOLLOW_REGULAR_ID_in_blob_key3920_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nvarchar2_key3948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nvarchar2_key3948( FOLLOW_REGULAR_ID_in_nvarchar2_key3948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3976_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3976( FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3976_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_nan_key3999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_nan_key3999( FOLLOW_REGULAR_ID_in_binary_float_nan_key3999_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_string_key4022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_string_key4022( FOLLOW_REGULAR_ID_in_string_key4022_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_c_key4050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_c_key4050( FOLLOW_REGULAR_ID_in_c_key4050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_library_key4078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_library_key4078( FOLLOW_REGULAR_ID_in_library_key4078_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_context_key4106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_context_key4106( FOLLOW_REGULAR_ID_in_context_key4106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parameters_key4134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parameters_key4134( FOLLOW_REGULAR_ID_in_parameters_key4134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_agent_key4162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_agent_key4162( FOLLOW_REGULAR_ID_in_agent_key4162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cluster_key4190_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cluster_key4190( FOLLOW_REGULAR_ID_in_cluster_key4190_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hash_key4218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hash_key4218( FOLLOW_REGULAR_ID_in_hash_key4218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_relies_on_key4246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_relies_on_key4246( FOLLOW_REGULAR_ID_in_relies_on_key4246_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_returning_key4274_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_returning_key4274( FOLLOW_REGULAR_ID_in_returning_key4274_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statement_id_key4301_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statement_id_key4301( FOLLOW_REGULAR_ID_in_statement_id_key4301_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_deferred_key4324_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_deferred_key4324( FOLLOW_REGULAR_ID_in_deferred_key4324_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_advise_key4352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_advise_key4352( FOLLOW_REGULAR_ID_in_advise_key4352_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_resumable_key4375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_resumable_key4375( FOLLOW_REGULAR_ID_in_resumable_key4375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timeout_key4398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timeout_key4398( FOLLOW_REGULAR_ID_in_timeout_key4398_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parallel_key4421_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parallel_key4421( FOLLOW_REGULAR_ID_in_parallel_key4421_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ddl_key4444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ddl_key4444( FOLLOW_REGULAR_ID_in_ddl_key4444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_query_key4472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_query_key4472( FOLLOW_REGULAR_ID_in_query_key4472_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dml_key4495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dml_key4495( FOLLOW_REGULAR_ID_in_dml_key4495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_guard_key4518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_guard_key4518( FOLLOW_REGULAR_ID_in_guard_key4518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nothing_key4541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nothing_key4541( FOLLOW_REGULAR_ID_in_nothing_key4541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_enable_key4564_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_enable_key4564( FOLLOW_REGULAR_ID_in_enable_key4564_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_database_key4592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_database_key4592( FOLLOW_REGULAR_ID_in_database_key4592_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_disable_key4620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_disable_key4620( FOLLOW_REGULAR_ID_in_disable_key4620_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_link_key4648_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_link_key4648( FOLLOW_REGULAR_ID_in_link_key4648_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key4668_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key4668( FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key4668_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_none_key4691_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_none_key4691( FOLLOW_REGULAR_ID_in_none_key4691_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_before_key4714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_before_key4714( FOLLOW_REGULAR_ID_in_before_key4714_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_referencing_key4743_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_referencing_key4743( FOLLOW_REGULAR_ID_in_referencing_key4743_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_logon_key4771_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_logon_key4771( FOLLOW_REGULAR_ID_in_logon_key4771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_after_key4799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_after_key4799( FOLLOW_REGULAR_ID_in_after_key4799_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_schema_key4827_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_schema_key4827( FOLLOW_REGULAR_ID_in_schema_key4827_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4852( FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4852_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_truncate_key4875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_truncate_key4875( FOLLOW_REGULAR_ID_in_truncate_key4875_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_startup_key4903_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_startup_key4903( FOLLOW_REGULAR_ID_in_startup_key4903_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statistics_key4931_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statistics_key4931( FOLLOW_REGULAR_ID_in_statistics_key4931_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noaudit_key4959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noaudit_key4959( FOLLOW_REGULAR_ID_in_noaudit_key4959_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_suspend_key4987_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_suspend_key4987( FOLLOW_REGULAR_ID_in_suspend_key4987_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_audit_key5015_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_audit_key5015( FOLLOW_REGULAR_ID_in_audit_key5015_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_disassociate_key5043_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_disassociate_key5043( FOLLOW_REGULAR_ID_in_disassociate_key5043_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_shutdown_key5072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_shutdown_key5072( FOLLOW_REGULAR_ID_in_shutdown_key5072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compound_key5100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compound_key5100( FOLLOW_REGULAR_ID_in_compound_key5100_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_servererror_key5128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_servererror_key5128( FOLLOW_REGULAR_ID_in_servererror_key5128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parent_key5156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parent_key5156( FOLLOW_REGULAR_ID_in_parent_key5156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_follows_key5184_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_follows_key5184( FOLLOW_REGULAR_ID_in_follows_key5184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nested_key5212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nested_key5212( FOLLOW_REGULAR_ID_in_nested_key5212_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_old_key5240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_old_key5240( FOLLOW_REGULAR_ID_in_old_key5240_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statement_key5268_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statement_key5268( FOLLOW_REGULAR_ID_in_statement_key5268_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_db_role_change_key5291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_db_role_change_key5291( FOLLOW_REGULAR_ID_in_db_role_change_key5291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_each_key5319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_each_key5319( FOLLOW_REGULAR_ID_in_each_key5319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_logoff_key5342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_logoff_key5342( FOLLOW_REGULAR_ID_in_logoff_key5342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_analyze_key5370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_analyze_key5370( FOLLOW_REGULAR_ID_in_analyze_key5370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instead_key5398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instead_key5398( FOLLOW_REGULAR_ID_in_instead_key5398_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_associate_key5426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_associate_key5426( FOLLOW_REGULAR_ID_in_associate_key5426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_new_key5454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_new_key5454( FOLLOW_REGULAR_ID_in_new_key5454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key5479_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key5479( FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key5479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rename_key5502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rename_key5502( FOLLOW_REGULAR_ID_in_rename_key5502_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_customdatum_key5531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_customdatum_key5531( FOLLOW_REGULAR_ID_in_customdatum_key5531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oradata_key5559_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oradata_key5559( FOLLOW_REGULAR_ID_in_oradata_key5559_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constructor_key5587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constructor_key5587( FOLLOW_REGULAR_ID_in_constructor_key5587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqldata_key5615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqldata_key5615( FOLLOW_REGULAR_ID_in_sqldata_key5615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_member_key5643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_member_key5643( FOLLOW_REGULAR_ID_in_member_key5643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_self_key5671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_self_key5671( FOLLOW_REGULAR_ID_in_self_key5671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_object_key5699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_object_key5699( FOLLOW_REGULAR_ID_in_object_key5699_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_variable_key5727_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_variable_key5727( FOLLOW_REGULAR_ID_in_variable_key5727_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instantiable_key5750_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instantiable_key5750( FOLLOW_REGULAR_ID_in_instantiable_key5750_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_final_key5778_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_final_key5778( FOLLOW_REGULAR_ID_in_final_key5778_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_static_key5806_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_static_key5806( FOLLOW_REGULAR_ID_in_static_key5806_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oid_key5834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oid_key5834( FOLLOW_REGULAR_ID_in_oid_key5834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_result_key5857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_result_key5857( FOLLOW_REGULAR_ID_in_result_key5857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_under_key5880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_under_key5880( FOLLOW_REGULAR_ID_in_under_key5880_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_map_key5908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_map_key5908( FOLLOW_REGULAR_ID_in_map_key5908_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_overriding_key5936_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_overriding_key5936( FOLLOW_REGULAR_ID_in_overriding_key5936_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_add_key5964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_add_key5964( FOLLOW_REGULAR_ID_in_add_key5964_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_modify_key5992_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_modify_key5992( FOLLOW_REGULAR_ID_in_modify_key5992_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_including_key6020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_including_key6020( FOLLOW_REGULAR_ID_in_including_key6020_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substitutable_key6048_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substitutable_key6048( FOLLOW_REGULAR_ID_in_substitutable_key6048_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_attribute_key6071_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_attribute_key6071( FOLLOW_REGULAR_ID_in_attribute_key6071_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cascade_key6094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cascade_key6094( FOLLOW_REGULAR_ID_in_cascade_key6094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_data_key6123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_data_key6123( FOLLOW_REGULAR_ID_in_data_key6123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_invalidate_key6146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_invalidate_key6146( FOLLOW_REGULAR_ID_in_invalidate_key6146_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_element_key6174_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_element_key6174( FOLLOW_REGULAR_ID_in_element_key6174_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_first_key6197_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_first_key6197( FOLLOW_REGULAR_ID_in_first_key6197_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CHECK_in_check_key6222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CHECK_in_check_key6222( FOLLOW_SQL92_RESERVED_CHECK_in_check_key6222_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OPTION_in_option_key6242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OPTION_in_option_key6242( FOLLOW_SQL92_RESERVED_OPTION_in_option_key6242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocycle_key6265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocycle_key6265( FOLLOW_REGULAR_ID_in_nocycle_key6265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_locked_key6293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_locked_key6293( FOLLOW_REGULAR_ID_in_locked_key6293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_block_key6316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_block_key6316( FOLLOW_REGULAR_ID_in_block_key6316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xml_key6344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xml_key6344( FOLLOW_REGULAR_ID_in_xml_key6344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key6370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key6370( FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key6370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key6390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key6390( FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key6390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sequential_key6413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sequential_key6413( FOLLOW_REGULAR_ID_in_sequential_key6413_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_single_key6441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_single_key6441( FOLLOW_REGULAR_ID_in_single_key6441_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_skip_key6469_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_skip_key6469( FOLLOW_REGULAR_ID_in_skip_key6469_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key6503_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key6503( FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key6503_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_updated_key6526_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_updated_key6526( FOLLOW_REGULAR_ID_in_updated_key6526_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_increment_key6554_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_increment_key6554( FOLLOW_REGULAR_ID_in_increment_key6554_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exclude_key6582_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exclude_key6582( FOLLOW_REGULAR_ID_in_exclude_key6582_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reference_key6610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reference_key6610( FOLLOW_REGULAR_ID_in_reference_key6610_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sets_key6638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sets_key6638( FOLLOW_REGULAR_ID_in_sets_key6638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_until_key6661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_until_key6661( FOLLOW_REGULAR_ID_in_until_key6661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_seed_key6689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_seed_key6689( FOLLOW_REGULAR_ID_in_seed_key6689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_maxvalue_key6717_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_maxvalue_key6717( FOLLOW_REGULAR_ID_in_maxvalue_key6717_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_siblings_key6745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_siblings_key6745( FOLLOW_REGULAR_ID_in_siblings_key6745_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cube_key6773_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cube_key6773( FOLLOW_REGULAR_ID_in_cube_key6773_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nulls_key6801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nulls_key6801( FOLLOW_REGULAR_ID_in_nulls_key6801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dimension_key6829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dimension_key6829( FOLLOW_REGULAR_ID_in_dimension_key6829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_scn_key6857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_scn_key6857( FOLLOW_REGULAR_ID_in_scn_key6857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_snapshot_key6885_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_snapshot_key6885( FOLLOW_REGULAR_ID_in_snapshot_key6885_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decrement_key6908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decrement_key6908( FOLLOW_REGULAR_ID_in_decrement_key6908_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key6934_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key6934( FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key6934_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_keep_key6957_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_keep_key6957( FOLLOW_REGULAR_ID_in_keep_key6957_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_measures_key6985_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_measures_key6985( FOLLOW_REGULAR_ID_in_measures_key6985_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rows_key7013_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rows_key7013( FOLLOW_REGULAR_ID_in_rows_key7013_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sample_key7041_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sample_key7041( FOLLOW_REGULAR_ID_in_sample_key7041_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_upsert_key7069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_upsert_key7069( FOLLOW_REGULAR_ID_in_upsert_key7069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_versions_key7097_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_versions_key7097( FOLLOW_REGULAR_ID_in_versions_key7097_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rules_key7125_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rules_key7125( FOLLOW_REGULAR_ID_in_rules_key7125_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_iterate_key7153_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_iterate_key7153( FOLLOW_REGULAR_ID_in_iterate_key7153_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_minvalue_key7181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_minvalue_key7181( FOLLOW_REGULAR_ID_in_minvalue_key7181_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rollup_key7209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rollup_key7209( FOLLOW_REGULAR_ID_in_rollup_key7209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nav_key7237_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nav_key7237( FOLLOW_REGULAR_ID_in_nav_key7237_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_automatic_key7265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_automatic_key7265( FOLLOW_REGULAR_ID_in_automatic_key7265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_last_key7293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_last_key7293( FOLLOW_REGULAR_ID_in_last_key7293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_main_key7321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_main_key7321( FOLLOW_REGULAR_ID_in_main_key7321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_grouping_key7344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_grouping_key7344( FOLLOW_REGULAR_ID_in_grouping_key7344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_include_key7372_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_include_key7372( FOLLOW_REGULAR_ID_in_include_key7372_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ignore_key7400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ignore_key7400( FOLLOW_REGULAR_ID_in_ignore_key7400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_respect_key7428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_respect_key7428( FOLLOW_REGULAR_ID_in_respect_key7428_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key7452_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key7452( FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key7452_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_submultiset_key7475_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_submultiset_key7475( FOLLOW_REGULAR_ID_in_submultiset_key7475_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_at_key7503_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_at_key7503( FOLLOW_REGULAR_ID_in_at_key7503_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_a_key7531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_a_key7531( FOLLOW_REGULAR_ID_in_a_key7531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_empty_key7554_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_empty_key7554( FOLLOW_REGULAR_ID_in_empty_key7554_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_likec_key7577_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_likec_key7577( FOLLOW_REGULAR_ID_in_likec_key7577_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nan_key7605_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nan_key7605( FOLLOW_REGULAR_ID_in_nan_key7605_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_infinite_key7628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_infinite_key7628( FOLLOW_REGULAR_ID_in_infinite_key7628_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_like2_key7651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_like2_key7651( FOLLOW_REGULAR_ID_in_like2_key7651_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_like4_key7679_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_like4_key7679( FOLLOW_REGULAR_ID_in_like4_key7679_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_present_key7707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_present_key7707( FOLLOW_REGULAR_ID_in_present_key7707_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dbtimezone_key7730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dbtimezone_key7730( FOLLOW_REGULAR_ID_in_dbtimezone_key7730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sessiontimezone_key7758_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sessiontimezone_key7758( FOLLOW_REGULAR_ID_in_sessiontimezone_key7758_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nchar_cs_key7786_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nchar_cs_key7786( FOLLOW_REGULAR_ID_in_nchar_cs_key7786_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decompose_key7814_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decompose_key7814( FOLLOW_REGULAR_ID_in_decompose_key7814_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_following_key7842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_following_key7842( FOLLOW_REGULAR_ID_in_following_key7842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_first_value_key7870_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_first_value_key7870( FOLLOW_REGULAR_ID_in_first_value_key7870_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_preceding_key7898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_preceding_key7898( FOLLOW_REGULAR_ID_in_preceding_key7898_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_within_key7926_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_within_key7926( FOLLOW_REGULAR_ID_in_within_key7926_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_canonical_key7954_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_canonical_key7954( FOLLOW_REGULAR_ID_in_canonical_key7954_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compatibility_key7982_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compatibility_key7982( FOLLOW_REGULAR_ID_in_compatibility_key7982_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_over_key8010_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_over_key8010( FOLLOW_REGULAR_ID_in_over_key8010_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_MULTISET_in_multiset_key8036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_MULTISET_in_multiset_key8036( FOLLOW_PLSQL_NON_RESERVED_MULTISET_in_multiset_key8036_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key8056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key8056( FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key8056_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_last_value_key8079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_last_value_key8079( FOLLOW_REGULAR_ID_in_last_value_key8079_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CURRENT_in_current_key8104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CURRENT_in_current_key8104( FOLLOW_SQL92_RESERVED_CURRENT_in_current_key8104_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unbounded_key8127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unbounded_key8127( FOLLOW_REGULAR_ID_in_unbounded_key8127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dense_rank_key8155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dense_rank_key8155( FOLLOW_REGULAR_ID_in_dense_rank_key8155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cost_key8183_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cost_key8183( FOLLOW_REGULAR_ID_in_cost_key8183_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_cs_key8211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_cs_key8211( FOLLOW_REGULAR_ID_in_char_cs_key8211_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_auto_key8239_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_auto_key8239( FOLLOW_REGULAR_ID_in_auto_key8239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_treat_key8267_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_treat_key8267( FOLLOW_REGULAR_ID_in_treat_key8267_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_content_key8295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_content_key8295( FOLLOW_REGULAR_ID_in_content_key8295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlparse_key8323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlparse_key8323( FOLLOW_REGULAR_ID_in_xmlparse_key8323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlelement_key8351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlelement_key8351( FOLLOW_REGULAR_ID_in_xmlelement_key8351_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_entityescaping_key8379_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_entityescaping_key8379( FOLLOW_REGULAR_ID_in_entityescaping_key8379_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_standalone_key8407_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_standalone_key8407( FOLLOW_REGULAR_ID_in_standalone_key8407_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_wellformed_key8435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_wellformed_key8435( FOLLOW_REGULAR_ID_in_wellformed_key8435_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlexists_key8463_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlexists_key8463( FOLLOW_REGULAR_ID_in_xmlexists_key8463_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_version_key8491_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_version_key8491( FOLLOW_REGULAR_ID_in_version_key8491_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlcast_key8519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlcast_key8519( FOLLOW_REGULAR_ID_in_xmlcast_key8519_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_yes_key8547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_yes_key8547( FOLLOW_REGULAR_ID_in_yes_key8547_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_no_key8575_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_no_key8575( FOLLOW_REGULAR_ID_in_no_key8575_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_evalname_key8603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_evalname_key8603( FOLLOW_REGULAR_ID_in_evalname_key8603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlpi_key8631_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlpi_key8631( FOLLOW_REGULAR_ID_in_xmlpi_key8631_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlcolattval_key8659_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlcolattval_key8659( FOLLOW_REGULAR_ID_in_xmlcolattval_key8659_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_document_key8687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_document_key8687( FOLLOW_REGULAR_ID_in_document_key8687_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlforest_key8715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlforest_key8715( FOLLOW_REGULAR_ID_in_xmlforest_key8715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_passing_key8743_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_passing_key8743( FOLLOW_REGULAR_ID_in_passing_key8743_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_columns_key8771_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_columns_key8771( FOLLOW_REGULAR_ID_in_columns_key8771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indent_key8800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indent_key8800( FOLLOW_REGULAR_ID_in_indent_key8800_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hide_key8828_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hide_key8828( FOLLOW_REGULAR_ID_in_hide_key8828_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlagg_key8856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlagg_key8856( FOLLOW_REGULAR_ID_in_xmlagg_key8856_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_path_key8884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_path_key8884( FOLLOW_REGULAR_ID_in_path_key8884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlnamespaces_key8907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlnamespaces_key8907( FOLLOW_REGULAR_ID_in_xmlnamespaces_key8907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_SIZE_in_size_key8932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_SIZE_in_size_key8932( FOLLOW_SQL92_RESERVED_SIZE_in_size_key8932_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noschemacheck_key8955_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noschemacheck_key8955( FOLLOW_REGULAR_ID_in_noschemacheck_key8955_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noentityescaping_key8983_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noentityescaping_key8983( FOLLOW_REGULAR_ID_in_noentityescaping_key8983_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlquery_key9011_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlquery_key9011( FOLLOW_REGULAR_ID_in_xmlquery_key9011_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmltable_key9039_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmltable_key9039( FOLLOW_REGULAR_ID_in_xmltable_key9039_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlroot_key9067_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlroot_key9067( FOLLOW_REGULAR_ID_in_xmlroot_key9067_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_schemacheck_key9095_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_schemacheck_key9095( FOLLOW_REGULAR_ID_in_schemacheck_key9095_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlattributes_key9123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlattributes_key9123( FOLLOW_REGULAR_ID_in_xmlattributes_key9123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_encoding_key9151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_encoding_key9151( FOLLOW_REGULAR_ID_in_encoding_key9151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_show_key9179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_show_key9179( FOLLOW_REGULAR_ID_in_show_key9179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlserialize_key9207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlserialize_key9207( FOLLOW_REGULAR_ID_in_xmlserialize_key9207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ordinality_key9235_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ordinality_key9235( FOLLOW_REGULAR_ID_in_ordinality_key9235_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_defaults_key9263_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_defaults_key9263( FOLLOW_REGULAR_ID_in_defaults_key9263_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqlerror_key9290_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqlerror_key9290( FOLLOW_REGULAR_ID_in_sqlerror_key9290_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oserror_key9314_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oserror_key9314( FOLLOW_REGULAR_ID_in_oserror_key9314_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_success_key9337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_success_key9337( FOLLOW_REGULAR_ID_in_success_key9337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_warning_key9360_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_warning_key9360( FOLLOW_REGULAR_ID_in_warning_key9360_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_failure_key9383_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_failure_key9383( FOLLOW_REGULAR_ID_in_failure_key9383_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INSERT_in_insert_key9404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INSERT_in_insert_key9404( FOLLOW_SQL92_RESERVED_INSERT_in_insert_key9404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ORDER_in_order_key9424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ORDER_in_order_key9424( FOLLOW_SQL92_RESERVED_ORDER_in_order_key9424_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key9444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key9444( FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key9444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_row_key9466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_row_key9466( FOLLOW_REGULAR_ID_in_row_key9466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_mod_key9493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_mod_key9493( FOLLOW_REGULAR_ID_in_mod_key9493_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_raw_key9516_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_raw_key9516( FOLLOW_REGULAR_ID_in_raw_key9516_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_power_key9543_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_power_key9543( FOLLOW_REGULAR_ID_in_power_key9543_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key9563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key9563( FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key9563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key9583_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key9583( FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key9583_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_HAVING_in_having_key9603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_HAVING_in_having_key9603( FOLLOW_SQL92_RESERVED_HAVING_in_having_key9603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ANY_in_any_key9623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ANY_in_any_key9623( FOLLOW_SQL92_RESERVED_ANY_in_any_key9623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WITH_in_with_key9643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WITH_in_with_key9643( FOLLOW_SQL92_RESERVED_WITH_in_with_key9643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_transaction_key9666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_transaction_key9666( FOLLOW_REGULAR_ID_in_transaction_key9666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rawtohex_key9688_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rawtohex_key9688( FOLLOW_REGULAR_ID_in_rawtohex_key9688_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_number_key9711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_number_key9711( FOLLOW_REGULAR_ID_in_number_key9711_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocopy_key9739_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocopy_key9739( FOLLOW_REGULAR_ID_in_nocopy_key9739_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TO_in_to_key9764_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TO_in_to_key9764( FOLLOW_SQL92_RESERVED_TO_in_to_key9764_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_abs_key9786_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_abs_key9786( FOLLOW_REGULAR_ID_in_abs_key9786_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rollback_key9809_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rollback_key9809( FOLLOW_REGULAR_ID_in_rollback_key9809_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_SHARE_in_share_key9834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_SHARE_in_share_key9834( FOLLOW_PLSQL_RESERVED_SHARE_in_share_key9834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_greatest_key9856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_greatest_key9856( FOLLOW_REGULAR_ID_in_greatest_key9856_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_vsize_key9878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_vsize_key9878( FOLLOW_REGULAR_ID_in_vsize_key9878_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key9898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key9898( FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key9898_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varchar2_key9921_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varchar2_key9921( FOLLOW_REGULAR_ID_in_varchar2_key9921_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rowidtochar_key9948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rowidtochar_key9948( FOLLOW_REGULAR_ID_in_rowidtochar_key9948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_open_key9971_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_open_key9971( FOLLOW_REGULAR_ID_in_open_key9971_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_comment_key9999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_comment_key9999( FOLLOW_REGULAR_ID_in_comment_key9999_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqrt_key10026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqrt_key10026( FOLLOW_REGULAR_ID_in_sqrt_key10026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instr_key10048_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instr_key10048( FOLLOW_REGULAR_ID_in_instr_key10048_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key10068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key10068( FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key10068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_lpad_key10090_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_lpad_key10090( FOLLOW_REGULAR_ID_in_lpad_key10090_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_boolean_key10113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_boolean_key10113( FOLLOW_REGULAR_ID_in_boolean_key10113_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rpad_key10140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rpad_key10140( FOLLOW_REGULAR_ID_in_rpad_key10140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_savepoint_key10163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_savepoint_key10163( FOLLOW_REGULAR_ID_in_savepoint_key10163_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decode_key10190_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decode_key10190( FOLLOW_REGULAR_ID_in_decode_key10190_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reverse_key10212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reverse_key10212( FOLLOW_REGULAR_ID_in_reverse_key10212_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_least_key10239_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_least_key10239( FOLLOW_REGULAR_ID_in_least_key10239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nvl_key10261_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nvl_key10261( FOLLOW_REGULAR_ID_in_nvl_key10261_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_variance_key10283_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_variance_key10283( FOLLOW_REGULAR_ID_in_variance_key10283_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_START_in_start_key10303_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_START_in_start_key10303( FOLLOW_PLSQL_RESERVED_START_in_start_key10303_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DESC_in_desc_key10323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DESC_in_desc_key10323( FOLLOW_SQL92_RESERVED_DESC_in_desc_key10323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_concat_key10345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_concat_key10345( FOLLOW_REGULAR_ID_in_concat_key10345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dump_key10367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dump_key10367( FOLLOW_REGULAR_ID_in_dump_key10367_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_soundex_key10389_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_soundex_key10389( FOLLOW_REGULAR_ID_in_soundex_key10389_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_positive_key10412_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_positive_key10412( FOLLOW_REGULAR_ID_in_positive_key10412_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UNION_in_union_key10437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UNION_in_union_key10437( FOLLOW_SQL92_RESERVED_UNION_in_union_key10437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ascii_key10459_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ascii_key10459( FOLLOW_REGULAR_ID_in_ascii_key10459_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key10479_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key10479( FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key10479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ASC_in_asc_key10499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ASC_in_asc_key10499( FOLLOW_SQL92_RESERVED_ASC_in_asc_key10499_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hextoraw_key10521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hextoraw_key10521( FOLLOW_REGULAR_ID_in_hextoraw_key10521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_date_key10543_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_date_key10543( FOLLOW_REGULAR_ID_in_to_date_key10543_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_floor_key10565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_floor_key10565( FOLLOW_REGULAR_ID_in_floor_key10565_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sign_key10587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sign_key10587( FOLLOW_REGULAR_ID_in_sign_key10587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UPDATE_in_update_key10607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UPDATE_in_update_key10607( FOLLOW_SQL92_RESERVED_UPDATE_in_update_key10607_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trunc_key10629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trunc_key10629( FOLLOW_REGULAR_ID_in_trunc_key10629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rtrim_key10651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rtrim_key10651( FOLLOW_REGULAR_ID_in_rtrim_key10651_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_close_key10674_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_close_key10674( FOLLOW_REGULAR_ID_in_close_key10674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_char_key10701_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_char_key10701( FOLLOW_REGULAR_ID_in_to_char_key10701_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ltrim_key10723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ltrim_key10723( FOLLOW_REGULAR_ID_in_ltrim_key10723_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_MODE_in_mode_key10743_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_MODE_in_mode_key10743( FOLLOW_PLSQL_RESERVED_MODE_in_mode_key10743_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_uid_key10765_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_uid_key10765( FOLLOW_REGULAR_ID_in_uid_key10765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_chr_key10787_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_chr_key10787( FOLLOW_REGULAR_ID_in_chr_key10787_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key10812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key10812( FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key10812_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_chartorowid_key10834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_chartorowid_key10834( FOLLOW_REGULAR_ID_in_chartorowid_key10834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_mlslabel_key10857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_mlslabel_key10857( FOLLOW_REGULAR_ID_in_mlslabel_key10857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_userenv_key10884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_userenv_key10884( FOLLOW_REGULAR_ID_in_userenv_key10884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stddev_key10906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stddev_key10906( FOLLOW_REGULAR_ID_in_stddev_key10906_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_length_key10928_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_length_key10928( FOLLOW_REGULAR_ID_in_length_key10928_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key10948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key10948( FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key10948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GROUP_in_group_key10968_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GROUP_in_group_key10968( FOLLOW_SQL92_RESERVED_GROUP_in_group_key10968_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sysdate_key10990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sysdate_key10990( FOLLOW_REGULAR_ID_in_sysdate_key10990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_integer_key11013_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_integer_key11013( FOLLOW_REGULAR_ID_in_binary_integer_key11013_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_number_key11040_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_number_key11040( FOLLOW_REGULAR_ID_in_to_number_key11040_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substr_key11062_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substr_key11062( FOLLOW_REGULAR_ID_in_substr_key11062_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ceil_key11084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ceil_key11084( FOLLOW_REGULAR_ID_in_ceil_key11084_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_initcap_key11106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_initcap_key11106( FOLLOW_REGULAR_ID_in_initcap_key11106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_round_key11128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_round_key11128( FOLLOW_REGULAR_ID_in_round_key11128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_long_key11151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_long_key11151( FOLLOW_REGULAR_ID_in_long_key11151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_read_key11179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_read_key11179( FOLLOW_REGULAR_ID_in_read_key11179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_only_key11206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_only_key11206( FOLLOW_REGULAR_ID_in_only_key11206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_set_key11234_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_set_key11234( FOLLOW_REGULAR_ID_in_set_key11234_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nullif_key11261_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nullif_key11261( FOLLOW_REGULAR_ID_in_nullif_key11261_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_coalesce_key11283_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_coalesce_key11283( FOLLOW_REGULAR_ID_in_coalesce_key11283_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_count_key11305_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_count_key11305( FOLLOW_REGULAR_ID_in_count_key11305_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_avg_key11331_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_avg_key11331( FOLLOW_REGULAR_ID_in_avg_key11331_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_max_key11352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_max_key11352( FOLLOW_REGULAR_ID_in_max_key11352_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_min_key11373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_min_key11373( FOLLOW_REGULAR_ID_in_min_key11373_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sum_key11394_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sum_key11394( FOLLOW_REGULAR_ID_in_sum_key11394_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unknown_key11416_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unknown_key11416( FOLLOW_REGULAR_ID_in_unknown_key11416_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_escape_key11438_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_escape_key11438( FOLLOW_REGULAR_ID_in_escape_key11438_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_some_key11460_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_some_key11460( FOLLOW_REGULAR_ID_in_some_key11460_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_match_key11487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_match_key11487( FOLLOW_REGULAR_ID_in_match_key11487_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_CAST_in_cast_key11508_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_CAST_in_cast_key11508( FOLLOW_PLSQL_NON_RESERVED_CAST_in_cast_key11508_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_full_key11526_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_full_key11526( FOLLOW_REGULAR_ID_in_full_key11526_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_partial_key11553_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_partial_key11553( FOLLOW_REGULAR_ID_in_partial_key11553_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_character_key11576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_character_key11576( FOLLOW_REGULAR_ID_in_character_key11576_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_except_key11603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_except_key11603( FOLLOW_REGULAR_ID_in_except_key11603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_key11621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_key11621( FOLLOW_REGULAR_ID_in_char_key11621_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varying_key11649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varying_key11649( FOLLOW_REGULAR_ID_in_varying_key11649_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varchar_key11672_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varchar_key11672( FOLLOW_REGULAR_ID_in_varchar_key11672_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_national_key11699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_national_key11699( FOLLOW_REGULAR_ID_in_national_key11699_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nchar_key11721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nchar_key11721( FOLLOW_REGULAR_ID_in_nchar_key11721_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bit_key11747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bit_key11747( FOLLOW_REGULAR_ID_in_bit_key11747_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_float_key11774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_float_key11774( FOLLOW_REGULAR_ID_in_float_key11774_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_real_key11801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_real_key11801( FOLLOW_REGULAR_ID_in_real_key11801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_double_key11829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_double_key11829( FOLLOW_REGULAR_ID_in_double_key11829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_precision_key11856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_precision_key11856( FOLLOW_REGULAR_ID_in_precision_key11856_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_interval_key11884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_interval_key11884( FOLLOW_REGULAR_ID_in_interval_key11884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_time_key11906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_time_key11906( FOLLOW_REGULAR_ID_in_time_key11906_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_zone_key11929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_zone_key11929( FOLLOW_REGULAR_ID_in_zone_key11929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_key11951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_key11951( FOLLOW_REGULAR_ID_in_timestamp_key11951_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DATE_in_date_key11976_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DATE_in_date_key11976( FOLLOW_SQL92_RESERVED_DATE_in_date_key11976_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_numeric_key11999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_numeric_key11999( FOLLOW_REGULAR_ID_in_numeric_key11999_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decimal_key12027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decimal_key12027( FOLLOW_REGULAR_ID_in_decimal_key12027_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dec_key12054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dec_key12054( FOLLOW_REGULAR_ID_in_dec_key12054_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_integer_key12082_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_integer_key12082( FOLLOW_REGULAR_ID_in_integer_key12082_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_int_key12109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_int_key12109( FOLLOW_REGULAR_ID_in_int_key12109_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_smallint_key12137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_smallint_key12137( FOLLOW_REGULAR_ID_in_smallint_key12137_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corresponding_key12164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corresponding_key12164( FOLLOW_REGULAR_ID_in_corresponding_key12164_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cross_key12187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cross_key12187( FOLLOW_REGULAR_ID_in_cross_key12187_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_join_key12215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_join_key12215( FOLLOW_REGULAR_ID_in_join_key12215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_left_key12238_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_left_key12238( FOLLOW_REGULAR_ID_in_left_key12238_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_right_key12266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_right_key12266( FOLLOW_REGULAR_ID_in_right_key12266_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inner_key12294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inner_key12294( FOLLOW_REGULAR_ID_in_inner_key12294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_natural_key12322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_natural_key12322( FOLLOW_REGULAR_ID_in_natural_key12322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_outer_key12350_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_outer_key12350( FOLLOW_REGULAR_ID_in_outer_key12350_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key12370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key12370( FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key12370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indicator_key12392_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indicator_key12392( FOLLOW_REGULAR_ID_in_indicator_key12392_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_user_key12414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_user_key12414( FOLLOW_REGULAR_ID_in_user_key12414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_user_key12436_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_user_key12436( FOLLOW_REGULAR_ID_in_current_user_key12436_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_session_user_key12463_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_session_user_key12463( FOLLOW_REGULAR_ID_in_session_user_key12463_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_system_user_key12485_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_system_user_key12485( FOLLOW_REGULAR_ID_in_system_user_key12485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_value_key12507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_value_key12507( FOLLOW_REGULAR_ID_in_value_key12507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substring_key12535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substring_key12535( FOLLOW_REGULAR_ID_in_substring_key12535_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_upper_key12557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_upper_key12557( FOLLOW_REGULAR_ID_in_upper_key12557_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_lower_key12579_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_lower_key12579( FOLLOW_REGULAR_ID_in_lower_key12579_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_convert_key12601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_convert_key12601( FOLLOW_REGULAR_ID_in_convert_key12601_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_translate_key12628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_translate_key12628( FOLLOW_REGULAR_ID_in_translate_key12628_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trim_key12655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trim_key12655( FOLLOW_REGULAR_ID_in_trim_key12655_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_leading_key12682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_leading_key12682( FOLLOW_REGULAR_ID_in_leading_key12682_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trailing_key12709_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trailing_key12709( FOLLOW_REGULAR_ID_in_trailing_key12709_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_both_key12736_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_both_key12736( FOLLOW_REGULAR_ID_in_both_key12736_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_collate_key12763_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_collate_key12763( FOLLOW_REGULAR_ID_in_collate_key12763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_position_key12785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_position_key12785( FOLLOW_REGULAR_ID_in_position_key12785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_extract_key12807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_extract_key12807( FOLLOW_REGULAR_ID_in_extract_key12807_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_second_key12834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_second_key12834( FOLLOW_REGULAR_ID_in_second_key12834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_hour_key12861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_hour_key12861( FOLLOW_REGULAR_ID_in_timezone_hour_key12861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_minute_key12888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_minute_key12888( FOLLOW_REGULAR_ID_in_timezone_minute_key12888_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_length_key12915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_length_key12915( FOLLOW_REGULAR_ID_in_char_length_key12915_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_octet_length_key12937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_octet_length_key12937( FOLLOW_REGULAR_ID_in_octet_length_key12937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_character_length_key12959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_character_length_key12959( FOLLOW_REGULAR_ID_in_character_length_key12959_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bit_length_key12981_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bit_length_key12981( FOLLOW_REGULAR_ID_in_bit_length_key12981_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_local_key13003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_local_key13003( FOLLOW_REGULAR_ID_in_local_key13003_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_timestamp_key13030_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_timestamp_key13030( FOLLOW_REGULAR_ID_in_current_timestamp_key13030_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_date_key13052_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_date_key13052( FOLLOW_REGULAR_ID_in_current_date_key13052_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_time_key13074_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_time_key13074( FOLLOW_REGULAR_ID_in_current_time_key13074_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_module_key13096_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_module_key13096( FOLLOW_REGULAR_ID_in_module_key13096_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_global_key13118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_global_key13118( FOLLOW_REGULAR_ID_in_global_key13118_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_year_key13141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_year_key13141( FOLLOW_REGULAR_ID_in_year_key13141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_month_key13168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_month_key13168( FOLLOW_REGULAR_ID_in_month_key13168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_day_key13196_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_day_key13196( FOLLOW_REGULAR_ID_in_day_key13196_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hour_key13218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hour_key13218( FOLLOW_REGULAR_ID_in_hour_key13218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_minute_key13245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_minute_key13245( FOLLOW_REGULAR_ID_in_minute_key13245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_whenever_key13272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_whenever_key13272( FOLLOW_REGULAR_ID_in_whenever_key13272_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_IS_in_is_key13292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_IS_in_is_key13292( FOLLOW_SQL92_RESERVED_IS_in_is_key13292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ELSE_in_else_key13312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ELSE_in_else_key13312( FOLLOW_SQL92_RESERVED_ELSE_in_else_key13312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TABLE_in_table_key13332_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TABLE_in_table_key13332( FOLLOW_SQL92_RESERVED_TABLE_in_table_key13332_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_THE_in_the_key13352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_THE_in_the_key13352( FOLLOW_SQL92_RESERVED_THE_in_the_key13352_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_THEN_in_then_key13372_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_THEN_in_then_key13372( FOLLOW_SQL92_RESERVED_THEN_in_then_key13372_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_END_in_end_key13392_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_END_in_end_key13392( FOLLOW_SQL92_RESERVED_END_in_end_key13392_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ALL_in_all_key13412_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ALL_in_all_key13412( FOLLOW_SQL92_RESERVED_ALL_in_all_key13412_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ON_in_on_key13432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ON_in_on_key13432( FOLLOW_SQL92_RESERVED_ON_in_on_key13432_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OR_in_or_key13452_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OR_in_or_key13452( FOLLOW_SQL92_RESERVED_OR_in_or_key13452_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_AND_in_and_key13472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_AND_in_and_key13472( FOLLOW_SQL92_RESERVED_AND_in_and_key13472_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_NOT_in_not_key13492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_NOT_in_not_key13492( FOLLOW_SQL92_RESERVED_NOT_in_not_key13492_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TRUE_in_true_key13512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TRUE_in_true_key13512( FOLLOW_SQL92_RESERVED_TRUE_in_true_key13512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FALSE_in_false_key13532_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FALSE_in_false_key13532( FOLLOW_SQL92_RESERVED_FALSE_in_false_key13532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key13552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key13552( FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key13552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key13572_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key13572( FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key13572_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INTO_in_into_key13592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INTO_in_into_key13592( FOLLOW_SQL92_RESERVED_INTO_in_into_key13592_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BY_in_by_key13612_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BY_in_by_key13612( FOLLOW_SQL92_RESERVED_BY_in_by_key13612_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_AS_in_as_key13632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_AS_in_as_key13632( FOLLOW_SQL92_RESERVED_AS_in_as_key13632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_IN_in_in_key13652_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_IN_in_in_key13652( FOLLOW_SQL92_RESERVED_IN_in_in_key13652_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OF_in_of_key13672_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OF_in_of_key13672( FOLLOW_SQL92_RESERVED_OF_in_of_key13672_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_NULL_in_null_key13692_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_NULL_in_null_key13692( FOLLOW_SQL92_RESERVED_NULL_in_null_key13692_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FOR_in_for_key13712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FOR_in_for_key13712( FOLLOW_SQL92_RESERVED_FOR_in_for_key13712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_SELECT_in_select_key13732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_SELECT_in_select_key13732( FOLLOW_SQL92_RESERVED_SELECT_in_select_key13732_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WHEN_in_when_key13752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WHEN_in_when_key13752( FOLLOW_SQL92_RESERVED_WHEN_in_when_key13752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DELETE_in_delete_key13772_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DELETE_in_delete_key13772( FOLLOW_SQL92_RESERVED_DELETE_in_delete_key13772_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key13792_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key13792( FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key13792_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_LIKE_in_like_key13812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_LIKE_in_like_key13812( FOLLOW_SQL92_RESERVED_LIKE_in_like_key13812_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FROM_in_from_key13834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FROM_in_from_key13834( FOLLOW_SQL92_RESERVED_FROM_in_from_key13834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WHERE_in_where_key13861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WHERE_in_where_key13861( FOLLOW_SQL92_RESERVED_WHERE_in_where_key13861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sequence_key13888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sequence_key13888( FOLLOW_REGULAR_ID_in_sequence_key13888_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noorder_key13915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noorder_key13915( FOLLOW_REGULAR_ID_in_noorder_key13915_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cycle_key13942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cycle_key13942( FOLLOW_REGULAR_ID_in_cycle_key13942_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cache_key13969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cache_key13969( FOLLOW_REGULAR_ID_in_cache_key13969_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocache_key13996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocache_key13996( FOLLOW_REGULAR_ID_in_nocache_key13996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nomaxvalue_key14023_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nomaxvalue_key14023( FOLLOW_REGULAR_ID_in_nomaxvalue_key14023_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nominvalue_key14050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nominvalue_key14050( FOLLOW_REGULAR_ID_in_nominvalue_key14050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_search_key14077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_search_key14077( FOLLOW_REGULAR_ID_in_search_key14077_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_depth_key14104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_depth_key14104( FOLLOW_REGULAR_ID_in_depth_key14104_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_breadth_key14131_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_breadth_key14131( FOLLOW_REGULAR_ID_in_breadth_key14131_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start create_key
 * OracleDMLKeys.g:352:1: create_key : SQL92_RESERVED_CREATE ;
 */
OracleDML_OracleDMLKeys::create_key_return
OracleDML_OracleDMLKeys::create_key()
{
    OracleDML_OracleDMLKeys::create_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_CREATE1 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_CREATE1_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:353:5: ( SQL92_RESERVED_CREATE )
        // OracleDMLKeys.g:353:10: SQL92_RESERVED_CREATE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_CREATE1 =  this->matchToken(SQL92_RESERVED_CREATE, &FOLLOW_SQL92_RESERVED_CREATE_in_create_key367);
            if  (this->hasException())
            {
                goto rulecreate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_CREATE1_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_CREATE1));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_CREATE1_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecreate_keyEx; /* Prevent compiler warnings */
    rulecreate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end create_key */

/**
 * $ANTLR start replace_key
 * OracleDMLKeys.g:356:1: replace_key :{...}? => REGULAR_ID -> REPLACE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::replace_key_return
OracleDML_OracleDMLKeys::replace_key()
{
    OracleDML_OracleDMLKeys::replace_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID2 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID2_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:357:5: ({...}? => REGULAR_ID -> REPLACE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:357:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REPLACE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REPLACE\"" );
                    ex->set_ruleName( "replace_key" );


            }

            REGULAR_ID2 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_replace_key394);
            if  (this->hasException())
            {
                goto rulereplace_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID2);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 357:65: -> REPLACE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REPLACE_VK, REGULAR_ID2));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereplace_keyEx; /* Prevent compiler warnings */
    rulereplace_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end replace_key */

/**
 * $ANTLR start package_key
 * OracleDMLKeys.g:360:1: package_key :{...}? => REGULAR_ID -> PACKAGE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::package_key_return
OracleDML_OracleDMLKeys::package_key()
{
    OracleDML_OracleDMLKeys::package_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID3 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID3_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:361:5: ({...}? => REGULAR_ID -> PACKAGE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:361:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PACKAGE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PACKAGE\"" );
                    ex->set_ruleName( "package_key" );


            }

            REGULAR_ID3 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_package_key422);
            if  (this->hasException())
            {
                goto rulepackage_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID3);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 361:65: -> PACKAGE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PACKAGE_VK, REGULAR_ID3));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepackage_keyEx; /* Prevent compiler warnings */
    rulepackage_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end package_key */

/**
 * $ANTLR start body_key
 * OracleDMLKeys.g:364:1: body_key :{...}? REGULAR_ID -> BODY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::body_key_return
OracleDML_OracleDMLKeys::body_key()
{
    OracleDML_OracleDMLKeys::body_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID4 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID4_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:365:5: ({...}? REGULAR_ID -> BODY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:365:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BODY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BODY\"" );
                    ex->set_ruleName( "body_key" );


            }

            REGULAR_ID4 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_body_key449);
            if  (this->hasException())
            {
                goto rulebody_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID4);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 365:60: -> BODY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BODY_VK, REGULAR_ID4));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebody_keyEx; /* Prevent compiler warnings */
    rulebody_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end body_key */

/**
 * $ANTLR start begin_key
 * OracleDMLKeys.g:368:1: begin_key : SQL92_RESERVED_BEGIN ;
 */
OracleDML_OracleDMLKeys::begin_key_return
OracleDML_OracleDMLKeys::begin_key()
{
    OracleDML_OracleDMLKeys::begin_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_BEGIN5 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_BEGIN5_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:369:5: ( SQL92_RESERVED_BEGIN )
        // OracleDMLKeys.g:369:10: SQL92_RESERVED_BEGIN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_BEGIN5 =  this->matchToken(SQL92_RESERVED_BEGIN, &FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key474);
            if  (this->hasException())
            {
                goto rulebegin_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_BEGIN5_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_BEGIN5));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_BEGIN5_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebegin_keyEx; /* Prevent compiler warnings */
    rulebegin_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end begin_key */

/**
 * $ANTLR start exit_key
 * OracleDMLKeys.g:372:1: exit_key :{...}? REGULAR_ID -> EXIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::exit_key_return
OracleDML_OracleDMLKeys::exit_key()
{
    OracleDML_OracleDMLKeys::exit_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID6 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID6_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:372:9: ({...}? REGULAR_ID -> EXIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:372:14: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EXIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXIT\"" );
                    ex->set_ruleName( "exit_key" );


            }

            REGULAR_ID6 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exit_key491);
            if  (this->hasException())
            {
                goto ruleexit_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID6);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 372:64: -> EXIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EXIT_VK, REGULAR_ID6));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexit_keyEx; /* Prevent compiler warnings */
    ruleexit_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exit_key */

/**
 * $ANTLR start declare_key
 * OracleDMLKeys.g:375:1: declare_key : SQL92_RESERVED_DECLARE ;
 */
OracleDML_OracleDMLKeys::declare_key_return
OracleDML_OracleDMLKeys::declare_key()
{
    OracleDML_OracleDMLKeys::declare_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_DECLARE7 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_DECLARE7_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:376:5: ( SQL92_RESERVED_DECLARE )
        // OracleDMLKeys.g:376:10: SQL92_RESERVED_DECLARE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_DECLARE7 =  this->matchToken(SQL92_RESERVED_DECLARE, &FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key516);
            if  (this->hasException())
            {
                goto ruledeclare_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_DECLARE7_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_DECLARE7));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_DECLARE7_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledeclare_keyEx; /* Prevent compiler warnings */
    ruledeclare_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end declare_key */

/**
 * $ANTLR start exception_key
 * OracleDMLKeys.g:379:1: exception_key : SQL92_RESERVED_EXCEPTION ;
 */
OracleDML_OracleDMLKeys::exception_key_return
OracleDML_OracleDMLKeys::exception_key()
{
    OracleDML_OracleDMLKeys::exception_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_EXCEPTION8 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_EXCEPTION8_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:380:5: ( SQL92_RESERVED_EXCEPTION )
        // OracleDMLKeys.g:380:10: SQL92_RESERVED_EXCEPTION
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_EXCEPTION8 =  this->matchToken(SQL92_RESERVED_EXCEPTION, &FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key536);
            if  (this->hasException())
            {
                goto ruleexception_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_EXCEPTION8_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_EXCEPTION8));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_EXCEPTION8_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexception_keyEx; /* Prevent compiler warnings */
    ruleexception_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exception_key */

/**
 * $ANTLR start serveroutput_key
 * OracleDMLKeys.g:383:1: serveroutput_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::serveroutput_key_return
OracleDML_OracleDMLKeys::serveroutput_key()
{
    OracleDML_OracleDMLKeys::serveroutput_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID9 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID9_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:384:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:384:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SERVEROUTPUT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SERVEROUTPUT\"" );
                    ex->set_ruleName( "serveroutput_key" );


            }

            REGULAR_ID9 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serveroutput_key558);
            if  (this->hasException())
            {
                goto ruleserveroutput_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID9_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID9));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID9_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleserveroutput_keyEx; /* Prevent compiler warnings */
    ruleserveroutput_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end serveroutput_key */

/**
 * $ANTLR start off_key
 * OracleDMLKeys.g:387:1: off_key :{...}? REGULAR_ID -> OFF_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::off_key_return
OracleDML_OracleDMLKeys::off_key()
{
    OracleDML_OracleDMLKeys::off_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID10 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID10_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:388:5: ({...}? REGULAR_ID -> OFF_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:388:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "OFF")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OFF\"" );
                    ex->set_ruleName( "off_key" );


            }

            REGULAR_ID10 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_off_key580);
            if  (this->hasException())
            {
                goto ruleoff_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID10);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 388:59: -> OFF_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(OFF_VK, REGULAR_ID10));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleoff_keyEx; /* Prevent compiler warnings */
    ruleoff_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end off_key */

/**
 * $ANTLR start constant_key
 * OracleDMLKeys.g:391:1: constant_key :{...}? REGULAR_ID -> CONSTANT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::constant_key_return
OracleDML_OracleDMLKeys::constant_key()
{
    OracleDML_OracleDMLKeys::constant_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID11 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID11_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:392:5: ({...}? REGULAR_ID -> CONSTANT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:392:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CONSTANT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONSTANT\"" );
                    ex->set_ruleName( "constant_key" );


            }

            REGULAR_ID11 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constant_key607);
            if  (this->hasException())
            {
                goto ruleconstant_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID11);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 392:64: -> CONSTANT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CONSTANT_VK, REGULAR_ID11));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconstant_keyEx; /* Prevent compiler warnings */
    ruleconstant_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end constant_key */

/**
 * $ANTLR start subtype_key
 * OracleDMLKeys.g:395:1: subtype_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::subtype_key_return
OracleDML_OracleDMLKeys::subtype_key()
{
    OracleDML_OracleDMLKeys::subtype_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID12 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID12_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:396:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:396:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SUBTYPE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUBTYPE\"" );
                    ex->set_ruleName( "subtype_key" );


            }

            REGULAR_ID12 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_subtype_key634);
            if  (this->hasException())
            {
                goto rulesubtype_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID12_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID12));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID12_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubtype_keyEx; /* Prevent compiler warnings */
    rulesubtype_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end subtype_key */

/**
 * $ANTLR start cursor_key
 * OracleDMLKeys.g:399:1: cursor_key : SQL92_RESERVED_CURSOR ;
 */
OracleDML_OracleDMLKeys::cursor_key_return
OracleDML_OracleDMLKeys::cursor_key()
{
    OracleDML_OracleDMLKeys::cursor_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_CURSOR13 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_CURSOR13_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:400:5: ( SQL92_RESERVED_CURSOR )
        // OracleDMLKeys.g:400:10: SQL92_RESERVED_CURSOR
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_CURSOR13 =  this->matchToken(SQL92_RESERVED_CURSOR, &FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key654);
            if  (this->hasException())
            {
                goto rulecursor_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_CURSOR13_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_CURSOR13));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_CURSOR13_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecursor_keyEx; /* Prevent compiler warnings */
    rulecursor_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cursor_key */

/**
 * $ANTLR start nextval_key
 * OracleDMLKeys.g:403:1: nextval_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::nextval_key_return
OracleDML_OracleDMLKeys::nextval_key()
{
    OracleDML_OracleDMLKeys::nextval_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID14 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID14_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:404:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:404:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "NEXTVAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NEXTVAL\"" );
                    ex->set_ruleName( "nextval_key" );


            }

            REGULAR_ID14 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nextval_key677);
            if  (this->hasException())
            {
                goto rulenextval_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID14_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID14));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID14_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenextval_keyEx; /* Prevent compiler warnings */
    rulenextval_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nextval_key */

/**
 * $ANTLR start goto_key
 * OracleDMLKeys.g:407:1: goto_key : SQL92_RESERVED_GOTO ;
 */
OracleDML_OracleDMLKeys::goto_key_return
OracleDML_OracleDMLKeys::goto_key()
{
    OracleDML_OracleDMLKeys::goto_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_GOTO15 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_GOTO15_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:408:5: ( SQL92_RESERVED_GOTO )
        // OracleDMLKeys.g:408:10: SQL92_RESERVED_GOTO
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_GOTO15 =  this->matchToken(SQL92_RESERVED_GOTO, &FOLLOW_SQL92_RESERVED_GOTO_in_goto_key697);
            if  (this->hasException())
            {
                goto rulegoto_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_GOTO15_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_GOTO15));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_GOTO15_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegoto_keyEx; /* Prevent compiler warnings */
    rulegoto_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end goto_key */

/**
 * $ANTLR start execute_key
 * OracleDMLKeys.g:411:1: execute_key :{...}? REGULAR_ID -> EXECUTE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::execute_key_return
OracleDML_OracleDMLKeys::execute_key()
{
    OracleDML_OracleDMLKeys::execute_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID16 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID16_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:412:5: ({...}? REGULAR_ID -> EXECUTE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:412:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EXECUTE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXECUTE\"" );
                    ex->set_ruleName( "execute_key" );


            }

            REGULAR_ID16 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_execute_key719);
            if  (this->hasException())
            {
                goto ruleexecute_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID16);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 412:63: -> EXECUTE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EXECUTE_VK, REGULAR_ID16));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexecute_keyEx; /* Prevent compiler warnings */
    ruleexecute_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end execute_key */

/**
 * $ANTLR start immediate_key
 * OracleDMLKeys.g:415:1: immediate_key :{...}? => REGULAR_ID -> IMMEDIATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::immediate_key_return
OracleDML_OracleDMLKeys::immediate_key()
{
    OracleDML_OracleDMLKeys::immediate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID17 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID17_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:416:5: ({...}? => REGULAR_ID -> IMMEDIATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:416:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "IMMEDIATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"IMMEDIATE\"" );
                    ex->set_ruleName( "immediate_key" );


            }

            REGULAR_ID17 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_immediate_key747);
            if  (this->hasException())
            {
                goto ruleimmediate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID17);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 416:67: -> IMMEDIATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(IMMEDIATE_VK, REGULAR_ID17));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleimmediate_keyEx; /* Prevent compiler warnings */
    ruleimmediate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end immediate_key */

/**
 * $ANTLR start return_key
 * OracleDMLKeys.g:419:1: return_key :{...}? REGULAR_ID -> RETURN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::return_key_return
OracleDML_OracleDMLKeys::return_key()
{
    OracleDML_OracleDMLKeys::return_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID18 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID18_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:420:5: ({...}? REGULAR_ID -> RETURN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:420:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RETURN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RETURN\"" );
                    ex->set_ruleName( "return_key" );


            }

            REGULAR_ID18 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_return_key774);
            if  (this->hasException())
            {
                goto rulereturn_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID18);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 420:62: -> RETURN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RETURN_VK, REGULAR_ID18));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereturn_keyEx; /* Prevent compiler warnings */
    rulereturn_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end return_key */

/**
 * $ANTLR start procedure_key
 * OracleDMLKeys.g:423:1: procedure_key : SQL92_RESERVED_PROCEDURE ;
 */
OracleDML_OracleDMLKeys::procedure_key_return
OracleDML_OracleDMLKeys::procedure_key()
{
    OracleDML_OracleDMLKeys::procedure_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_PROCEDURE19 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_PROCEDURE19_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:424:5: ( SQL92_RESERVED_PROCEDURE )
        // OracleDMLKeys.g:424:10: SQL92_RESERVED_PROCEDURE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_PROCEDURE19 =  this->matchToken(SQL92_RESERVED_PROCEDURE, &FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key799);
            if  (this->hasException())
            {
                goto ruleprocedure_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_PROCEDURE19_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_PROCEDURE19));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_PROCEDURE19_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleprocedure_keyEx; /* Prevent compiler warnings */
    ruleprocedure_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end procedure_key */

/**
 * $ANTLR start function_key
 * OracleDMLKeys.g:427:1: function_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::function_key_return
OracleDML_OracleDMLKeys::function_key()
{
    OracleDML_OracleDMLKeys::function_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID20 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID20_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:428:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:428:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "FUNCTION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FUNCTION\"" );
                    ex->set_ruleName( "function_key" );


            }

            REGULAR_ID20 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_function_key822);
            if  (this->hasException())
            {
                goto rulefunction_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID20_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID20));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID20_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefunction_keyEx; /* Prevent compiler warnings */
    rulefunction_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end function_key */

/**
 * $ANTLR start pragma_key
 * OracleDMLKeys.g:431:1: pragma_key :{...}? REGULAR_ID -> PRAGMA_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::pragma_key_return
OracleDML_OracleDMLKeys::pragma_key()
{
    OracleDML_OracleDMLKeys::pragma_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID21 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID21_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:432:5: ({...}? REGULAR_ID -> PRAGMA_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:432:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PRAGMA")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PRAGMA\"" );
                    ex->set_ruleName( "pragma_key" );


            }

            REGULAR_ID21 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pragma_key844);
            if  (this->hasException())
            {
                goto rulepragma_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID21);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 432:62: -> PRAGMA_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PRAGMA_VK, REGULAR_ID21));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepragma_keyEx; /* Prevent compiler warnings */
    rulepragma_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pragma_key */

/**
 * $ANTLR start exception_init_key
 * OracleDMLKeys.g:435:1: exception_init_key :{...}? REGULAR_ID -> EXCEPTION_INIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::exception_init_key_return
OracleDML_OracleDMLKeys::exception_init_key()
{
    OracleDML_OracleDMLKeys::exception_init_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID22 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID22_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:436:5: ({...}? REGULAR_ID -> EXCEPTION_INIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:436:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EXCEPTION_INIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXCEPTION_INIT\"" );
                    ex->set_ruleName( "exception_init_key" );


            }

            REGULAR_ID22 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exception_init_key871);
            if  (this->hasException())
            {
                goto ruleexception_init_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID22);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 436:70: -> EXCEPTION_INIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EXCEPTION_INIT_VK, REGULAR_ID22));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexception_init_keyEx; /* Prevent compiler warnings */
    ruleexception_init_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exception_init_key */

/**
 * $ANTLR start type_key
 * OracleDMLKeys.g:439:1: type_key :{...}? => REGULAR_ID -> TYPE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::type_key_return
OracleDML_OracleDMLKeys::type_key()
{
    OracleDML_OracleDMLKeys::type_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID23 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID23_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:440:5: ({...}? => REGULAR_ID -> TYPE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:440:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TYPE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TYPE\"" );
                    ex->set_ruleName( "type_key" );


            }

            REGULAR_ID23 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_type_key899);
            if  (this->hasException())
            {
                goto ruletype_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID23);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 440:62: -> TYPE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TYPE_VK, REGULAR_ID23));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletype_keyEx; /* Prevent compiler warnings */
    ruletype_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end type_key */

/**
 * $ANTLR start record_key
 * OracleDMLKeys.g:443:1: record_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::record_key_return
OracleDML_OracleDMLKeys::record_key()
{
    OracleDML_OracleDMLKeys::record_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID24 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID24_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:444:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:444:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "RECORD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RECORD\"" );
                    ex->set_ruleName( "record_key" );


            }

            REGULAR_ID24 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_record_key927);
            if  (this->hasException())
            {
                goto rulerecord_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID24_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID24));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID24_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerecord_keyEx; /* Prevent compiler warnings */
    rulerecord_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end record_key */

/**
 * $ANTLR start indexed_key
 * OracleDMLKeys.g:447:1: indexed_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::indexed_key_return
OracleDML_OracleDMLKeys::indexed_key()
{
    OracleDML_OracleDMLKeys::indexed_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID25 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID25_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:448:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:448:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "INDEXED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INDEXED\"" );
                    ex->set_ruleName( "indexed_key" );


            }

            REGULAR_ID25 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indexed_key949);
            if  (this->hasException())
            {
                goto ruleindexed_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID25_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID25));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID25_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleindexed_keyEx; /* Prevent compiler warnings */
    ruleindexed_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end indexed_key */

/**
 * $ANTLR start index_key
 * OracleDMLKeys.g:451:1: index_key : PLSQL_RESERVED_INDEX ;
 */
OracleDML_OracleDMLKeys::index_key_return
OracleDML_OracleDMLKeys::index_key()
{
    OracleDML_OracleDMLKeys::index_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_INDEX26 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_INDEX26_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:452:5: ( PLSQL_RESERVED_INDEX )
        // OracleDMLKeys.g:452:10: PLSQL_RESERVED_INDEX
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_INDEX26 =  this->matchToken(PLSQL_RESERVED_INDEX, &FOLLOW_PLSQL_RESERVED_INDEX_in_index_key969);
            if  (this->hasException())
            {
                goto ruleindex_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_INDEX26_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_INDEX26));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_INDEX26_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleindex_keyEx; /* Prevent compiler warnings */
    ruleindex_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end index_key */

/**
 * $ANTLR start percent_notfound_key
 * OracleDMLKeys.g:455:1: percent_notfound_key :{...}? => PERCENT REGULAR_ID -> PERCENT_NOTFOUND_VK[$REGULAR_ID, $REGULAR_ID.text] ;
 */
OracleDML_OracleDMLKeys::percent_notfound_key_return
OracleDML_OracleDMLKeys::percent_notfound_key()
{
    OracleDML_OracleDMLKeys::percent_notfound_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERCENT27 = NULL;
    ImplTraits::CommonTokenType const* REGULAR_ID28 = NULL;

    ImplTraits::TreeTypePtr PERCENT27_tree;
    ImplTraits::TreeTypePtr REGULAR_ID28_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERCENT(get_psrstate()->get_treeAdaptor(), "token PERCENT");
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:456:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_NOTFOUND_VK[$REGULAR_ID, $REGULAR_ID.text] )
        // OracleDMLKeys.g:456:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((toUpper(LT(2)->getText()) == "NOTFOUND")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(2)->getText()) == \"NOTFOUND\"" );
                    ex->set_ruleName( "percent_notfound_key" );


            }

            PERCENT27 =  this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_notfound_key992);
            if  (this->hasException())
            {
                goto rulepercent_notfound_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_PERCENT.add(PERCENT27);


            REGULAR_ID28 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_notfound_key994);
            if  (this->hasException())
            {
                goto rulepercent_notfound_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID28);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 456:74: -> PERCENT_NOTFOUND_VK[$REGULAR_ID, $REGULAR_ID.text]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PERCENT_NOTFOUND_VK, REGULAR_ID28, (REGULAR_ID28->getText())));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepercent_notfound_keyEx; /* Prevent compiler warnings */
    rulepercent_notfound_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end percent_notfound_key */

/**
 * $ANTLR start percent_found_key
 * OracleDMLKeys.g:459:1: percent_found_key :{...}? => PERCENT REGULAR_ID -> PERCENT_FOUND_VK[$REGULAR_ID, $REGULAR_ID.text] ;
 */
OracleDML_OracleDMLKeys::percent_found_key_return
OracleDML_OracleDMLKeys::percent_found_key()
{
    OracleDML_OracleDMLKeys::percent_found_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERCENT29 = NULL;
    ImplTraits::CommonTokenType const* REGULAR_ID30 = NULL;

    ImplTraits::TreeTypePtr PERCENT29_tree;
    ImplTraits::TreeTypePtr REGULAR_ID30_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERCENT(get_psrstate()->get_treeAdaptor(), "token PERCENT");
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:460:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_FOUND_VK[$REGULAR_ID, $REGULAR_ID.text] )
        // OracleDMLKeys.g:460:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((toUpper(LT(2)->getText()) == "FOUND")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(2)->getText()) == \"FOUND\"" );
                    ex->set_ruleName( "percent_found_key" );


            }

            PERCENT29 =  this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_found_key1022);
            if  (this->hasException())
            {
                goto rulepercent_found_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_PERCENT.add(PERCENT29);


            REGULAR_ID30 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_found_key1024);
            if  (this->hasException())
            {
                goto rulepercent_found_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID30);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 460:71: -> PERCENT_FOUND_VK[$REGULAR_ID, $REGULAR_ID.text]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PERCENT_FOUND_VK, REGULAR_ID30, (REGULAR_ID30->getText())));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepercent_found_keyEx; /* Prevent compiler warnings */
    rulepercent_found_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end percent_found_key */

/**
 * $ANTLR start percent_isopen_key
 * OracleDMLKeys.g:463:1: percent_isopen_key :{...}? => PERCENT REGULAR_ID -> PERCENT_ISOPEN_VK[$REGULAR_ID, $REGULAR_ID.text] ;
 */
OracleDML_OracleDMLKeys::percent_isopen_key_return
OracleDML_OracleDMLKeys::percent_isopen_key()
{
    OracleDML_OracleDMLKeys::percent_isopen_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERCENT31 = NULL;
    ImplTraits::CommonTokenType const* REGULAR_ID32 = NULL;

    ImplTraits::TreeTypePtr PERCENT31_tree;
    ImplTraits::TreeTypePtr REGULAR_ID32_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERCENT(get_psrstate()->get_treeAdaptor(), "token PERCENT");
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:464:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_ISOPEN_VK[$REGULAR_ID, $REGULAR_ID.text] )
        // OracleDMLKeys.g:464:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((toUpper(LT(2)->getText()) == "ISOPEN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(2)->getText()) == \"ISOPEN\"" );
                    ex->set_ruleName( "percent_isopen_key" );


            }

            PERCENT31 =  this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_isopen_key1052);
            if  (this->hasException())
            {
                goto rulepercent_isopen_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_PERCENT.add(PERCENT31);


            REGULAR_ID32 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_isopen_key1054);
            if  (this->hasException())
            {
                goto rulepercent_isopen_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID32);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 464:72: -> PERCENT_ISOPEN_VK[$REGULAR_ID, $REGULAR_ID.text]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PERCENT_ISOPEN_VK, REGULAR_ID32, (REGULAR_ID32->getText())));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepercent_isopen_keyEx; /* Prevent compiler warnings */
    rulepercent_isopen_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end percent_isopen_key */

/**
 * $ANTLR start percent_rowcount_key
 * OracleDMLKeys.g:467:1: percent_rowcount_key :{...}? => PERCENT REGULAR_ID -> PERCENT_ROWCOUNT_VK[$REGULAR_ID, $REGULAR_ID.text] ;
 */
OracleDML_OracleDMLKeys::percent_rowcount_key_return
OracleDML_OracleDMLKeys::percent_rowcount_key()
{
    OracleDML_OracleDMLKeys::percent_rowcount_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERCENT33 = NULL;
    ImplTraits::CommonTokenType const* REGULAR_ID34 = NULL;

    ImplTraits::TreeTypePtr PERCENT33_tree;
    ImplTraits::TreeTypePtr REGULAR_ID34_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERCENT(get_psrstate()->get_treeAdaptor(), "token PERCENT");
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:468:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_ROWCOUNT_VK[$REGULAR_ID, $REGULAR_ID.text] )
        // OracleDMLKeys.g:468:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((toUpper(LT(2)->getText()) == "ROWCOUNT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(2)->getText()) == \"ROWCOUNT\"" );
                    ex->set_ruleName( "percent_rowcount_key" );


            }

            PERCENT33 =  this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_rowcount_key1082);
            if  (this->hasException())
            {
                goto rulepercent_rowcount_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_PERCENT.add(PERCENT33);


            REGULAR_ID34 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_rowcount_key1084);
            if  (this->hasException())
            {
                goto rulepercent_rowcount_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID34);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 468:74: -> PERCENT_ROWCOUNT_VK[$REGULAR_ID, $REGULAR_ID.text]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PERCENT_ROWCOUNT_VK, REGULAR_ID34, (REGULAR_ID34->getText())));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepercent_rowcount_keyEx; /* Prevent compiler warnings */
    rulepercent_rowcount_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end percent_rowcount_key */

/**
 * $ANTLR start percent_rowtype_key
 * OracleDMLKeys.g:471:1: percent_rowtype_key :{...}? => PERCENT REGULAR_ID -> PERCENT_ROWTYPE_VK[$REGULAR_ID, $REGULAR_ID.text] ;
 */
OracleDML_OracleDMLKeys::percent_rowtype_key_return
OracleDML_OracleDMLKeys::percent_rowtype_key()
{
    OracleDML_OracleDMLKeys::percent_rowtype_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERCENT35 = NULL;
    ImplTraits::CommonTokenType const* REGULAR_ID36 = NULL;

    ImplTraits::TreeTypePtr PERCENT35_tree;
    ImplTraits::TreeTypePtr REGULAR_ID36_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERCENT(get_psrstate()->get_treeAdaptor(), "token PERCENT");
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:472:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_ROWTYPE_VK[$REGULAR_ID, $REGULAR_ID.text] )
        // OracleDMLKeys.g:472:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((toUpper(LT(2)->getText()) == "ROWTYPE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(2)->getText()) == \"ROWTYPE\"" );
                    ex->set_ruleName( "percent_rowtype_key" );


            }

            PERCENT35 =  this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_rowtype_key1112);
            if  (this->hasException())
            {
                goto rulepercent_rowtype_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_PERCENT.add(PERCENT35);


            REGULAR_ID36 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_rowtype_key1114);
            if  (this->hasException())
            {
                goto rulepercent_rowtype_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID36);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 472:73: -> PERCENT_ROWTYPE_VK[$REGULAR_ID, $REGULAR_ID.text]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PERCENT_ROWTYPE_VK, REGULAR_ID36, (REGULAR_ID36->getText())));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepercent_rowtype_keyEx; /* Prevent compiler warnings */
    rulepercent_rowtype_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end percent_rowtype_key */

/**
 * $ANTLR start percent_type_key
 * OracleDMLKeys.g:475:1: percent_type_key :{...}? => PERCENT REGULAR_ID -> PERCENT_TYPE_VK[$REGULAR_ID, $REGULAR_ID.text] ;
 */
OracleDML_OracleDMLKeys::percent_type_key_return
OracleDML_OracleDMLKeys::percent_type_key()
{
    OracleDML_OracleDMLKeys::percent_type_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERCENT37 = NULL;
    ImplTraits::CommonTokenType const* REGULAR_ID38 = NULL;

    ImplTraits::TreeTypePtr PERCENT37_tree;
    ImplTraits::TreeTypePtr REGULAR_ID38_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERCENT(get_psrstate()->get_treeAdaptor(), "token PERCENT");
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:476:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_TYPE_VK[$REGULAR_ID, $REGULAR_ID.text] )
        // OracleDMLKeys.g:476:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((toUpper(LT(2)->getText()) == "TYPE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(2)->getText()) == \"TYPE\"" );
                    ex->set_ruleName( "percent_type_key" );


            }

            PERCENT37 =  this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_type_key1143);
            if  (this->hasException())
            {
                goto rulepercent_type_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_PERCENT.add(PERCENT37);


            REGULAR_ID38 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_type_key1145);
            if  (this->hasException())
            {
                goto rulepercent_type_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID38);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 476:70: -> PERCENT_TYPE_VK[$REGULAR_ID, $REGULAR_ID.text]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PERCENT_TYPE_VK, REGULAR_ID38, (REGULAR_ID38->getText())));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepercent_type_keyEx; /* Prevent compiler warnings */
    rulepercent_type_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end percent_type_key */

/**
 * $ANTLR start out_key
 * OracleDMLKeys.g:479:1: out_key :{...}? => REGULAR_ID -> OUT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::out_key_return
OracleDML_OracleDMLKeys::out_key()
{
    OracleDML_OracleDMLKeys::out_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID39 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID39_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:480:5: ({...}? => REGULAR_ID -> OUT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:480:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "OUT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OUT\"" );
                    ex->set_ruleName( "out_key" );


            }

            REGULAR_ID39 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_out_key1173);
            if  (this->hasException())
            {
                goto ruleout_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID39);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 480:61: -> OUT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(OUT_VK, REGULAR_ID39));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleout_keyEx; /* Prevent compiler warnings */
    ruleout_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end out_key */

/**
 * $ANTLR start inout_key
 * OracleDMLKeys.g:483:1: inout_key :{...}? REGULAR_ID -> INOUT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::inout_key_return
OracleDML_OracleDMLKeys::inout_key()
{
    OracleDML_OracleDMLKeys::inout_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID40 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID40_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:484:5: ({...}? REGULAR_ID -> INOUT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:484:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INOUT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INOUT\"" );
                    ex->set_ruleName( "inout_key" );


            }

            REGULAR_ID40 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inout_key1200);
            if  (this->hasException())
            {
                goto ruleinout_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID40);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 484:61: -> INOUT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INOUT_VK, REGULAR_ID40));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinout_keyEx; /* Prevent compiler warnings */
    ruleinout_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end inout_key */

/**
 * $ANTLR start extend_key
 * OracleDMLKeys.g:487:1: extend_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::extend_key_return
OracleDML_OracleDMLKeys::extend_key()
{
    OracleDML_OracleDMLKeys::extend_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID41 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID41_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:488:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:488:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "EXTEND")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXTEND\"" );
                    ex->set_ruleName( "extend_key" );


            }

            REGULAR_ID41 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_extend_key1228);
            if  (this->hasException())
            {
                goto ruleextend_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID41_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID41));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID41_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleextend_keyEx; /* Prevent compiler warnings */
    ruleextend_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end extend_key */

/**
 * $ANTLR start raise_key
 * OracleDMLKeys.g:491:1: raise_key :{...}? REGULAR_ID -> RAISE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::raise_key_return
OracleDML_OracleDMLKeys::raise_key()
{
    OracleDML_OracleDMLKeys::raise_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID42 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID42_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:492:5: ({...}? REGULAR_ID -> RAISE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:492:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RAISE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RAISE\"" );
                    ex->set_ruleName( "raise_key" );


            }

            REGULAR_ID42 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_raise_key1250);
            if  (this->hasException())
            {
                goto ruleraise_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID42);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 492:61: -> RAISE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RAISE_VK, REGULAR_ID42));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleraise_keyEx; /* Prevent compiler warnings */
    ruleraise_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end raise_key */

/**
 * $ANTLR start while_key
 * OracleDMLKeys.g:495:1: while_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::while_key_return
OracleDML_OracleDMLKeys::while_key()
{
    OracleDML_OracleDMLKeys::while_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID43 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID43_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:496:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:496:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "WHILE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WHILE\"" );
                    ex->set_ruleName( "while_key" );


            }

            REGULAR_ID43 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_while_key1277);
            if  (this->hasException())
            {
                goto rulewhile_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID43_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID43));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID43_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewhile_keyEx; /* Prevent compiler warnings */
    rulewhile_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end while_key */

/**
 * $ANTLR start loop_key
 * OracleDMLKeys.g:499:1: loop_key :{...}? REGULAR_ID -> LOOP_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::loop_key_return
OracleDML_OracleDMLKeys::loop_key()
{
    OracleDML_OracleDMLKeys::loop_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID44 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID44_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:500:5: ({...}? REGULAR_ID -> LOOP_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:500:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LOOP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LOOP\"" );
                    ex->set_ruleName( "loop_key" );


            }

            REGULAR_ID44 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_loop_key1299);
            if  (this->hasException())
            {
                goto ruleloop_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID44);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 500:60: -> LOOP_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LOOP_VK, REGULAR_ID44));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleloop_keyEx; /* Prevent compiler warnings */
    ruleloop_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end loop_key */

/**
 * $ANTLR start commit_key
 * OracleDMLKeys.g:503:1: commit_key :{...}? => REGULAR_ID -> COMMIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::commit_key_return
OracleDML_OracleDMLKeys::commit_key()
{
    OracleDML_OracleDMLKeys::commit_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID45 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID45_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:504:5: ({...}? => REGULAR_ID -> COMMIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:504:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COMMIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COMMIT\"" );
                    ex->set_ruleName( "commit_key" );


            }

            REGULAR_ID45 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_commit_key1327);
            if  (this->hasException())
            {
                goto rulecommit_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID45);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 504:64: -> COMMIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COMMIT_VK, REGULAR_ID45));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecommit_keyEx; /* Prevent compiler warnings */
    rulecommit_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end commit_key */

/**
 * $ANTLR start work_key
 * OracleDMLKeys.g:507:1: work_key :{...}? REGULAR_ID -> WORK_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::work_key_return
OracleDML_OracleDMLKeys::work_key()
{
    OracleDML_OracleDMLKeys::work_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID46 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID46_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:507:9: ({...}? REGULAR_ID -> WORK_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:507:14: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "WORK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WORK\"" );
                    ex->set_ruleName( "work_key" );


            }

            REGULAR_ID46 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_work_key1349);
            if  (this->hasException())
            {
                goto rulework_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID46);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 507:64: -> WORK_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(WORK_VK, REGULAR_ID46));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulework_keyEx; /* Prevent compiler warnings */
    rulework_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end work_key */

/**
 * $ANTLR start if_key
 * OracleDMLKeys.g:510:1: if_key : PLSQL_RESERVED_IF ;
 */
OracleDML_OracleDMLKeys::if_key_return
OracleDML_OracleDMLKeys::if_key()
{
    OracleDML_OracleDMLKeys::if_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_IF47 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_IF47_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:511:5: ( PLSQL_RESERVED_IF )
        // OracleDMLKeys.g:511:10: PLSQL_RESERVED_IF
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_IF47 =  this->matchToken(PLSQL_RESERVED_IF, &FOLLOW_PLSQL_RESERVED_IF_in_if_key1374);
            if  (this->hasException())
            {
                goto ruleif_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_IF47_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_IF47));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_IF47_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleif_keyEx; /* Prevent compiler warnings */
    ruleif_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end if_key */

/**
 * $ANTLR start elsif_key
 * OracleDMLKeys.g:514:1: elsif_key : PLSQL_NON_RESERVED_ELSIF ;
 */
OracleDML_OracleDMLKeys::elsif_key_return
OracleDML_OracleDMLKeys::elsif_key()
{
    OracleDML_OracleDMLKeys::elsif_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_ELSIF48 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_ELSIF48_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:515:5: ( PLSQL_NON_RESERVED_ELSIF )
        // OracleDMLKeys.g:515:10: PLSQL_NON_RESERVED_ELSIF
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_ELSIF48 =  this->matchToken(PLSQL_NON_RESERVED_ELSIF, &FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key1394);
            if  (this->hasException())
            {
                goto ruleelsif_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_ELSIF48_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_ELSIF48));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_ELSIF48_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleelsif_keyEx; /* Prevent compiler warnings */
    ruleelsif_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end elsif_key */

/**
 * $ANTLR start authid_key
 * OracleDMLKeys.g:518:1: authid_key :{...}? => REGULAR_ID -> AUTHID_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::authid_key_return
OracleDML_OracleDMLKeys::authid_key()
{
    OracleDML_OracleDMLKeys::authid_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID49 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID49_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:519:5: ({...}? => REGULAR_ID -> AUTHID_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:519:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AUTHID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AUTHID\"" );
                    ex->set_ruleName( "authid_key" );


            }

            REGULAR_ID49 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_authid_key1417);
            if  (this->hasException())
            {
                goto ruleauthid_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID49);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 519:64: -> AUTHID_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AUTHID_VK, REGULAR_ID49));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleauthid_keyEx; /* Prevent compiler warnings */
    ruleauthid_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end authid_key */

/**
 * $ANTLR start definer_key
 * OracleDMLKeys.g:522:1: definer_key :{...}? REGULAR_ID -> DEFINER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::definer_key_return
OracleDML_OracleDMLKeys::definer_key()
{
    OracleDML_OracleDMLKeys::definer_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID50 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID50_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:523:5: ({...}? REGULAR_ID -> DEFINER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:523:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DEFINER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DEFINER\"" );
                    ex->set_ruleName( "definer_key" );


            }

            REGULAR_ID50 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_definer_key1444);
            if  (this->hasException())
            {
                goto ruledefiner_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID50);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 523:63: -> DEFINER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DEFINER_VK, REGULAR_ID50));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledefiner_keyEx; /* Prevent compiler warnings */
    ruledefiner_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end definer_key */

/**
 * $ANTLR start external_key
 * OracleDMLKeys.g:526:1: external_key :{...}? REGULAR_ID -> EXTERNAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::external_key_return
OracleDML_OracleDMLKeys::external_key()
{
    OracleDML_OracleDMLKeys::external_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID51 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID51_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:527:5: ({...}? REGULAR_ID -> EXTERNAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:527:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EXTERNAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXTERNAL\"" );
                    ex->set_ruleName( "external_key" );


            }

            REGULAR_ID51 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_external_key1471);
            if  (this->hasException())
            {
                goto ruleexternal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID51);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 527:64: -> EXTERNAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EXTERNAL_VK, REGULAR_ID51));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexternal_keyEx; /* Prevent compiler warnings */
    ruleexternal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end external_key */

/**
 * $ANTLR start language_key
 * OracleDMLKeys.g:530:1: language_key :{...}? REGULAR_ID -> LANGUAGE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::language_key_return
OracleDML_OracleDMLKeys::language_key()
{
    OracleDML_OracleDMLKeys::language_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID52 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID52_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:531:5: ({...}? REGULAR_ID -> LANGUAGE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:531:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LANGUAGE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LANGUAGE\"" );
                    ex->set_ruleName( "language_key" );


            }

            REGULAR_ID52 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_language_key1498);
            if  (this->hasException())
            {
                goto rulelanguage_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID52);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 531:64: -> LANGUAGE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LANGUAGE_VK, REGULAR_ID52));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelanguage_keyEx; /* Prevent compiler warnings */
    rulelanguage_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end language_key */

/**
 * $ANTLR start java_key
 * OracleDMLKeys.g:534:1: java_key :{...}? REGULAR_ID -> JAVA_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::java_key_return
OracleDML_OracleDMLKeys::java_key()
{
    OracleDML_OracleDMLKeys::java_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID53 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID53_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:535:5: ({...}? REGULAR_ID -> JAVA_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:535:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "JAVA")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"JAVA\"" );
                    ex->set_ruleName( "java_key" );


            }

            REGULAR_ID53 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_java_key1525);
            if  (this->hasException())
            {
                goto rulejava_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID53);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 535:60: -> JAVA_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(JAVA_VK, REGULAR_ID53));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulejava_keyEx; /* Prevent compiler warnings */
    rulejava_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end java_key */

/**
 * $ANTLR start name_key
 * OracleDMLKeys.g:538:1: name_key :{...}? => REGULAR_ID -> NAME_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::name_key_return
OracleDML_OracleDMLKeys::name_key()
{
    OracleDML_OracleDMLKeys::name_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID54 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID54_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:539:5: ({...}? => REGULAR_ID -> NAME_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:539:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NAME")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NAME\"" );
                    ex->set_ruleName( "name_key" );


            }

            REGULAR_ID54 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_name_key1553);
            if  (this->hasException())
            {
                goto rulename_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID54);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 539:62: -> NAME_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NAME_VK, REGULAR_ID54));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulename_keyEx; /* Prevent compiler warnings */
    rulename_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end name_key */

/**
 * $ANTLR start deterministic_key
 * OracleDMLKeys.g:542:1: deterministic_key :{...}? => REGULAR_ID -> DETERMINISTIC_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::deterministic_key_return
OracleDML_OracleDMLKeys::deterministic_key()
{
    OracleDML_OracleDMLKeys::deterministic_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID55 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID55_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:543:5: ({...}? => REGULAR_ID -> DETERMINISTIC_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:543:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DETERMINISTIC")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DETERMINISTIC\"" );
                    ex->set_ruleName( "deterministic_key" );


            }

            REGULAR_ID55 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_deterministic_key1581);
            if  (this->hasException())
            {
                goto ruledeterministic_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID55);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 543:71: -> DETERMINISTIC_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DETERMINISTIC_VK, REGULAR_ID55));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledeterministic_keyEx; /* Prevent compiler warnings */
    ruledeterministic_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end deterministic_key */

/**
 * $ANTLR start parallel_enable_key
 * OracleDMLKeys.g:546:1: parallel_enable_key :{...}? => REGULAR_ID -> PARALLEL_ENABLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::parallel_enable_key_return
OracleDML_OracleDMLKeys::parallel_enable_key()
{
    OracleDML_OracleDMLKeys::parallel_enable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID56 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID56_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:547:5: ({...}? => REGULAR_ID -> PARALLEL_ENABLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:547:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PARALLEL_ENABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PARALLEL_ENABLE\"" );
                    ex->set_ruleName( "parallel_enable_key" );


            }

            REGULAR_ID56 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parallel_enable_key1609);
            if  (this->hasException())
            {
                goto ruleparallel_enable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID56);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 547:73: -> PARALLEL_ENABLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PARALLEL_ENABLE_VK, REGULAR_ID56));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleparallel_enable_keyEx; /* Prevent compiler warnings */
    ruleparallel_enable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end parallel_enable_key */

/**
 * $ANTLR start result_cache_key
 * OracleDMLKeys.g:550:1: result_cache_key :{...}? => REGULAR_ID -> RESULT_CACHE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::result_cache_key_return
OracleDML_OracleDMLKeys::result_cache_key()
{
    OracleDML_OracleDMLKeys::result_cache_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID57 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID57_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:551:5: ({...}? => REGULAR_ID -> RESULT_CACHE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:551:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RESULT_CACHE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RESULT_CACHE\"" );
                    ex->set_ruleName( "result_cache_key" );


            }

            REGULAR_ID57 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_result_cache_key1637);
            if  (this->hasException())
            {
                goto ruleresult_cache_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID57);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 551:70: -> RESULT_CACHE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RESULT_CACHE_VK, REGULAR_ID57));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleresult_cache_keyEx; /* Prevent compiler warnings */
    ruleresult_cache_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end result_cache_key */

/**
 * $ANTLR start pipelined_key
 * OracleDMLKeys.g:554:1: pipelined_key :{...}? => REGULAR_ID -> PIPELINED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::pipelined_key_return
OracleDML_OracleDMLKeys::pipelined_key()
{
    OracleDML_OracleDMLKeys::pipelined_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID58 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID58_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:555:5: ({...}? => REGULAR_ID -> PIPELINED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:555:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PIPELINED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PIPELINED\"" );
                    ex->set_ruleName( "pipelined_key" );


            }

            REGULAR_ID58 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pipelined_key1665);
            if  (this->hasException())
            {
                goto rulepipelined_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID58);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 555:67: -> PIPELINED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PIPELINED_VK, REGULAR_ID58));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepipelined_keyEx; /* Prevent compiler warnings */
    rulepipelined_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pipelined_key */

/**
 * $ANTLR start aggregate_key
 * OracleDMLKeys.g:558:1: aggregate_key :{...}? REGULAR_ID -> AGGREGATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::aggregate_key_return
OracleDML_OracleDMLKeys::aggregate_key()
{
    OracleDML_OracleDMLKeys::aggregate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID59 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID59_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:559:5: ({...}? REGULAR_ID -> AGGREGATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:559:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AGGREGATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AGGREGATE\"" );
                    ex->set_ruleName( "aggregate_key" );


            }

            REGULAR_ID59 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_aggregate_key1692);
            if  (this->hasException())
            {
                goto ruleaggregate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID59);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 559:65: -> AGGREGATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AGGREGATE_VK, REGULAR_ID59));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleaggregate_keyEx; /* Prevent compiler warnings */
    ruleaggregate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end aggregate_key */

/**
 * $ANTLR start alter_key
 * OracleDMLKeys.g:562:1: alter_key : SQL92_RESERVED_ALTER ;
 */
OracleDML_OracleDMLKeys::alter_key_return
OracleDML_OracleDMLKeys::alter_key()
{
    OracleDML_OracleDMLKeys::alter_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_ALTER60 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_ALTER60_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:563:5: ( SQL92_RESERVED_ALTER )
        // OracleDMLKeys.g:563:10: SQL92_RESERVED_ALTER
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_ALTER60 =  this->matchToken(SQL92_RESERVED_ALTER, &FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1717);
            if  (this->hasException())
            {
                goto rulealter_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_ALTER60_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_ALTER60));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_ALTER60_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulealter_keyEx; /* Prevent compiler warnings */
    rulealter_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end alter_key */

/**
 * $ANTLR start compile_key
 * OracleDMLKeys.g:566:1: compile_key :{...}? REGULAR_ID -> COMPILE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::compile_key_return
OracleDML_OracleDMLKeys::compile_key()
{
    OracleDML_OracleDMLKeys::compile_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID61 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID61_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:567:5: ({...}? REGULAR_ID -> COMPILE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:567:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COMPILE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COMPILE\"" );
                    ex->set_ruleName( "compile_key" );


            }

            REGULAR_ID61 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compile_key1739);
            if  (this->hasException())
            {
                goto rulecompile_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID61);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 567:63: -> COMPILE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COMPILE_VK, REGULAR_ID61));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecompile_keyEx; /* Prevent compiler warnings */
    rulecompile_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end compile_key */

/**
 * $ANTLR start debug_key
 * OracleDMLKeys.g:570:1: debug_key :{...}? REGULAR_ID -> DEBUG_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::debug_key_return
OracleDML_OracleDMLKeys::debug_key()
{
    OracleDML_OracleDMLKeys::debug_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID62 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID62_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:571:5: ({...}? REGULAR_ID -> DEBUG_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:571:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DEBUG")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DEBUG\"" );
                    ex->set_ruleName( "debug_key" );


            }

            REGULAR_ID62 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_debug_key1767);
            if  (this->hasException())
            {
                goto ruledebug_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID62);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 571:61: -> DEBUG_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DEBUG_VK, REGULAR_ID62));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledebug_keyEx; /* Prevent compiler warnings */
    ruledebug_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end debug_key */

/**
 * $ANTLR start reuse_key
 * OracleDMLKeys.g:574:1: reuse_key :{...}? REGULAR_ID -> REUSE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::reuse_key_return
OracleDML_OracleDMLKeys::reuse_key()
{
    OracleDML_OracleDMLKeys::reuse_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID63 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID63_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:575:5: ({...}? REGULAR_ID -> REUSE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:575:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REUSE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REUSE\"" );
                    ex->set_ruleName( "reuse_key" );


            }

            REGULAR_ID63 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reuse_key1794);
            if  (this->hasException())
            {
                goto rulereuse_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID63);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 575:61: -> REUSE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REUSE_VK, REGULAR_ID63));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereuse_keyEx; /* Prevent compiler warnings */
    rulereuse_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end reuse_key */

/**
 * $ANTLR start settings_key
 * OracleDMLKeys.g:578:1: settings_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::settings_key_return
OracleDML_OracleDMLKeys::settings_key()
{
    OracleDML_OracleDMLKeys::settings_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID64 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID64_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:579:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:579:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SETTINGS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SETTINGS\"" );
                    ex->set_ruleName( "settings_key" );


            }

            REGULAR_ID64 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_settings_key1821);
            if  (this->hasException())
            {
                goto rulesettings_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID64_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID64));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID64_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesettings_keyEx; /* Prevent compiler warnings */
    rulesettings_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end settings_key */

/**
 * $ANTLR start specification_key
 * OracleDMLKeys.g:582:1: specification_key :{...}? REGULAR_ID -> SPECIFICATION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::specification_key_return
OracleDML_OracleDMLKeys::specification_key()
{
    OracleDML_OracleDMLKeys::specification_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID65 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID65_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:583:5: ({...}? REGULAR_ID -> SPECIFICATION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:583:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SPECIFICATION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SPECIFICATION\"" );
                    ex->set_ruleName( "specification_key" );


            }

            REGULAR_ID65 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_specification_key1843);
            if  (this->hasException())
            {
                goto rulespecification_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID65);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 583:69: -> SPECIFICATION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SPECIFICATION_VK, REGULAR_ID65));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulespecification_keyEx; /* Prevent compiler warnings */
    rulespecification_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end specification_key */

/**
 * $ANTLR start drop_key
 * OracleDMLKeys.g:586:1: drop_key : SQL92_RESERVED_DROP ;
 */
OracleDML_OracleDMLKeys::drop_key_return
OracleDML_OracleDMLKeys::drop_key()
{
    OracleDML_OracleDMLKeys::drop_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_DROP66 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_DROP66_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:587:5: ( SQL92_RESERVED_DROP )
        // OracleDMLKeys.g:587:10: SQL92_RESERVED_DROP
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_DROP66 =  this->matchToken(SQL92_RESERVED_DROP, &FOLLOW_SQL92_RESERVED_DROP_in_drop_key1868);
            if  (this->hasException())
            {
                goto ruledrop_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_DROP66_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_DROP66));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_DROP66_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledrop_keyEx; /* Prevent compiler warnings */
    ruledrop_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end drop_key */

/**
 * $ANTLR start trigger_key
 * OracleDMLKeys.g:590:1: trigger_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::trigger_key_return
OracleDML_OracleDMLKeys::trigger_key()
{
    OracleDML_OracleDMLKeys::trigger_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID67 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID67_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:591:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:591:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "TRIGGER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TRIGGER\"" );
                    ex->set_ruleName( "trigger_key" );


            }

            REGULAR_ID67 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trigger_key1891);
            if  (this->hasException())
            {
                goto ruletrigger_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID67_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID67));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID67_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletrigger_keyEx; /* Prevent compiler warnings */
    ruletrigger_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end trigger_key */

/**
 * $ANTLR start force_key
 * OracleDMLKeys.g:594:1: force_key :{...}? => REGULAR_ID -> FORCE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::force_key_return
OracleDML_OracleDMLKeys::force_key()
{
    OracleDML_OracleDMLKeys::force_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID68 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID68_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:595:5: ({...}? => REGULAR_ID -> FORCE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:595:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FORCE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FORCE\"" );
                    ex->set_ruleName( "force_key" );


            }

            REGULAR_ID68 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_force_key1914);
            if  (this->hasException())
            {
                goto ruleforce_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID68);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 595:63: -> FORCE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FORCE_VK, REGULAR_ID68));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleforce_keyEx; /* Prevent compiler warnings */
    ruleforce_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end force_key */

/**
 * $ANTLR start validate_key
 * OracleDMLKeys.g:598:1: validate_key :{...}? REGULAR_ID -> VALIDATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::validate_key_return
OracleDML_OracleDMLKeys::validate_key()
{
    OracleDML_OracleDMLKeys::validate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID69 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID69_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:599:5: ({...}? REGULAR_ID -> VALIDATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:599:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "VALIDATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VALIDATE\"" );
                    ex->set_ruleName( "validate_key" );


            }

            REGULAR_ID69 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_validate_key1941);
            if  (this->hasException())
            {
                goto rulevalidate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID69);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 599:64: -> VALIDATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(VALIDATE_VK, REGULAR_ID69));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevalidate_keyEx; /* Prevent compiler warnings */
    rulevalidate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end validate_key */

/**
 * $ANTLR start ref_key
 * OracleDMLKeys.g:602:1: ref_key :{...}? => REGULAR_ID -> REF_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::ref_key_return
OracleDML_OracleDMLKeys::ref_key()
{
    OracleDML_OracleDMLKeys::ref_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID70 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID70_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:603:5: ({...}? => REGULAR_ID -> REF_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:603:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REF")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REF\"" );
                    ex->set_ruleName( "ref_key" );


            }

            REGULAR_ID70 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ref_key1969);
            if  (this->hasException())
            {
                goto ruleref_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID70);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 603:61: -> REF_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REF_VK, REGULAR_ID70));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleref_keyEx; /* Prevent compiler warnings */
    ruleref_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end ref_key */

/**
 * $ANTLR start array_key
 * OracleDMLKeys.g:606:1: array_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::array_key_return
OracleDML_OracleDMLKeys::array_key()
{
    OracleDML_OracleDMLKeys::array_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID71 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID71_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:607:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:607:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ARRAY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ARRAY\"" );
                    ex->set_ruleName( "array_key" );


            }

            REGULAR_ID71 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_array_key1997);
            if  (this->hasException())
            {
                goto rulearray_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID71_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID71));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID71_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulearray_keyEx; /* Prevent compiler warnings */
    rulearray_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end array_key */

/**
 * $ANTLR start varray_key
 * OracleDMLKeys.g:610:1: varray_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::varray_key_return
OracleDML_OracleDMLKeys::varray_key()
{
    OracleDML_OracleDMLKeys::varray_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID72 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID72_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:611:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:611:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "VARRAY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VARRAY\"" );
                    ex->set_ruleName( "varray_key" );


            }

            REGULAR_ID72 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varray_key2020);
            if  (this->hasException())
            {
                goto rulevarray_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID72_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID72));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID72_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevarray_keyEx; /* Prevent compiler warnings */
    rulevarray_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end varray_key */

/**
 * $ANTLR start pls_integer_key
 * OracleDMLKeys.g:614:1: pls_integer_key :{...}? => REGULAR_ID -> PLS_INTEGER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::pls_integer_key_return
OracleDML_OracleDMLKeys::pls_integer_key()
{
    OracleDML_OracleDMLKeys::pls_integer_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID73 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID73_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:615:5: ({...}? => REGULAR_ID -> PLS_INTEGER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:615:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PLS_iNTEGER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PLS_iNTEGER\"" );
                    ex->set_ruleName( "pls_integer_key" );


            }

            REGULAR_ID73 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pls_integer_key2043);
            if  (this->hasException())
            {
                goto rulepls_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID73);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 615:69: -> PLS_INTEGER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PLS_INTEGER_VK, REGULAR_ID73));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepls_integer_keyEx; /* Prevent compiler warnings */
    rulepls_integer_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pls_integer_key */

/**
 * $ANTLR start serially_reusable_key
 * OracleDMLKeys.g:618:1: serially_reusable_key :{...}? => REGULAR_ID -> SERIALLY_REUSABLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::serially_reusable_key_return
OracleDML_OracleDMLKeys::serially_reusable_key()
{
    OracleDML_OracleDMLKeys::serially_reusable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID74 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID74_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:619:5: ({...}? => REGULAR_ID -> SERIALLY_REUSABLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:619:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SERIALLY_REUSABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SERIALLY_REUSABLE\"" );
                    ex->set_ruleName( "serially_reusable_key" );


            }

            REGULAR_ID74 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serially_reusable_key2071);
            if  (this->hasException())
            {
                goto ruleserially_reusable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID74);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 619:75: -> SERIALLY_REUSABLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SERIALLY_REUSABLE_VK, REGULAR_ID74));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleserially_reusable_keyEx; /* Prevent compiler warnings */
    ruleserially_reusable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end serially_reusable_key */

/**
 * $ANTLR start autonomous_transaction_key
 * OracleDMLKeys.g:622:1: autonomous_transaction_key :{...}? => REGULAR_ID -> AUTONOMOUS_TRANSACTION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::autonomous_transaction_key_return
OracleDML_OracleDMLKeys::autonomous_transaction_key()
{
    OracleDML_OracleDMLKeys::autonomous_transaction_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID75 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID75_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:623:5: ({...}? => REGULAR_ID -> AUTONOMOUS_TRANSACTION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:623:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AUTONOMOUS_TRANSACTION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AUTONOMOUS_TRANSACTION\"" );
                    ex->set_ruleName( "autonomous_transaction_key" );


            }

            REGULAR_ID75 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_autonomous_transaction_key2099);
            if  (this->hasException())
            {
                goto ruleautonomous_transaction_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID75);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 623:80: -> AUTONOMOUS_TRANSACTION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AUTONOMOUS_TRANSACTION_VK, REGULAR_ID75));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleautonomous_transaction_keyEx; /* Prevent compiler warnings */
    ruleautonomous_transaction_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end autonomous_transaction_key */

/**
 * $ANTLR start inline_key
 * OracleDMLKeys.g:626:1: inline_key :{...}? => REGULAR_ID -> INLINE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::inline_key_return
OracleDML_OracleDMLKeys::inline_key()
{
    OracleDML_OracleDMLKeys::inline_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID76 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID76_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:627:5: ({...}? => REGULAR_ID -> INLINE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:627:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INLINE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INLINE\"" );
                    ex->set_ruleName( "inline_key" );


            }

            REGULAR_ID76 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inline_key2127);
            if  (this->hasException())
            {
                goto ruleinline_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID76);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 627:64: -> INLINE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INLINE_VK, REGULAR_ID76));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinline_keyEx; /* Prevent compiler warnings */
    ruleinline_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end inline_key */

/**
 * $ANTLR start restrict_references_key
 * OracleDMLKeys.g:630:1: restrict_references_key :{...}? => REGULAR_ID -> RESTRICT_REFERENCES_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::restrict_references_key_return
OracleDML_OracleDMLKeys::restrict_references_key()
{
    OracleDML_OracleDMLKeys::restrict_references_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID77 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID77_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:631:5: ({...}? => REGULAR_ID -> RESTRICT_REFERENCES_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:631:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RESTRICT_REFERENCES")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RESTRICT_REFERENCES\"" );
                    ex->set_ruleName( "restrict_references_key" );


            }

            REGULAR_ID77 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_restrict_references_key2155);
            if  (this->hasException())
            {
                goto rulerestrict_references_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID77);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 631:77: -> RESTRICT_REFERENCES_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RESTRICT_REFERENCES_VK, REGULAR_ID77));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerestrict_references_keyEx; /* Prevent compiler warnings */
    rulerestrict_references_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end restrict_references_key */

/**
 * $ANTLR start exceptions_key
 * OracleDMLKeys.g:634:1: exceptions_key :{...}? => REGULAR_ID -> EXCEPTIONS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::exceptions_key_return
OracleDML_OracleDMLKeys::exceptions_key()
{
    OracleDML_OracleDMLKeys::exceptions_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID78 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID78_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:635:5: ({...}? => REGULAR_ID -> EXCEPTIONS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:635:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EXCEPTIONS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXCEPTIONS\"" );
                    ex->set_ruleName( "exceptions_key" );


            }

            REGULAR_ID78 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exceptions_key2183);
            if  (this->hasException())
            {
                goto ruleexceptions_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID78);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 635:68: -> EXCEPTIONS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EXCEPTIONS_VK, REGULAR_ID78));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexceptions_keyEx; /* Prevent compiler warnings */
    ruleexceptions_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exceptions_key */

/**
 * $ANTLR start save_key
 * OracleDMLKeys.g:638:1: save_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::save_key_return
OracleDML_OracleDMLKeys::save_key()
{
    OracleDML_OracleDMLKeys::save_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID79 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID79_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:639:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:639:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SAVE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SAVE\"" );
                    ex->set_ruleName( "save_key" );


            }

            REGULAR_ID79 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_save_key2212);
            if  (this->hasException())
            {
                goto rulesave_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID79_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID79));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID79_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesave_keyEx; /* Prevent compiler warnings */
    rulesave_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end save_key */

/**
 * $ANTLR start forall_key
 * OracleDMLKeys.g:642:1: forall_key :{...}? => REGULAR_ID -> FORALL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::forall_key_return
OracleDML_OracleDMLKeys::forall_key()
{
    OracleDML_OracleDMLKeys::forall_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID80 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID80_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:643:5: ({...}? => REGULAR_ID -> FORALL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:643:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FORALL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FORALL\"" );
                    ex->set_ruleName( "forall_key" );


            }

            REGULAR_ID80 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_forall_key2235);
            if  (this->hasException())
            {
                goto ruleforall_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID80);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 643:64: -> FORALL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FORALL_VK, REGULAR_ID80));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleforall_keyEx; /* Prevent compiler warnings */
    ruleforall_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end forall_key */

/**
 * $ANTLR start continue_key
 * OracleDMLKeys.g:646:1: continue_key :{...}? => REGULAR_ID -> CONTINUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::continue_key_return
OracleDML_OracleDMLKeys::continue_key()
{
    OracleDML_OracleDMLKeys::continue_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID81 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID81_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:647:5: ({...}? => REGULAR_ID -> CONTINUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:647:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CONTINUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONTINUE\"" );
                    ex->set_ruleName( "continue_key" );


            }

            REGULAR_ID81 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_continue_key2263);
            if  (this->hasException())
            {
                goto rulecontinue_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID81);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 647:66: -> CONTINUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CONTINUE_VK, REGULAR_ID81));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecontinue_keyEx; /* Prevent compiler warnings */
    rulecontinue_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end continue_key */

/**
 * $ANTLR start indices_key
 * OracleDMLKeys.g:650:1: indices_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::indices_key_return
OracleDML_OracleDMLKeys::indices_key()
{
    OracleDML_OracleDMLKeys::indices_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID82 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID82_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:651:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:651:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "INDICES")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INDICES\"" );
                    ex->set_ruleName( "indices_key" );


            }

            REGULAR_ID82 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indices_key2291);
            if  (this->hasException())
            {
                goto ruleindices_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID82_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID82));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID82_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleindices_keyEx; /* Prevent compiler warnings */
    ruleindices_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end indices_key */

/**
 * $ANTLR start values_key
 * OracleDMLKeys.g:654:1: values_key : SQL92_RESERVED_VALUES ;
 */
OracleDML_OracleDMLKeys::values_key_return
OracleDML_OracleDMLKeys::values_key()
{
    OracleDML_OracleDMLKeys::values_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_VALUES83 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_VALUES83_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:655:5: ( SQL92_RESERVED_VALUES )
        // OracleDMLKeys.g:655:10: SQL92_RESERVED_VALUES
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_VALUES83 =  this->matchToken(SQL92_RESERVED_VALUES, &FOLLOW_SQL92_RESERVED_VALUES_in_values_key2311);
            if  (this->hasException())
            {
                goto rulevalues_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_VALUES83_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_VALUES83));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_VALUES83_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevalues_keyEx; /* Prevent compiler warnings */
    rulevalues_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end values_key */

/**
 * $ANTLR start case_key
 * OracleDMLKeys.g:658:1: case_key : SQL92_RESERVED_CASE ;
 */
OracleDML_OracleDMLKeys::case_key_return
OracleDML_OracleDMLKeys::case_key()
{
    OracleDML_OracleDMLKeys::case_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_CASE84 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_CASE84_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:659:5: ( SQL92_RESERVED_CASE )
        // OracleDMLKeys.g:659:10: SQL92_RESERVED_CASE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_CASE84 =  this->matchToken(SQL92_RESERVED_CASE, &FOLLOW_SQL92_RESERVED_CASE_in_case_key2331);
            if  (this->hasException())
            {
                goto rulecase_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_CASE84_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_CASE84));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_CASE84_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecase_keyEx; /* Prevent compiler warnings */
    rulecase_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end case_key */

/**
 * $ANTLR start bulk_key
 * OracleDMLKeys.g:662:1: bulk_key :{...}? => REGULAR_ID -> BULK_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::bulk_key_return
OracleDML_OracleDMLKeys::bulk_key()
{
    OracleDML_OracleDMLKeys::bulk_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID85 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID85_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:663:5: ({...}? => REGULAR_ID -> BULK_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:663:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BULK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BULK\"" );
                    ex->set_ruleName( "bulk_key" );


            }

            REGULAR_ID85 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bulk_key2354);
            if  (this->hasException())
            {
                goto rulebulk_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID85);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 663:62: -> BULK_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BULK_VK, REGULAR_ID85));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebulk_keyEx; /* Prevent compiler warnings */
    rulebulk_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end bulk_key */

/**
 * $ANTLR start collect_key
 * OracleDMLKeys.g:666:1: collect_key :{...}? => REGULAR_ID -> COLLECT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::collect_key_return
OracleDML_OracleDMLKeys::collect_key()
{
    OracleDML_OracleDMLKeys::collect_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID86 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID86_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:667:5: ({...}? => REGULAR_ID -> COLLECT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:667:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COLLECT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COLLECT\"" );
                    ex->set_ruleName( "collect_key" );


            }

            REGULAR_ID86 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_collect_key2382);
            if  (this->hasException())
            {
                goto rulecollect_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID86);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 667:65: -> COLLECT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COLLECT_VK, REGULAR_ID86));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecollect_keyEx; /* Prevent compiler warnings */
    rulecollect_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end collect_key */

/**
 * $ANTLR start committed_key
 * OracleDMLKeys.g:670:1: committed_key :{...}? REGULAR_ID -> COMMITTED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::committed_key_return
OracleDML_OracleDMLKeys::committed_key()
{
    OracleDML_OracleDMLKeys::committed_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID87 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID87_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:671:5: ({...}? REGULAR_ID -> COMMITTED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:671:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COMMITTED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COMMITTED\"" );
                    ex->set_ruleName( "committed_key" );


            }

            REGULAR_ID87 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_committed_key2409);
            if  (this->hasException())
            {
                goto rulecommitted_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID87);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 671:65: -> COMMITTED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COMMITTED_VK, REGULAR_ID87));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecommitted_keyEx; /* Prevent compiler warnings */
    rulecommitted_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end committed_key */

/**
 * $ANTLR start use_key
 * OracleDMLKeys.g:674:1: use_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::use_key_return
OracleDML_OracleDMLKeys::use_key()
{
    OracleDML_OracleDMLKeys::use_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID88 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID88_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:675:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:675:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "USE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"USE\"" );
                    ex->set_ruleName( "use_key" );


            }

            REGULAR_ID88 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_use_key2437);
            if  (this->hasException())
            {
                goto ruleuse_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID88_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID88));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID88_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleuse_keyEx; /* Prevent compiler warnings */
    ruleuse_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end use_key */

/**
 * $ANTLR start level_key
 * OracleDMLKeys.g:678:1: level_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::level_key_return
OracleDML_OracleDMLKeys::level_key()
{
    OracleDML_OracleDMLKeys::level_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID89 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID89_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:679:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:679:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LEVEL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LEVEL\"" );
                    ex->set_ruleName( "level_key" );


            }

            REGULAR_ID89 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_level_key2459);
            if  (this->hasException())
            {
                goto rulelevel_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID89_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID89));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID89_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelevel_keyEx; /* Prevent compiler warnings */
    rulelevel_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end level_key */

/**
 * $ANTLR start isolation_key
 * OracleDMLKeys.g:682:1: isolation_key :{...}? => REGULAR_ID -> ISOLATION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::isolation_key_return
OracleDML_OracleDMLKeys::isolation_key()
{
    OracleDML_OracleDMLKeys::isolation_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID90 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID90_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:683:5: ({...}? => REGULAR_ID -> ISOLATION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:683:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ISOLATION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ISOLATION\"" );
                    ex->set_ruleName( "isolation_key" );


            }

            REGULAR_ID90 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_isolation_key2482);
            if  (this->hasException())
            {
                goto ruleisolation_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID90);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 683:67: -> ISOLATION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ISOLATION_VK, REGULAR_ID90));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleisolation_keyEx; /* Prevent compiler warnings */
    ruleisolation_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end isolation_key */

/**
 * $ANTLR start serializable_key
 * OracleDMLKeys.g:686:1: serializable_key :{...}? REGULAR_ID -> SERIALIZABLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::serializable_key_return
OracleDML_OracleDMLKeys::serializable_key()
{
    OracleDML_OracleDMLKeys::serializable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID91 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID91_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:687:5: ({...}? REGULAR_ID -> SERIALIZABLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:687:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SERIALIZABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SERIALIZABLE\"" );
                    ex->set_ruleName( "serializable_key" );


            }

            REGULAR_ID91 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serializable_key2509);
            if  (this->hasException())
            {
                goto ruleserializable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID91);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 687:68: -> SERIALIZABLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SERIALIZABLE_VK, REGULAR_ID91));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleserializable_keyEx; /* Prevent compiler warnings */
    ruleserializable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end serializable_key */

/**
 * $ANTLR start segment_key
 * OracleDMLKeys.g:690:1: segment_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::segment_key_return
OracleDML_OracleDMLKeys::segment_key()
{
    OracleDML_OracleDMLKeys::segment_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID92 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID92_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:691:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:691:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SEGMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SEGMENT\"" );
                    ex->set_ruleName( "segment_key" );


            }

            REGULAR_ID92 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_segment_key2536);
            if  (this->hasException())
            {
                goto rulesegment_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID92_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID92));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID92_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesegment_keyEx; /* Prevent compiler warnings */
    rulesegment_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end segment_key */

/**
 * $ANTLR start write_key
 * OracleDMLKeys.g:694:1: write_key :{...}? => REGULAR_ID -> WRITE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::write_key_return
OracleDML_OracleDMLKeys::write_key()
{
    OracleDML_OracleDMLKeys::write_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID93 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID93_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:695:5: ({...}? => REGULAR_ID -> WRITE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:695:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "WRITE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WRITE\"" );
                    ex->set_ruleName( "write_key" );


            }

            REGULAR_ID93 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_write_key2559);
            if  (this->hasException())
            {
                goto rulewrite_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID93);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 695:63: -> WRITE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(WRITE_VK, REGULAR_ID93));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewrite_keyEx; /* Prevent compiler warnings */
    rulewrite_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end write_key */

/**
 * $ANTLR start wait_key
 * OracleDMLKeys.g:698:1: wait_key :{...}? => REGULAR_ID -> WAIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::wait_key_return
OracleDML_OracleDMLKeys::wait_key()
{
    OracleDML_OracleDMLKeys::wait_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID94 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID94_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:699:5: ({...}? => REGULAR_ID -> WAIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:699:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "WAIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WAIT\"" );
                    ex->set_ruleName( "wait_key" );


            }

            REGULAR_ID94 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_wait_key2587);
            if  (this->hasException())
            {
                goto rulewait_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID94);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 699:62: -> WAIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(WAIT_VK, REGULAR_ID94));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewait_keyEx; /* Prevent compiler warnings */
    rulewait_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end wait_key */

/**
 * $ANTLR start corrupt_xid_all_key
 * OracleDMLKeys.g:702:1: corrupt_xid_all_key :{...}? => REGULAR_ID -> CORRUPT_XID_ALL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::corrupt_xid_all_key_return
OracleDML_OracleDMLKeys::corrupt_xid_all_key()
{
    OracleDML_OracleDMLKeys::corrupt_xid_all_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID95 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID95_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:703:5: ({...}? => REGULAR_ID -> CORRUPT_XID_ALL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:703:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CORRUPT_XID_ALL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CORRUPT_XID_ALL\"" );
                    ex->set_ruleName( "corrupt_xid_all_key" );


            }

            REGULAR_ID95 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2615);
            if  (this->hasException())
            {
                goto rulecorrupt_xid_all_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID95);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 703:73: -> CORRUPT_XID_ALL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CORRUPT_XID_ALL_VK, REGULAR_ID95));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecorrupt_xid_all_keyEx; /* Prevent compiler warnings */
    rulecorrupt_xid_all_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end corrupt_xid_all_key */

/**
 * $ANTLR start corrupt_xid_key
 * OracleDMLKeys.g:706:1: corrupt_xid_key :{...}? => REGULAR_ID -> CORRUPT_XID_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::corrupt_xid_key_return
OracleDML_OracleDMLKeys::corrupt_xid_key()
{
    OracleDML_OracleDMLKeys::corrupt_xid_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID96 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID96_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:707:5: ({...}? => REGULAR_ID -> CORRUPT_XID_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:707:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CORRUPT_XID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CORRUPT_XID\"" );
                    ex->set_ruleName( "corrupt_xid_key" );


            }

            REGULAR_ID96 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corrupt_xid_key2643);
            if  (this->hasException())
            {
                goto rulecorrupt_xid_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID96);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 707:69: -> CORRUPT_XID_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CORRUPT_XID_VK, REGULAR_ID96));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecorrupt_xid_keyEx; /* Prevent compiler warnings */
    rulecorrupt_xid_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end corrupt_xid_key */

/**
 * $ANTLR start batch_key
 * OracleDMLKeys.g:710:1: batch_key :{...}? => REGULAR_ID -> BATCH_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::batch_key_return
OracleDML_OracleDMLKeys::batch_key()
{
    OracleDML_OracleDMLKeys::batch_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID97 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID97_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:711:5: ({...}? => REGULAR_ID -> BATCH_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:711:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BATCH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BATCH\"" );
                    ex->set_ruleName( "batch_key" );


            }

            REGULAR_ID97 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_batch_key2671);
            if  (this->hasException())
            {
                goto rulebatch_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID97);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 711:63: -> BATCH_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BATCH_VK, REGULAR_ID97));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebatch_keyEx; /* Prevent compiler warnings */
    rulebatch_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end batch_key */

/**
 * $ANTLR start session_key
 * OracleDMLKeys.g:714:1: session_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::session_key_return
OracleDML_OracleDMLKeys::session_key()
{
    OracleDML_OracleDMLKeys::session_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID98 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID98_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:715:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:715:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SESSION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SESSION\"" );
                    ex->set_ruleName( "session_key" );


            }

            REGULAR_ID98 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_session_key2699);
            if  (this->hasException())
            {
                goto rulesession_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID98_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID98));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID98_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesession_keyEx; /* Prevent compiler warnings */
    rulesession_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end session_key */

/**
 * $ANTLR start role_key
 * OracleDMLKeys.g:718:1: role_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::role_key_return
OracleDML_OracleDMLKeys::role_key()
{
    OracleDML_OracleDMLKeys::role_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID99 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID99_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:719:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:719:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ROLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROLE\"" );
                    ex->set_ruleName( "role_key" );


            }

            REGULAR_ID99 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_role_key2722);
            if  (this->hasException())
            {
                goto rulerole_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID99_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID99));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID99_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerole_keyEx; /* Prevent compiler warnings */
    rulerole_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end role_key */

/**
 * $ANTLR start constraint_key
 * OracleDMLKeys.g:722:1: constraint_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::constraint_key_return
OracleDML_OracleDMLKeys::constraint_key()
{
    OracleDML_OracleDMLKeys::constraint_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID100 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID100_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:723:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:723:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CONSTRAINT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONSTRAINT\"" );
                    ex->set_ruleName( "constraint_key" );


            }

            REGULAR_ID100 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constraint_key2745);
            if  (this->hasException())
            {
                goto ruleconstraint_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID100_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID100));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID100_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconstraint_keyEx; /* Prevent compiler warnings */
    ruleconstraint_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end constraint_key */

/**
 * $ANTLR start constraints_key
 * OracleDMLKeys.g:726:1: constraints_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::constraints_key_return
OracleDML_OracleDMLKeys::constraints_key()
{
    OracleDML_OracleDMLKeys::constraints_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID101 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID101_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:727:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:727:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CONSTRAINTS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONSTRAINTS\"" );
                    ex->set_ruleName( "constraints_key" );


            }

            REGULAR_ID101 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constraints_key2768);
            if  (this->hasException())
            {
                goto ruleconstraints_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID101_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID101));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID101_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconstraints_keyEx; /* Prevent compiler warnings */
    ruleconstraints_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end constraints_key */

/**
 * $ANTLR start call_key
 * OracleDMLKeys.g:730:1: call_key :{...}? => REGULAR_ID -> CALL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::call_key_return
OracleDML_OracleDMLKeys::call_key()
{
    OracleDML_OracleDMLKeys::call_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID102 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID102_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:731:5: ({...}? => REGULAR_ID -> CALL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:731:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CALL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CALL\"" );
                    ex->set_ruleName( "call_key" );


            }

            REGULAR_ID102 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_call_key2791);
            if  (this->hasException())
            {
                goto rulecall_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID102);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 731:62: -> CALL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CALL_VK, REGULAR_ID102));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecall_keyEx; /* Prevent compiler warnings */
    rulecall_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end call_key */

/**
 * $ANTLR start explain_key
 * OracleDMLKeys.g:734:1: explain_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::explain_key_return
OracleDML_OracleDMLKeys::explain_key()
{
    OracleDML_OracleDMLKeys::explain_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID103 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID103_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:735:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:735:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "EXPLAIN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXPLAIN\"" );
                    ex->set_ruleName( "explain_key" );


            }

            REGULAR_ID103 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_explain_key2819);
            if  (this->hasException())
            {
                goto ruleexplain_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID103_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID103));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID103_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexplain_keyEx; /* Prevent compiler warnings */
    ruleexplain_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end explain_key */

/**
 * $ANTLR start merge_key
 * OracleDMLKeys.g:738:1: merge_key :{...}? => REGULAR_ID -> MERGE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::merge_key_return
OracleDML_OracleDMLKeys::merge_key()
{
    OracleDML_OracleDMLKeys::merge_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID104 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID104_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:739:5: ({...}? => REGULAR_ID -> MERGE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:739:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MERGE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MERGE\"" );
                    ex->set_ruleName( "merge_key" );


            }

            REGULAR_ID104 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_merge_key2842);
            if  (this->hasException())
            {
                goto rulemerge_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID104);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 739:63: -> MERGE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MERGE_VK, REGULAR_ID104));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_keyEx; /* Prevent compiler warnings */
    rulemerge_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_key */

/**
 * $ANTLR start plan_key
 * OracleDMLKeys.g:742:1: plan_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::plan_key_return
OracleDML_OracleDMLKeys::plan_key()
{
    OracleDML_OracleDMLKeys::plan_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID105 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID105_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:743:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:743:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "PLAN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PLAN\"" );
                    ex->set_ruleName( "plan_key" );


            }

            REGULAR_ID105 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_plan_key2870);
            if  (this->hasException())
            {
                goto ruleplan_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID105_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID105));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID105_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleplan_keyEx; /* Prevent compiler warnings */
    ruleplan_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end plan_key */

/**
 * $ANTLR start system_key
 * OracleDMLKeys.g:746:1: system_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::system_key_return
OracleDML_OracleDMLKeys::system_key()
{
    OracleDML_OracleDMLKeys::system_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID106 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID106_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:747:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:747:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SYSTEM")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SYSTEM\"" );
                    ex->set_ruleName( "system_key" );


            }

            REGULAR_ID106 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_system_key2893);
            if  (this->hasException())
            {
                goto rulesystem_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID106_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID106));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID106_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesystem_keyEx; /* Prevent compiler warnings */
    rulesystem_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end system_key */

/**
 * $ANTLR start subpartition_key
 * OracleDMLKeys.g:750:1: subpartition_key :{...}? => REGULAR_ID -> SUBPARTITION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::subpartition_key_return
OracleDML_OracleDMLKeys::subpartition_key()
{
    OracleDML_OracleDMLKeys::subpartition_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID107 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID107_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:751:5: ({...}? => REGULAR_ID -> SUBPARTITION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:751:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SUBPARTITION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUBPARTITION\"" );
                    ex->set_ruleName( "subpartition_key" );


            }

            REGULAR_ID107 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_subpartition_key2916);
            if  (this->hasException())
            {
                goto rulesubpartition_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID107);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 751:70: -> SUBPARTITION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SUBPARTITION_VK, REGULAR_ID107));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubpartition_keyEx; /* Prevent compiler warnings */
    rulesubpartition_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end subpartition_key */

/**
 * $ANTLR start partition_key
 * OracleDMLKeys.g:754:1: partition_key :{...}? => REGULAR_ID -> PARTITION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::partition_key_return
OracleDML_OracleDMLKeys::partition_key()
{
    OracleDML_OracleDMLKeys::partition_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID108 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID108_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:755:5: ({...}? => REGULAR_ID -> PARTITION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:755:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PARTITION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PARTITION\"" );
                    ex->set_ruleName( "partition_key" );


            }

            REGULAR_ID108 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_partition_key2944);
            if  (this->hasException())
            {
                goto rulepartition_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID108);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 755:67: -> PARTITION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PARTITION_VK, REGULAR_ID108));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepartition_keyEx; /* Prevent compiler warnings */
    rulepartition_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end partition_key */

/**
 * $ANTLR start matched_key
 * OracleDMLKeys.g:758:1: matched_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::matched_key_return
OracleDML_OracleDMLKeys::matched_key()
{
    OracleDML_OracleDMLKeys::matched_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID109 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID109_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:759:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:759:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "MATCHED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MATCHED\"" );
                    ex->set_ruleName( "matched_key" );


            }

            REGULAR_ID109 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_matched_key2972);
            if  (this->hasException())
            {
                goto rulematched_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID109_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID109));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID109_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulematched_keyEx; /* Prevent compiler warnings */
    rulematched_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end matched_key */

/**
 * $ANTLR start reject_key
 * OracleDMLKeys.g:762:1: reject_key :{...}? => REGULAR_ID -> REJECT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::reject_key_return
OracleDML_OracleDMLKeys::reject_key()
{
    OracleDML_OracleDMLKeys::reject_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID110 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID110_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:763:5: ({...}? => REGULAR_ID -> REJECT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:763:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REJECT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REJECT\"" );
                    ex->set_ruleName( "reject_key" );


            }

            REGULAR_ID110 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reject_key2995);
            if  (this->hasException())
            {
                goto rulereject_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID110);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 763:64: -> REJECT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REJECT_VK, REGULAR_ID110));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereject_keyEx; /* Prevent compiler warnings */
    rulereject_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end reject_key */

/**
 * $ANTLR start log_key
 * OracleDMLKeys.g:766:1: log_key :{...}? => REGULAR_ID -> LOG_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::log_key_return
OracleDML_OracleDMLKeys::log_key()
{
    OracleDML_OracleDMLKeys::log_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID111 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID111_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:767:5: ({...}? => REGULAR_ID -> LOG_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:767:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LOG")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LOG\"" );
                    ex->set_ruleName( "log_key" );


            }

            REGULAR_ID111 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_log_key3023);
            if  (this->hasException())
            {
                goto rulelog_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID111);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 767:61: -> LOG_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LOG_VK, REGULAR_ID111));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelog_keyEx; /* Prevent compiler warnings */
    rulelog_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end log_key */

/**
 * $ANTLR start unlimited_key
 * OracleDMLKeys.g:770:1: unlimited_key :{...}? => REGULAR_ID -> UNLIMITED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::unlimited_key_return
OracleDML_OracleDMLKeys::unlimited_key()
{
    OracleDML_OracleDMLKeys::unlimited_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID112 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID112_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:771:5: ({...}? => REGULAR_ID -> UNLIMITED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:771:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "UNLIMITED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UNLIMITED\"" );
                    ex->set_ruleName( "unlimited_key" );


            }

            REGULAR_ID112 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unlimited_key3051);
            if  (this->hasException())
            {
                goto ruleunlimited_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID112);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 771:67: -> UNLIMITED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(UNLIMITED_VK, REGULAR_ID112));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunlimited_keyEx; /* Prevent compiler warnings */
    ruleunlimited_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unlimited_key */

/**
 * $ANTLR start limit_key
 * OracleDMLKeys.g:774:1: limit_key :{...}? => REGULAR_ID -> LIMIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::limit_key_return
OracleDML_OracleDMLKeys::limit_key()
{
    OracleDML_OracleDMLKeys::limit_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID113 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID113_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:775:5: ({...}? => REGULAR_ID -> LIMIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:775:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LIMIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LIMIT\"" );
                    ex->set_ruleName( "limit_key" );


            }

            REGULAR_ID113 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_limit_key3079);
            if  (this->hasException())
            {
                goto rulelimit_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID113);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 775:63: -> LIMIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LIMIT_VK, REGULAR_ID113));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelimit_keyEx; /* Prevent compiler warnings */
    rulelimit_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end limit_key */

/**
 * $ANTLR start errors_key
 * OracleDMLKeys.g:778:1: errors_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::errors_key_return
OracleDML_OracleDMLKeys::errors_key()
{
    OracleDML_OracleDMLKeys::errors_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID114 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID114_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:779:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:779:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ERRORS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ERRORS\"" );
                    ex->set_ruleName( "errors_key" );


            }

            REGULAR_ID114 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_errors_key3107);
            if  (this->hasException())
            {
                goto ruleerrors_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID114_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID114));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID114_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleerrors_keyEx; /* Prevent compiler warnings */
    ruleerrors_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end errors_key */

/**
 * $ANTLR start timestamp_tz_unconstrained_key
 * OracleDMLKeys.g:782:1: timestamp_tz_unconstrained_key :{...}? => REGULAR_ID -> TIMESTAMP_TZ_UNCONSTRAINED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timestamp_tz_unconstrained_key_return
OracleDML_OracleDMLKeys::timestamp_tz_unconstrained_key()
{
    OracleDML_OracleDMLKeys::timestamp_tz_unconstrained_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID115 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID115_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:783:5: ({...}? => REGULAR_ID -> TIMESTAMP_TZ_UNCONSTRAINED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:783:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMESTAMP_TZ_UNCONSTRAINED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMESTAMP_TZ_UNCONSTRAINED\"" );
                    ex->set_ruleName( "timestamp_tz_unconstrained_key" );


            }

            REGULAR_ID115 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key3130);
            if  (this->hasException())
            {
                goto ruletimestamp_tz_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID115);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 783:84: -> TIMESTAMP_TZ_UNCONSTRAINED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMESTAMP_TZ_UNCONSTRAINED_VK, REGULAR_ID115));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimestamp_tz_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_tz_unconstrained_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timestamp_tz_unconstrained_key */

/**
 * $ANTLR start urowid_key
 * OracleDMLKeys.g:786:1: urowid_key :{...}? => REGULAR_ID -> UROWID_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::urowid_key_return
OracleDML_OracleDMLKeys::urowid_key()
{
    OracleDML_OracleDMLKeys::urowid_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID116 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID116_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:787:5: ({...}? => REGULAR_ID -> UROWID_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:787:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "UROWID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UROWID\"" );
                    ex->set_ruleName( "urowid_key" );


            }

            REGULAR_ID116 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_urowid_key3158);
            if  (this->hasException())
            {
                goto ruleurowid_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID116);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 787:64: -> UROWID_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(UROWID_VK, REGULAR_ID116));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleurowid_keyEx; /* Prevent compiler warnings */
    ruleurowid_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end urowid_key */

/**
 * $ANTLR start binary_float_min_subnormal_key
 * OracleDMLKeys.g:790:1: binary_float_min_subnormal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_float_min_subnormal_key_return
OracleDML_OracleDMLKeys::binary_float_min_subnormal_key()
{
    OracleDML_OracleDMLKeys::binary_float_min_subnormal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID117 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID117_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:791:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:791:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_FLOAT_MIN_SUBNORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_FLOAT_MIN_SUBNORMAL\"" );
                    ex->set_ruleName( "binary_float_min_subnormal_key" );


            }

            REGULAR_ID117 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key3186);
            if  (this->hasException())
            {
                goto rulebinary_float_min_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID117_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID117));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID117_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_float_min_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_min_subnormal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_float_min_subnormal_key */

/**
 * $ANTLR start binary_double_min_normal_key
 * OracleDMLKeys.g:794:1: binary_double_min_normal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_double_min_normal_key_return
OracleDML_OracleDMLKeys::binary_double_min_normal_key()
{
    OracleDML_OracleDMLKeys::binary_double_min_normal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID118 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID118_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:795:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:795:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_DOUBLE_MIN_NORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_DOUBLE_MIN_NORMAL\"" );
                    ex->set_ruleName( "binary_double_min_normal_key" );


            }

            REGULAR_ID118 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_min_normal_key3209);
            if  (this->hasException())
            {
                goto rulebinary_double_min_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID118_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID118));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID118_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_double_min_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_min_normal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_double_min_normal_key */

/**
 * $ANTLR start binary_float_max_normal_key
 * OracleDMLKeys.g:798:1: binary_float_max_normal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_float_max_normal_key_return
OracleDML_OracleDMLKeys::binary_float_max_normal_key()
{
    OracleDML_OracleDMLKeys::binary_float_max_normal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID119 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID119_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:799:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:799:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_FLOAT_MAX_NORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_FLOAT_MAX_NORMAL\"" );
                    ex->set_ruleName( "binary_float_max_normal_key" );


            }

            REGULAR_ID119 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_max_normal_key3232);
            if  (this->hasException())
            {
                goto rulebinary_float_max_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID119_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID119));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID119_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_float_max_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_max_normal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_float_max_normal_key */

/**
 * $ANTLR start positiven_key
 * OracleDMLKeys.g:802:1: positiven_key :{...}? => REGULAR_ID -> POSITIVEN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::positiven_key_return
OracleDML_OracleDMLKeys::positiven_key()
{
    OracleDML_OracleDMLKeys::positiven_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID120 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID120_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:803:5: ({...}? => REGULAR_ID -> POSITIVEN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:803:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "POSITIVEN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"POSITIVEN\"" );
                    ex->set_ruleName( "positiven_key" );


            }

            REGULAR_ID120 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_positiven_key3255);
            if  (this->hasException())
            {
                goto rulepositiven_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID120);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 803:67: -> POSITIVEN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(POSITIVEN_VK, REGULAR_ID120));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepositiven_keyEx; /* Prevent compiler warnings */
    rulepositiven_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end positiven_key */

/**
 * $ANTLR start timezone_abbr_key
 * OracleDMLKeys.g:806:1: timezone_abbr_key :{...}? => REGULAR_ID -> TIMEZONE_ABBR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timezone_abbr_key_return
OracleDML_OracleDMLKeys::timezone_abbr_key()
{
    OracleDML_OracleDMLKeys::timezone_abbr_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID121 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID121_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:807:5: ({...}? => REGULAR_ID -> TIMEZONE_ABBR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:807:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMEZONE_ABBR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMEZONE_ABBR\"" );
                    ex->set_ruleName( "timezone_abbr_key" );


            }

            REGULAR_ID121 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_abbr_key3283);
            if  (this->hasException())
            {
                goto ruletimezone_abbr_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID121);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 807:71: -> TIMEZONE_ABBR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMEZONE_ABBR_VK, REGULAR_ID121));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimezone_abbr_keyEx; /* Prevent compiler warnings */
    ruletimezone_abbr_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timezone_abbr_key */

/**
 * $ANTLR start binary_double_min_subnormal_key
 * OracleDMLKeys.g:810:1: binary_double_min_subnormal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_double_min_subnormal_key_return
OracleDML_OracleDMLKeys::binary_double_min_subnormal_key()
{
    OracleDML_OracleDMLKeys::binary_double_min_subnormal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID122 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID122_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:811:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:811:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_DOUBLE_MIN_SUBNORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_DOUBLE_MIN_SUBNORMAL\"" );
                    ex->set_ruleName( "binary_double_min_subnormal_key" );


            }

            REGULAR_ID122 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key3311);
            if  (this->hasException())
            {
                goto rulebinary_double_min_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID122_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID122));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID122_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_double_min_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_min_subnormal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_double_min_subnormal_key */

/**
 * $ANTLR start binary_float_max_subnormal_key
 * OracleDMLKeys.g:814:1: binary_float_max_subnormal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_float_max_subnormal_key_return
OracleDML_OracleDMLKeys::binary_float_max_subnormal_key()
{
    OracleDML_OracleDMLKeys::binary_float_max_subnormal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID123 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID123_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:815:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:815:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_FLOAT_MAX_SUBNORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_FLOAT_MAX_SUBNORMAL\"" );
                    ex->set_ruleName( "binary_float_max_subnormal_key" );


            }

            REGULAR_ID123 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key3334);
            if  (this->hasException())
            {
                goto rulebinary_float_max_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID123_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID123));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID123_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_float_max_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_max_subnormal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_float_max_subnormal_key */

/**
 * $ANTLR start binary_double_key
 * OracleDMLKeys.g:818:1: binary_double_key :{...}? => REGULAR_ID -> BINARY_DOUBLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::binary_double_key_return
OracleDML_OracleDMLKeys::binary_double_key()
{
    OracleDML_OracleDMLKeys::binary_double_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID124 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID124_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:819:5: ({...}? => REGULAR_ID -> BINARY_DOUBLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:819:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BINARY_DOUBLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_DOUBLE\"" );
                    ex->set_ruleName( "binary_double_key" );


            }

            REGULAR_ID124 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_key3357);
            if  (this->hasException())
            {
                goto rulebinary_double_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID124);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 819:71: -> BINARY_DOUBLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BINARY_DOUBLE_VK, REGULAR_ID124));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_double_keyEx; /* Prevent compiler warnings */
    rulebinary_double_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_double_key */

/**
 * $ANTLR start bfile_key
 * OracleDMLKeys.g:822:1: bfile_key :{...}? => REGULAR_ID -> BFILE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::bfile_key_return
OracleDML_OracleDMLKeys::bfile_key()
{
    OracleDML_OracleDMLKeys::bfile_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID125 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID125_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:823:5: ({...}? => REGULAR_ID -> BFILE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:823:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BFILE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BFILE\"" );
                    ex->set_ruleName( "bfile_key" );


            }

            REGULAR_ID125 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bfile_key3385);
            if  (this->hasException())
            {
                goto rulebfile_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID125);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 823:63: -> BFILE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BFILE_VK, REGULAR_ID125));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebfile_keyEx; /* Prevent compiler warnings */
    rulebfile_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end bfile_key */

/**
 * $ANTLR start binary_double_infinity_key
 * OracleDMLKeys.g:826:1: binary_double_infinity_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_double_infinity_key_return
OracleDML_OracleDMLKeys::binary_double_infinity_key()
{
    OracleDML_OracleDMLKeys::binary_double_infinity_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID126 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID126_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:827:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:827:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_DOUBLE_INFINITY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_DOUBLE_INFINITY\"" );
                    ex->set_ruleName( "binary_double_infinity_key" );


            }

            REGULAR_ID126 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_infinity_key3413);
            if  (this->hasException())
            {
                goto rulebinary_double_infinity_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID126_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID126));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID126_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_double_infinity_keyEx; /* Prevent compiler warnings */
    rulebinary_double_infinity_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_double_infinity_key */

/**
 * $ANTLR start timezone_region_key
 * OracleDMLKeys.g:830:1: timezone_region_key :{...}? => REGULAR_ID -> TIMEZONE_REGION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timezone_region_key_return
OracleDML_OracleDMLKeys::timezone_region_key()
{
    OracleDML_OracleDMLKeys::timezone_region_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID127 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID127_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:831:5: ({...}? => REGULAR_ID -> TIMEZONE_REGION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:831:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMEZONE_REGION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMEZONE_REGION\"" );
                    ex->set_ruleName( "timezone_region_key" );


            }

            REGULAR_ID127 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_region_key3436);
            if  (this->hasException())
            {
                goto ruletimezone_region_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID127);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 831:73: -> TIMEZONE_REGION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMEZONE_REGION_VK, REGULAR_ID127));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimezone_region_keyEx; /* Prevent compiler warnings */
    ruletimezone_region_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timezone_region_key */

/**
 * $ANTLR start timestamp_ltz_unconstrained_key
 * OracleDMLKeys.g:834:1: timestamp_ltz_unconstrained_key :{...}? => REGULAR_ID -> TIMESTAMP_LTZ_UNCONSTRAINED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timestamp_ltz_unconstrained_key_return
OracleDML_OracleDMLKeys::timestamp_ltz_unconstrained_key()
{
    OracleDML_OracleDMLKeys::timestamp_ltz_unconstrained_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID128 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID128_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:835:5: ({...}? => REGULAR_ID -> TIMESTAMP_LTZ_UNCONSTRAINED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:835:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMESTAMP_LTZ_UNCONSTRAINED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMESTAMP_LTZ_UNCONSTRAINED\"" );
                    ex->set_ruleName( "timestamp_ltz_unconstrained_key" );


            }

            REGULAR_ID128 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key3464);
            if  (this->hasException())
            {
                goto ruletimestamp_ltz_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID128);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 835:85: -> TIMESTAMP_LTZ_UNCONSTRAINED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMESTAMP_LTZ_UNCONSTRAINED_VK, REGULAR_ID128));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimestamp_ltz_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_ltz_unconstrained_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timestamp_ltz_unconstrained_key */

/**
 * $ANTLR start naturaln_key
 * OracleDMLKeys.g:838:1: naturaln_key :{...}? => REGULAR_ID -> NATURALN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::naturaln_key_return
OracleDML_OracleDMLKeys::naturaln_key()
{
    OracleDML_OracleDMLKeys::naturaln_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID129 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID129_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:839:5: ({...}? => REGULAR_ID -> NATURALN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:839:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NATURALN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NATURALN\"" );
                    ex->set_ruleName( "naturaln_key" );


            }

            REGULAR_ID129 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_naturaln_key3492);
            if  (this->hasException())
            {
                goto rulenaturaln_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID129);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 839:66: -> NATURALN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NATURALN_VK, REGULAR_ID129));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenaturaln_keyEx; /* Prevent compiler warnings */
    rulenaturaln_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end naturaln_key */

/**
 * $ANTLR start simple_integer_key
 * OracleDMLKeys.g:842:1: simple_integer_key :{...}? => REGULAR_ID -> SIMPLE_INTEGER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::simple_integer_key_return
OracleDML_OracleDMLKeys::simple_integer_key()
{
    OracleDML_OracleDMLKeys::simple_integer_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID130 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID130_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:843:5: ({...}? => REGULAR_ID -> SIMPLE_INTEGER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:843:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SIMPLE_INTEGER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SIMPLE_INTEGER\"" );
                    ex->set_ruleName( "simple_integer_key" );


            }

            REGULAR_ID130 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_simple_integer_key3520);
            if  (this->hasException())
            {
                goto rulesimple_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID130);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 843:72: -> SIMPLE_INTEGER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SIMPLE_INTEGER_VK, REGULAR_ID130));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesimple_integer_keyEx; /* Prevent compiler warnings */
    rulesimple_integer_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end simple_integer_key */

/**
 * $ANTLR start binary_double_max_subnormal_key
 * OracleDMLKeys.g:846:1: binary_double_max_subnormal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_double_max_subnormal_key_return
OracleDML_OracleDMLKeys::binary_double_max_subnormal_key()
{
    OracleDML_OracleDMLKeys::binary_double_max_subnormal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID131 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID131_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:847:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:847:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_DOUBLE_MAX_SUBNORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_DOUBLE_MAX_SUBNORMAL\"" );
                    ex->set_ruleName( "binary_double_max_subnormal_key" );


            }

            REGULAR_ID131 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key3548);
            if  (this->hasException())
            {
                goto rulebinary_double_max_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID131_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID131));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID131_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_double_max_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_max_subnormal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_double_max_subnormal_key */

/**
 * $ANTLR start byte_key
 * OracleDMLKeys.g:850:1: byte_key :{...}? => REGULAR_ID -> BYTE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::byte_key_return
OracleDML_OracleDMLKeys::byte_key()
{
    OracleDML_OracleDMLKeys::byte_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID132 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID132_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:851:5: ({...}? => REGULAR_ID -> BYTE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:851:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BYTE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BYTE\"" );
                    ex->set_ruleName( "byte_key" );


            }

            REGULAR_ID132 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_byte_key3571);
            if  (this->hasException())
            {
                goto rulebyte_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID132);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 851:62: -> BYTE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BYTE_VK, REGULAR_ID132));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebyte_keyEx; /* Prevent compiler warnings */
    rulebyte_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end byte_key */

/**
 * $ANTLR start binary_float_infinity_key
 * OracleDMLKeys.g:854:1: binary_float_infinity_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_float_infinity_key_return
OracleDML_OracleDMLKeys::binary_float_infinity_key()
{
    OracleDML_OracleDMLKeys::binary_float_infinity_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID133 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID133_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:855:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:855:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_FLOAT_INFINITY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_FLOAT_INFINITY\"" );
                    ex->set_ruleName( "binary_float_infinity_key" );


            }

            REGULAR_ID133 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_infinity_key3599);
            if  (this->hasException())
            {
                goto rulebinary_float_infinity_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID133_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID133));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID133_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_float_infinity_keyEx; /* Prevent compiler warnings */
    rulebinary_float_infinity_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_float_infinity_key */

/**
 * $ANTLR start binary_float_key
 * OracleDMLKeys.g:858:1: binary_float_key :{...}? => REGULAR_ID -> BINARY_FLOAT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::binary_float_key_return
OracleDML_OracleDMLKeys::binary_float_key()
{
    OracleDML_OracleDMLKeys::binary_float_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID134 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID134_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:859:5: ({...}? => REGULAR_ID -> BINARY_FLOAT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:859:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BINARY_FLOAT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_FLOAT\"" );
                    ex->set_ruleName( "binary_float_key" );


            }

            REGULAR_ID134 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_key3622);
            if  (this->hasException())
            {
                goto rulebinary_float_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID134);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 859:70: -> BINARY_FLOAT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BINARY_FLOAT_VK, REGULAR_ID134));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_float_keyEx; /* Prevent compiler warnings */
    rulebinary_float_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_float_key */

/**
 * $ANTLR start range_key
 * OracleDMLKeys.g:862:1: range_key :{...}? => REGULAR_ID -> RANGE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::range_key_return
OracleDML_OracleDMLKeys::range_key()
{
    OracleDML_OracleDMLKeys::range_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID135 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID135_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:863:5: ({...}? => REGULAR_ID -> RANGE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:863:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "range")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"range\"" );
                    ex->set_ruleName( "range_key" );


            }

            REGULAR_ID135 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_range_key3650);
            if  (this->hasException())
            {
                goto rulerange_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID135);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 863:63: -> RANGE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RANGE_VK, REGULAR_ID135));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerange_keyEx; /* Prevent compiler warnings */
    rulerange_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end range_key */

/**
 * $ANTLR start nclob_key
 * OracleDMLKeys.g:866:1: nclob_key :{...}? => REGULAR_ID -> NCLOB_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nclob_key_return
OracleDML_OracleDMLKeys::nclob_key()
{
    OracleDML_OracleDMLKeys::nclob_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID136 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID136_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:867:5: ({...}? => REGULAR_ID -> NCLOB_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:867:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NCLOB")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NCLOB\"" );
                    ex->set_ruleName( "nclob_key" );


            }

            REGULAR_ID136 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nclob_key3678);
            if  (this->hasException())
            {
                goto rulenclob_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID136);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 867:63: -> NCLOB_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NCLOB_VK, REGULAR_ID136));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenclob_keyEx; /* Prevent compiler warnings */
    rulenclob_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nclob_key */

/**
 * $ANTLR start clob_key
 * OracleDMLKeys.g:870:1: clob_key :{...}? => REGULAR_ID -> CLOB_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::clob_key_return
OracleDML_OracleDMLKeys::clob_key()
{
    OracleDML_OracleDMLKeys::clob_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID137 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID137_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:871:5: ({...}? => REGULAR_ID -> CLOB_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:871:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CLOB")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CLOB\"" );
                    ex->set_ruleName( "clob_key" );


            }

            REGULAR_ID137 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_clob_key3706);
            if  (this->hasException())
            {
                goto ruleclob_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID137);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 871:62: -> CLOB_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CLOB_VK, REGULAR_ID137));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleclob_keyEx; /* Prevent compiler warnings */
    ruleclob_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end clob_key */

/**
 * $ANTLR start dsinterval_unconstrained_key
 * OracleDMLKeys.g:874:1: dsinterval_unconstrained_key :{...}? => REGULAR_ID -> DSINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::dsinterval_unconstrained_key_return
OracleDML_OracleDMLKeys::dsinterval_unconstrained_key()
{
    OracleDML_OracleDMLKeys::dsinterval_unconstrained_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID138 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID138_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:875:5: ({...}? => REGULAR_ID -> DSINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:875:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DSINTERVAL_UNCONSTRAINED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DSINTERVAL_UNCONSTRAINED\"" );
                    ex->set_ruleName( "dsinterval_unconstrained_key" );


            }

            REGULAR_ID138 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3734);
            if  (this->hasException())
            {
                goto ruledsinterval_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID138);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 875:82: -> DSINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DSINTERVAL_UNCONSTRAINED_VK, REGULAR_ID138));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledsinterval_unconstrained_keyEx; /* Prevent compiler warnings */
    ruledsinterval_unconstrained_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dsinterval_unconstrained_key */

/**
 * $ANTLR start yminterval_unconstrained_key
 * OracleDMLKeys.g:878:1: yminterval_unconstrained_key :{...}? => REGULAR_ID -> YMINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::yminterval_unconstrained_key_return
OracleDML_OracleDMLKeys::yminterval_unconstrained_key()
{
    OracleDML_OracleDMLKeys::yminterval_unconstrained_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID139 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID139_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:879:5: ({...}? => REGULAR_ID -> YMINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:879:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "YMINTERVAL_UNCONSTRAINED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"YMINTERVAL_UNCONSTRAINED\"" );
                    ex->set_ruleName( "yminterval_unconstrained_key" );


            }

            REGULAR_ID139 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3762);
            if  (this->hasException())
            {
                goto ruleyminterval_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID139);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 879:82: -> YMINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(YMINTERVAL_UNCONSTRAINED_VK, REGULAR_ID139));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleyminterval_unconstrained_keyEx; /* Prevent compiler warnings */
    ruleyminterval_unconstrained_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end yminterval_unconstrained_key */

/**
 * $ANTLR start rowid_key
 * OracleDMLKeys.g:882:1: rowid_key :{...}? => REGULAR_ID -> ROWID_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::rowid_key_return
OracleDML_OracleDMLKeys::rowid_key()
{
    OracleDML_OracleDMLKeys::rowid_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID140 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID140_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:883:5: ({...}? => REGULAR_ID -> ROWID_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:883:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ROWID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROWID\"" );
                    ex->set_ruleName( "rowid_key" );


            }

            REGULAR_ID140 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rowid_key3790);
            if  (this->hasException())
            {
                goto rulerowid_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID140);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 883:63: -> ROWID_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ROWID_VK, REGULAR_ID140));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerowid_keyEx; /* Prevent compiler warnings */
    rulerowid_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rowid_key */

/**
 * $ANTLR start binary_double_nan_key
 * OracleDMLKeys.g:886:1: binary_double_nan_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_double_nan_key_return
OracleDML_OracleDMLKeys::binary_double_nan_key()
{
    OracleDML_OracleDMLKeys::binary_double_nan_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID141 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID141_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:887:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:887:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_DOUBLE_NAN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_DOUBLE_NAN\"" );
                    ex->set_ruleName( "binary_double_nan_key" );


            }

            REGULAR_ID141 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_nan_key3818);
            if  (this->hasException())
            {
                goto rulebinary_double_nan_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID141_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID141));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID141_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_double_nan_keyEx; /* Prevent compiler warnings */
    rulebinary_double_nan_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_double_nan_key */

/**
 * $ANTLR start timestamp_unconstrained_key
 * OracleDMLKeys.g:890:1: timestamp_unconstrained_key :{...}? => REGULAR_ID -> TIMESTAMP_UNCONSTRAINED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timestamp_unconstrained_key_return
OracleDML_OracleDMLKeys::timestamp_unconstrained_key()
{
    OracleDML_OracleDMLKeys::timestamp_unconstrained_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID142 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID142_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:891:5: ({...}? => REGULAR_ID -> TIMESTAMP_UNCONSTRAINED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:891:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMESTAMP_UNCONSTRAINED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMESTAMP_UNCONSTRAINED\"" );
                    ex->set_ruleName( "timestamp_unconstrained_key" );


            }

            REGULAR_ID142 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3841);
            if  (this->hasException())
            {
                goto ruletimestamp_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID142);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 891:81: -> TIMESTAMP_UNCONSTRAINED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMESTAMP_UNCONSTRAINED_VK, REGULAR_ID142));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimestamp_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_unconstrained_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timestamp_unconstrained_key */

/**
 * $ANTLR start binary_float_min_normal_key
 * OracleDMLKeys.g:894:1: binary_float_min_normal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_float_min_normal_key_return
OracleDML_OracleDMLKeys::binary_float_min_normal_key()
{
    OracleDML_OracleDMLKeys::binary_float_min_normal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID143 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID143_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:895:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:895:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_FLOAT_MIN_NORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_FLOAT_MIN_NORMAL\"" );
                    ex->set_ruleName( "binary_float_min_normal_key" );


            }

            REGULAR_ID143 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3869);
            if  (this->hasException())
            {
                goto rulebinary_float_min_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID143_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID143));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID143_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_float_min_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_min_normal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_float_min_normal_key */

/**
 * $ANTLR start signtype_key
 * OracleDMLKeys.g:898:1: signtype_key :{...}? => REGULAR_ID -> SIGNTYPE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::signtype_key_return
OracleDML_OracleDMLKeys::signtype_key()
{
    OracleDML_OracleDMLKeys::signtype_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID144 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID144_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:899:5: ({...}? => REGULAR_ID -> SIGNTYPE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:899:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SIGNTYPE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SIGNTYPE\"" );
                    ex->set_ruleName( "signtype_key" );


            }

            REGULAR_ID144 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_signtype_key3892);
            if  (this->hasException())
            {
                goto rulesigntype_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID144);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 899:66: -> SIGNTYPE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SIGNTYPE_VK, REGULAR_ID144));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesigntype_keyEx; /* Prevent compiler warnings */
    rulesigntype_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end signtype_key */

/**
 * $ANTLR start blob_key
 * OracleDMLKeys.g:902:1: blob_key :{...}? => REGULAR_ID -> BLOB_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::blob_key_return
OracleDML_OracleDMLKeys::blob_key()
{
    OracleDML_OracleDMLKeys::blob_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID145 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID145_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:903:5: ({...}? => REGULAR_ID -> BLOB_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:903:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BLOB")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BLOB\"" );
                    ex->set_ruleName( "blob_key" );


            }

            REGULAR_ID145 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_blob_key3920);
            if  (this->hasException())
            {
                goto ruleblob_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID145);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 903:62: -> BLOB_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BLOB_VK, REGULAR_ID145));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleblob_keyEx; /* Prevent compiler warnings */
    ruleblob_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end blob_key */

/**
 * $ANTLR start nvarchar2_key
 * OracleDMLKeys.g:906:1: nvarchar2_key :{...}? => REGULAR_ID -> NVARCHAR2_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nvarchar2_key_return
OracleDML_OracleDMLKeys::nvarchar2_key()
{
    OracleDML_OracleDMLKeys::nvarchar2_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID146 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID146_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:907:5: ({...}? => REGULAR_ID -> NVARCHAR2_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:907:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NVARCHAR2")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NVARCHAR2\"" );
                    ex->set_ruleName( "nvarchar2_key" );


            }

            REGULAR_ID146 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nvarchar2_key3948);
            if  (this->hasException())
            {
                goto rulenvarchar2_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID146);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 907:67: -> NVARCHAR2_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NVARCHAR2_VK, REGULAR_ID146));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenvarchar2_keyEx; /* Prevent compiler warnings */
    rulenvarchar2_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nvarchar2_key */

/**
 * $ANTLR start binary_double_max_normal_key
 * OracleDMLKeys.g:910:1: binary_double_max_normal_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_double_max_normal_key_return
OracleDML_OracleDMLKeys::binary_double_max_normal_key()
{
    OracleDML_OracleDMLKeys::binary_double_max_normal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID147 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID147_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:911:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:911:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_DOUBLE_MAX_NORMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_DOUBLE_MAX_NORMAL\"" );
                    ex->set_ruleName( "binary_double_max_normal_key" );


            }

            REGULAR_ID147 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3976);
            if  (this->hasException())
            {
                goto rulebinary_double_max_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID147_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID147));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID147_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_double_max_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_max_normal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_double_max_normal_key */

/**
 * $ANTLR start binary_float_nan_key
 * OracleDMLKeys.g:914:1: binary_float_nan_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::binary_float_nan_key_return
OracleDML_OracleDMLKeys::binary_float_nan_key()
{
    OracleDML_OracleDMLKeys::binary_float_nan_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID148 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID148_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:915:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:915:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BINARY_FLOAT_NAN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_FLOAT_NAN\"" );
                    ex->set_ruleName( "binary_float_nan_key" );


            }

            REGULAR_ID148 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_nan_key3999);
            if  (this->hasException())
            {
                goto rulebinary_float_nan_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID148_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID148));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID148_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_float_nan_keyEx; /* Prevent compiler warnings */
    rulebinary_float_nan_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_float_nan_key */

/**
 * $ANTLR start string_key
 * OracleDMLKeys.g:918:1: string_key :{...}? => REGULAR_ID -> STRING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::string_key_return
OracleDML_OracleDMLKeys::string_key()
{
    OracleDML_OracleDMLKeys::string_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID149 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID149_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:919:5: ({...}? => REGULAR_ID -> STRING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:919:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "STRING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STRING\"" );
                    ex->set_ruleName( "string_key" );


            }

            REGULAR_ID149 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_string_key4022);
            if  (this->hasException())
            {
                goto rulestring_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID149);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 919:64: -> STRING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(STRING_VK, REGULAR_ID149));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestring_keyEx; /* Prevent compiler warnings */
    rulestring_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end string_key */

/**
 * $ANTLR start c_key
 * OracleDMLKeys.g:922:1: c_key :{...}? => REGULAR_ID -> C_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::c_key_return
OracleDML_OracleDMLKeys::c_key()
{
    OracleDML_OracleDMLKeys::c_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID150 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID150_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:923:5: ({...}? => REGULAR_ID -> C_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:923:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "C")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"C\"" );
                    ex->set_ruleName( "c_key" );


            }

            REGULAR_ID150 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_c_key4050);
            if  (this->hasException())
            {
                goto rulec_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID150);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 923:59: -> C_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(C_VK, REGULAR_ID150));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulec_keyEx; /* Prevent compiler warnings */
    rulec_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end c_key */

/**
 * $ANTLR start library_key
 * OracleDMLKeys.g:926:1: library_key :{...}? => REGULAR_ID -> LIBRARY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::library_key_return
OracleDML_OracleDMLKeys::library_key()
{
    OracleDML_OracleDMLKeys::library_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID151 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID151_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:927:5: ({...}? => REGULAR_ID -> LIBRARY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:927:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LIBRARY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LIBRARY\"" );
                    ex->set_ruleName( "library_key" );


            }

            REGULAR_ID151 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_library_key4078);
            if  (this->hasException())
            {
                goto rulelibrary_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID151);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 927:65: -> LIBRARY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LIBRARY_VK, REGULAR_ID151));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelibrary_keyEx; /* Prevent compiler warnings */
    rulelibrary_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end library_key */

/**
 * $ANTLR start context_key
 * OracleDMLKeys.g:930:1: context_key :{...}? => REGULAR_ID -> CONTEXT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::context_key_return
OracleDML_OracleDMLKeys::context_key()
{
    OracleDML_OracleDMLKeys::context_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID152 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID152_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:931:5: ({...}? => REGULAR_ID -> CONTEXT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:931:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CONTEXT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONTEXT\"" );
                    ex->set_ruleName( "context_key" );


            }

            REGULAR_ID152 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_context_key4106);
            if  (this->hasException())
            {
                goto rulecontext_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID152);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 931:65: -> CONTEXT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CONTEXT_VK, REGULAR_ID152));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecontext_keyEx; /* Prevent compiler warnings */
    rulecontext_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end context_key */

/**
 * $ANTLR start parameters_key
 * OracleDMLKeys.g:934:1: parameters_key :{...}? => REGULAR_ID -> PARAMETERS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::parameters_key_return
OracleDML_OracleDMLKeys::parameters_key()
{
    OracleDML_OracleDMLKeys::parameters_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID153 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID153_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:935:5: ({...}? => REGULAR_ID -> PARAMETERS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:935:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PARAMETERS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PARAMETERS\"" );
                    ex->set_ruleName( "parameters_key" );


            }

            REGULAR_ID153 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parameters_key4134);
            if  (this->hasException())
            {
                goto ruleparameters_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID153);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 935:68: -> PARAMETERS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PARAMETERS_VK, REGULAR_ID153));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleparameters_keyEx; /* Prevent compiler warnings */
    ruleparameters_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end parameters_key */

/**
 * $ANTLR start agent_key
 * OracleDMLKeys.g:938:1: agent_key :{...}? => REGULAR_ID -> AGENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::agent_key_return
OracleDML_OracleDMLKeys::agent_key()
{
    OracleDML_OracleDMLKeys::agent_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID154 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID154_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:939:5: ({...}? => REGULAR_ID -> AGENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:939:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AGENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AGENT\"" );
                    ex->set_ruleName( "agent_key" );


            }

            REGULAR_ID154 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_agent_key4162);
            if  (this->hasException())
            {
                goto ruleagent_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID154);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 939:63: -> AGENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AGENT_VK, REGULAR_ID154));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleagent_keyEx; /* Prevent compiler warnings */
    ruleagent_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end agent_key */

/**
 * $ANTLR start cluster_key
 * OracleDMLKeys.g:942:1: cluster_key :{...}? => REGULAR_ID -> CLUSTER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::cluster_key_return
OracleDML_OracleDMLKeys::cluster_key()
{
    OracleDML_OracleDMLKeys::cluster_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID155 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID155_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:943:5: ({...}? => REGULAR_ID -> CLUSTER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:943:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CLUSTER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CLUSTER\"" );
                    ex->set_ruleName( "cluster_key" );


            }

            REGULAR_ID155 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cluster_key4190);
            if  (this->hasException())
            {
                goto rulecluster_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID155);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 943:65: -> CLUSTER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CLUSTER_VK, REGULAR_ID155));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecluster_keyEx; /* Prevent compiler warnings */
    rulecluster_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cluster_key */

/**
 * $ANTLR start hash_key
 * OracleDMLKeys.g:946:1: hash_key :{...}? => REGULAR_ID -> HASH_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::hash_key_return
OracleDML_OracleDMLKeys::hash_key()
{
    OracleDML_OracleDMLKeys::hash_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID156 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID156_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:947:5: ({...}? => REGULAR_ID -> HASH_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:947:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "HASH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"HASH\"" );
                    ex->set_ruleName( "hash_key" );


            }

            REGULAR_ID156 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hash_key4218);
            if  (this->hasException())
            {
                goto rulehash_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID156);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 947:62: -> HASH_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(HASH_VK, REGULAR_ID156));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulehash_keyEx; /* Prevent compiler warnings */
    rulehash_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end hash_key */

/**
 * $ANTLR start relies_on_key
 * OracleDMLKeys.g:950:1: relies_on_key :{...}? => REGULAR_ID -> RELIES_ON_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::relies_on_key_return
OracleDML_OracleDMLKeys::relies_on_key()
{
    OracleDML_OracleDMLKeys::relies_on_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID157 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID157_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:951:5: ({...}? => REGULAR_ID -> RELIES_ON_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:951:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RELIES_ON")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RELIES_ON\"" );
                    ex->set_ruleName( "relies_on_key" );


            }

            REGULAR_ID157 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_relies_on_key4246);
            if  (this->hasException())
            {
                goto rulerelies_on_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID157);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 951:67: -> RELIES_ON_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RELIES_ON_VK, REGULAR_ID157));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerelies_on_keyEx; /* Prevent compiler warnings */
    rulerelies_on_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end relies_on_key */

/**
 * $ANTLR start returning_key
 * OracleDMLKeys.g:954:1: returning_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::returning_key_return
OracleDML_OracleDMLKeys::returning_key()
{
    OracleDML_OracleDMLKeys::returning_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID158 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID158_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:955:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:955:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "RETURNING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RETURNING\"" );
                    ex->set_ruleName( "returning_key" );


            }

            REGULAR_ID158 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_returning_key4274);
            if  (this->hasException())
            {
                goto rulereturning_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID158_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID158));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID158_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereturning_keyEx; /* Prevent compiler warnings */
    rulereturning_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end returning_key */

/**
 * $ANTLR start statement_id_key
 * OracleDMLKeys.g:958:1: statement_id_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::statement_id_key_return
OracleDML_OracleDMLKeys::statement_id_key()
{
    OracleDML_OracleDMLKeys::statement_id_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID159 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID159_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:959:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:959:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "STATEMENT_ID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STATEMENT_ID\"" );
                    ex->set_ruleName( "statement_id_key" );


            }

            REGULAR_ID159 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statement_id_key4301);
            if  (this->hasException())
            {
                goto rulestatement_id_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID159_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID159));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID159_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestatement_id_keyEx; /* Prevent compiler warnings */
    rulestatement_id_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end statement_id_key */

/**
 * $ANTLR start deferred_key
 * OracleDMLKeys.g:962:1: deferred_key :{...}? => REGULAR_ID -> DEFERRED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::deferred_key_return
OracleDML_OracleDMLKeys::deferred_key()
{
    OracleDML_OracleDMLKeys::deferred_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID160 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID160_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:963:5: ({...}? => REGULAR_ID -> DEFERRED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:963:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DEFERRED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DEFERRED\"" );
                    ex->set_ruleName( "deferred_key" );


            }

            REGULAR_ID160 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_deferred_key4324);
            if  (this->hasException())
            {
                goto ruledeferred_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID160);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 963:66: -> DEFERRED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DEFERRED_VK, REGULAR_ID160));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledeferred_keyEx; /* Prevent compiler warnings */
    ruledeferred_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end deferred_key */

/**
 * $ANTLR start advise_key
 * OracleDMLKeys.g:966:1: advise_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::advise_key_return
OracleDML_OracleDMLKeys::advise_key()
{
    OracleDML_OracleDMLKeys::advise_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID161 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID161_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:967:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:967:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ADVISE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ADVISE\"" );
                    ex->set_ruleName( "advise_key" );


            }

            REGULAR_ID161 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_advise_key4352);
            if  (this->hasException())
            {
                goto ruleadvise_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID161_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID161));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID161_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleadvise_keyEx; /* Prevent compiler warnings */
    ruleadvise_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end advise_key */

/**
 * $ANTLR start resumable_key
 * OracleDMLKeys.g:970:1: resumable_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::resumable_key_return
OracleDML_OracleDMLKeys::resumable_key()
{
    OracleDML_OracleDMLKeys::resumable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID162 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID162_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:971:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:971:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "RESUMABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RESUMABLE\"" );
                    ex->set_ruleName( "resumable_key" );


            }

            REGULAR_ID162 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_resumable_key4375);
            if  (this->hasException())
            {
                goto ruleresumable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID162_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID162));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID162_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleresumable_keyEx; /* Prevent compiler warnings */
    ruleresumable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end resumable_key */

/**
 * $ANTLR start timeout_key
 * OracleDMLKeys.g:974:1: timeout_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::timeout_key_return
OracleDML_OracleDMLKeys::timeout_key()
{
    OracleDML_OracleDMLKeys::timeout_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID163 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID163_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:975:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:975:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "TIMEOUT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMEOUT\"" );
                    ex->set_ruleName( "timeout_key" );


            }

            REGULAR_ID163 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timeout_key4398);
            if  (this->hasException())
            {
                goto ruletimeout_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID163_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID163));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID163_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimeout_keyEx; /* Prevent compiler warnings */
    ruletimeout_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timeout_key */

/**
 * $ANTLR start parallel_key
 * OracleDMLKeys.g:978:1: parallel_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::parallel_key_return
OracleDML_OracleDMLKeys::parallel_key()
{
    OracleDML_OracleDMLKeys::parallel_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID164 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID164_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:979:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:979:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "PARALLEL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PARALLEL\"" );
                    ex->set_ruleName( "parallel_key" );


            }

            REGULAR_ID164 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parallel_key4421);
            if  (this->hasException())
            {
                goto ruleparallel_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID164_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID164));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID164_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleparallel_keyEx; /* Prevent compiler warnings */
    ruleparallel_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end parallel_key */

/**
 * $ANTLR start ddl_key
 * OracleDMLKeys.g:982:1: ddl_key :{...}? => REGULAR_ID -> DDL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::ddl_key_return
OracleDML_OracleDMLKeys::ddl_key()
{
    OracleDML_OracleDMLKeys::ddl_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID165 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID165_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:983:5: ({...}? => REGULAR_ID -> DDL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:983:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DDL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DDL\"" );
                    ex->set_ruleName( "ddl_key" );


            }

            REGULAR_ID165 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ddl_key4444);
            if  (this->hasException())
            {
                goto ruleddl_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID165);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 983:61: -> DDL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DDL_VK, REGULAR_ID165));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleddl_keyEx; /* Prevent compiler warnings */
    ruleddl_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end ddl_key */

/**
 * $ANTLR start query_key
 * OracleDMLKeys.g:986:1: query_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::query_key_return
OracleDML_OracleDMLKeys::query_key()
{
    OracleDML_OracleDMLKeys::query_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID166 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID166_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:987:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:987:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "QUERY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"QUERY\"" );
                    ex->set_ruleName( "query_key" );


            }

            REGULAR_ID166 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_query_key4472);
            if  (this->hasException())
            {
                goto rulequery_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID166_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID166));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID166_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulequery_keyEx; /* Prevent compiler warnings */
    rulequery_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end query_key */

/**
 * $ANTLR start dml_key
 * OracleDMLKeys.g:990:1: dml_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::dml_key_return
OracleDML_OracleDMLKeys::dml_key()
{
    OracleDML_OracleDMLKeys::dml_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID167 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID167_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:991:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:991:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "DML")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DML\"" );
                    ex->set_ruleName( "dml_key" );


            }

            REGULAR_ID167 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dml_key4495);
            if  (this->hasException())
            {
                goto ruledml_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID167_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID167));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID167_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledml_keyEx; /* Prevent compiler warnings */
    ruledml_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dml_key */

/**
 * $ANTLR start guard_key
 * OracleDMLKeys.g:994:1: guard_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::guard_key_return
OracleDML_OracleDMLKeys::guard_key()
{
    OracleDML_OracleDMLKeys::guard_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID168 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID168_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:995:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:995:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "GUARD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"GUARD\"" );
                    ex->set_ruleName( "guard_key" );


            }

            REGULAR_ID168 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_guard_key4518);
            if  (this->hasException())
            {
                goto ruleguard_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID168_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID168));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID168_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleguard_keyEx; /* Prevent compiler warnings */
    ruleguard_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end guard_key */

/**
 * $ANTLR start nothing_key
 * OracleDMLKeys.g:998:1: nothing_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::nothing_key_return
OracleDML_OracleDMLKeys::nothing_key()
{
    OracleDML_OracleDMLKeys::nothing_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID169 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID169_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:999:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:999:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "NOTHING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOTHING\"" );
                    ex->set_ruleName( "nothing_key" );


            }

            REGULAR_ID169 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nothing_key4541);
            if  (this->hasException())
            {
                goto rulenothing_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID169_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID169));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID169_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenothing_keyEx; /* Prevent compiler warnings */
    rulenothing_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nothing_key */

/**
 * $ANTLR start enable_key
 * OracleDMLKeys.g:1002:1: enable_key :{...}? => REGULAR_ID -> ENABLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::enable_key_return
OracleDML_OracleDMLKeys::enable_key()
{
    OracleDML_OracleDMLKeys::enable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID170 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID170_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1003:5: ({...}? => REGULAR_ID -> ENABLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1003:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ENABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ENABLE\"" );
                    ex->set_ruleName( "enable_key" );


            }

            REGULAR_ID170 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_enable_key4564);
            if  (this->hasException())
            {
                goto ruleenable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID170);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1003:64: -> ENABLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ENABLE_VK, REGULAR_ID170));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleenable_keyEx; /* Prevent compiler warnings */
    ruleenable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end enable_key */

/**
 * $ANTLR start database_key
 * OracleDMLKeys.g:1006:1: database_key :{...}? => REGULAR_ID -> DATABASE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::database_key_return
OracleDML_OracleDMLKeys::database_key()
{
    OracleDML_OracleDMLKeys::database_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID171 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID171_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1007:5: ({...}? => REGULAR_ID -> DATABASE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1007:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DATABASE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DATABASE\"" );
                    ex->set_ruleName( "database_key" );


            }

            REGULAR_ID171 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_database_key4592);
            if  (this->hasException())
            {
                goto ruledatabase_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID171);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1007:66: -> DATABASE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DATABASE_VK, REGULAR_ID171));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledatabase_keyEx; /* Prevent compiler warnings */
    ruledatabase_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end database_key */

/**
 * $ANTLR start disable_key
 * OracleDMLKeys.g:1010:1: disable_key :{...}? => REGULAR_ID -> DISABLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::disable_key_return
OracleDML_OracleDMLKeys::disable_key()
{
    OracleDML_OracleDMLKeys::disable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID172 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID172_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1011:5: ({...}? => REGULAR_ID -> DISABLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1011:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DISABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DISABLE\"" );
                    ex->set_ruleName( "disable_key" );


            }

            REGULAR_ID172 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_disable_key4620);
            if  (this->hasException())
            {
                goto ruledisable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID172);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1011:65: -> DISABLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DISABLE_VK, REGULAR_ID172));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledisable_keyEx; /* Prevent compiler warnings */
    ruledisable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end disable_key */

/**
 * $ANTLR start link_key
 * OracleDMLKeys.g:1014:1: link_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::link_key_return
OracleDML_OracleDMLKeys::link_key()
{
    OracleDML_OracleDMLKeys::link_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID173 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID173_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1015:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1015:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LINK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LINK\"" );
                    ex->set_ruleName( "link_key" );


            }

            REGULAR_ID173 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_link_key4648);
            if  (this->hasException())
            {
                goto rulelink_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID173_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID173));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID173_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelink_keyEx; /* Prevent compiler warnings */
    rulelink_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end link_key */

/**
 * $ANTLR start identified_key
 * OracleDMLKeys.g:1018:1: identified_key : PLSQL_RESERVED_IDENTIFIED ;
 */
OracleDML_OracleDMLKeys::identified_key_return
OracleDML_OracleDMLKeys::identified_key()
{
    OracleDML_OracleDMLKeys::identified_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_IDENTIFIED174 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_IDENTIFIED174_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1019:5: ( PLSQL_RESERVED_IDENTIFIED )
        // OracleDMLKeys.g:1019:10: PLSQL_RESERVED_IDENTIFIED
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_IDENTIFIED174 =  this->matchToken(PLSQL_RESERVED_IDENTIFIED, &FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key4668);
            if  (this->hasException())
            {
                goto ruleidentified_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_IDENTIFIED174_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_IDENTIFIED174));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_IDENTIFIED174_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleidentified_keyEx; /* Prevent compiler warnings */
    ruleidentified_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end identified_key */

/**
 * $ANTLR start none_key
 * OracleDMLKeys.g:1022:1: none_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::none_key_return
OracleDML_OracleDMLKeys::none_key()
{
    OracleDML_OracleDMLKeys::none_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID175 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID175_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1023:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1023:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "NONE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NONE\"" );
                    ex->set_ruleName( "none_key" );


            }

            REGULAR_ID175 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_none_key4691);
            if  (this->hasException())
            {
                goto rulenone_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID175_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID175));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID175_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenone_keyEx; /* Prevent compiler warnings */
    rulenone_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end none_key */

/**
 * $ANTLR start before_key
 * OracleDMLKeys.g:1026:1: before_key :{...}? => REGULAR_ID -> BEFORE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::before_key_return
OracleDML_OracleDMLKeys::before_key()
{
    OracleDML_OracleDMLKeys::before_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID176 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID176_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1027:5: ({...}? => REGULAR_ID -> BEFORE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1027:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BEFORE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BEFORE\"" );
                    ex->set_ruleName( "before_key" );


            }

            REGULAR_ID176 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_before_key4714);
            if  (this->hasException())
            {
                goto rulebefore_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID176);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1027:64: -> BEFORE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BEFORE_VK, REGULAR_ID176));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebefore_keyEx; /* Prevent compiler warnings */
    rulebefore_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end before_key */

/**
 * $ANTLR start referencing_key
 * OracleDMLKeys.g:1030:1: referencing_key :{...}? => REGULAR_ID -> REFERENCING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::referencing_key_return
OracleDML_OracleDMLKeys::referencing_key()
{
    OracleDML_OracleDMLKeys::referencing_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID177 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID177_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1031:5: ({...}? => REGULAR_ID -> REFERENCING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1031:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REFERENCING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REFERENCING\"" );
                    ex->set_ruleName( "referencing_key" );


            }

            REGULAR_ID177 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_referencing_key4743);
            if  (this->hasException())
            {
                goto rulereferencing_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID177);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1031:69: -> REFERENCING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REFERENCING_VK, REGULAR_ID177));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereferencing_keyEx; /* Prevent compiler warnings */
    rulereferencing_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end referencing_key */

/**
 * $ANTLR start logon_key
 * OracleDMLKeys.g:1034:1: logon_key :{...}? => REGULAR_ID -> LOGON_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::logon_key_return
OracleDML_OracleDMLKeys::logon_key()
{
    OracleDML_OracleDMLKeys::logon_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID178 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID178_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1035:5: ({...}? => REGULAR_ID -> LOGON_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1035:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LOGON")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LOGON\"" );
                    ex->set_ruleName( "logon_key" );


            }

            REGULAR_ID178 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_logon_key4771);
            if  (this->hasException())
            {
                goto rulelogon_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID178);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1035:63: -> LOGON_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LOGON_VK, REGULAR_ID178));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelogon_keyEx; /* Prevent compiler warnings */
    rulelogon_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end logon_key */

/**
 * $ANTLR start after_key
 * OracleDMLKeys.g:1038:1: after_key :{...}? => REGULAR_ID -> AFTER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::after_key_return
OracleDML_OracleDMLKeys::after_key()
{
    OracleDML_OracleDMLKeys::after_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID179 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID179_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1039:5: ({...}? => REGULAR_ID -> AFTER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1039:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AFTER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AFTER\"" );
                    ex->set_ruleName( "after_key" );


            }

            REGULAR_ID179 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_after_key4799);
            if  (this->hasException())
            {
                goto ruleafter_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID179);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1039:63: -> AFTER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AFTER_VK, REGULAR_ID179));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleafter_keyEx; /* Prevent compiler warnings */
    ruleafter_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end after_key */

/**
 * $ANTLR start schema_key
 * OracleDMLKeys.g:1042:1: schema_key :{...}? => REGULAR_ID -> SCHEMA_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::schema_key_return
OracleDML_OracleDMLKeys::schema_key()
{
    OracleDML_OracleDMLKeys::schema_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID180 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID180_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1043:5: ({...}? => REGULAR_ID -> SCHEMA_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1043:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SCHEMA")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SCHEMA\"" );
                    ex->set_ruleName( "schema_key" );


            }

            REGULAR_ID180 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_schema_key4827);
            if  (this->hasException())
            {
                goto ruleschema_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID180);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1043:64: -> SCHEMA_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SCHEMA_VK, REGULAR_ID180));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleschema_keyEx; /* Prevent compiler warnings */
    ruleschema_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end schema_key */

/**
 * $ANTLR start grant_key
 * OracleDMLKeys.g:1046:1: grant_key : SQL92_RESERVED_GRANT ;
 */
OracleDML_OracleDMLKeys::grant_key_return
OracleDML_OracleDMLKeys::grant_key()
{
    OracleDML_OracleDMLKeys::grant_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_GRANT181 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_GRANT181_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1047:5: ( SQL92_RESERVED_GRANT )
        // OracleDMLKeys.g:1047:10: SQL92_RESERVED_GRANT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_GRANT181 =  this->matchToken(SQL92_RESERVED_GRANT, &FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4852);
            if  (this->hasException())
            {
                goto rulegrant_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_GRANT181_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_GRANT181));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_GRANT181_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegrant_keyEx; /* Prevent compiler warnings */
    rulegrant_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end grant_key */

/**
 * $ANTLR start truncate_key
 * OracleDMLKeys.g:1050:1: truncate_key :{...}? => REGULAR_ID -> TRUNCATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::truncate_key_return
OracleDML_OracleDMLKeys::truncate_key()
{
    OracleDML_OracleDMLKeys::truncate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID182 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID182_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1051:5: ({...}? => REGULAR_ID -> TRUNCATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1051:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TRUNCATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TRUNCATE\"" );
                    ex->set_ruleName( "truncate_key" );


            }

            REGULAR_ID182 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_truncate_key4875);
            if  (this->hasException())
            {
                goto ruletruncate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID182);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1051:66: -> TRUNCATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TRUNCATE_VK, REGULAR_ID182));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletruncate_keyEx; /* Prevent compiler warnings */
    ruletruncate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end truncate_key */

/**
 * $ANTLR start startup_key
 * OracleDMLKeys.g:1054:1: startup_key :{...}? => REGULAR_ID -> STARTUP_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::startup_key_return
OracleDML_OracleDMLKeys::startup_key()
{
    OracleDML_OracleDMLKeys::startup_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID183 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID183_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1055:5: ({...}? => REGULAR_ID -> STARTUP_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1055:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "STARTUP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STARTUP\"" );
                    ex->set_ruleName( "startup_key" );


            }

            REGULAR_ID183 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_startup_key4903);
            if  (this->hasException())
            {
                goto rulestartup_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID183);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1055:65: -> STARTUP_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(STARTUP_VK, REGULAR_ID183));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestartup_keyEx; /* Prevent compiler warnings */
    rulestartup_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end startup_key */

/**
 * $ANTLR start statistics_key
 * OracleDMLKeys.g:1058:1: statistics_key :{...}? => REGULAR_ID -> STATISTICS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::statistics_key_return
OracleDML_OracleDMLKeys::statistics_key()
{
    OracleDML_OracleDMLKeys::statistics_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID184 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID184_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1059:5: ({...}? => REGULAR_ID -> STATISTICS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1059:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "STATISTICS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STATISTICS\"" );
                    ex->set_ruleName( "statistics_key" );


            }

            REGULAR_ID184 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statistics_key4931);
            if  (this->hasException())
            {
                goto rulestatistics_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID184);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1059:68: -> STATISTICS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(STATISTICS_VK, REGULAR_ID184));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestatistics_keyEx; /* Prevent compiler warnings */
    rulestatistics_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end statistics_key */

/**
 * $ANTLR start noaudit_key
 * OracleDMLKeys.g:1062:1: noaudit_key :{...}? => REGULAR_ID -> NOAUDIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::noaudit_key_return
OracleDML_OracleDMLKeys::noaudit_key()
{
    OracleDML_OracleDMLKeys::noaudit_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID185 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID185_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1063:5: ({...}? => REGULAR_ID -> NOAUDIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1063:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOAUDIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOAUDIT\"" );
                    ex->set_ruleName( "noaudit_key" );


            }

            REGULAR_ID185 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noaudit_key4959);
            if  (this->hasException())
            {
                goto rulenoaudit_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID185);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1063:65: -> NOAUDIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOAUDIT_VK, REGULAR_ID185));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenoaudit_keyEx; /* Prevent compiler warnings */
    rulenoaudit_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end noaudit_key */

/**
 * $ANTLR start suspend_key
 * OracleDMLKeys.g:1066:1: suspend_key :{...}? => REGULAR_ID -> SUSPEND_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::suspend_key_return
OracleDML_OracleDMLKeys::suspend_key()
{
    OracleDML_OracleDMLKeys::suspend_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID186 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID186_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1067:5: ({...}? => REGULAR_ID -> SUSPEND_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1067:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SUSPEND")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUSPEND\"" );
                    ex->set_ruleName( "suspend_key" );


            }

            REGULAR_ID186 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_suspend_key4987);
            if  (this->hasException())
            {
                goto rulesuspend_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID186);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1067:65: -> SUSPEND_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SUSPEND_VK, REGULAR_ID186));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesuspend_keyEx; /* Prevent compiler warnings */
    rulesuspend_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end suspend_key */

/**
 * $ANTLR start audit_key
 * OracleDMLKeys.g:1070:1: audit_key :{...}? => REGULAR_ID -> AUDIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::audit_key_return
OracleDML_OracleDMLKeys::audit_key()
{
    OracleDML_OracleDMLKeys::audit_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID187 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID187_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1071:5: ({...}? => REGULAR_ID -> AUDIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1071:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AUDIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AUDIT\"" );
                    ex->set_ruleName( "audit_key" );


            }

            REGULAR_ID187 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_audit_key5015);
            if  (this->hasException())
            {
                goto ruleaudit_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID187);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1071:63: -> AUDIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AUDIT_VK, REGULAR_ID187));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleaudit_keyEx; /* Prevent compiler warnings */
    ruleaudit_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end audit_key */

/**
 * $ANTLR start disassociate_key
 * OracleDMLKeys.g:1074:1: disassociate_key :{...}? => REGULAR_ID -> DISASSOCIATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::disassociate_key_return
OracleDML_OracleDMLKeys::disassociate_key()
{
    OracleDML_OracleDMLKeys::disassociate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID188 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID188_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1075:5: ({...}? => REGULAR_ID -> DISASSOCIATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1075:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DISASSOCIATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DISASSOCIATE\"" );
                    ex->set_ruleName( "disassociate_key" );


            }

            REGULAR_ID188 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_disassociate_key5043);
            if  (this->hasException())
            {
                goto ruledisassociate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID188);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1075:70: -> DISASSOCIATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DISASSOCIATE_VK, REGULAR_ID188));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledisassociate_keyEx; /* Prevent compiler warnings */
    ruledisassociate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end disassociate_key */

/**
 * $ANTLR start shutdown_key
 * OracleDMLKeys.g:1078:1: shutdown_key :{...}? => REGULAR_ID -> SHUTDOWN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::shutdown_key_return
OracleDML_OracleDMLKeys::shutdown_key()
{
    OracleDML_OracleDMLKeys::shutdown_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID189 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID189_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1079:5: ({...}? => REGULAR_ID -> SHUTDOWN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1079:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SHUTDOWN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SHUTDOWN\"" );
                    ex->set_ruleName( "shutdown_key" );


            }

            REGULAR_ID189 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_shutdown_key5072);
            if  (this->hasException())
            {
                goto ruleshutdown_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID189);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1079:66: -> SHUTDOWN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SHUTDOWN_VK, REGULAR_ID189));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleshutdown_keyEx; /* Prevent compiler warnings */
    ruleshutdown_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end shutdown_key */

/**
 * $ANTLR start compound_key
 * OracleDMLKeys.g:1082:1: compound_key :{...}? => REGULAR_ID -> COMPOUND_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::compound_key_return
OracleDML_OracleDMLKeys::compound_key()
{
    OracleDML_OracleDMLKeys::compound_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID190 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID190_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1083:5: ({...}? => REGULAR_ID -> COMPOUND_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1083:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COMPOUND")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COMPOUND\"" );
                    ex->set_ruleName( "compound_key" );


            }

            REGULAR_ID190 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compound_key5100);
            if  (this->hasException())
            {
                goto rulecompound_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID190);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1083:66: -> COMPOUND_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COMPOUND_VK, REGULAR_ID190));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecompound_keyEx; /* Prevent compiler warnings */
    rulecompound_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end compound_key */

/**
 * $ANTLR start servererror_key
 * OracleDMLKeys.g:1086:1: servererror_key :{...}? => REGULAR_ID -> SERVERERROR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::servererror_key_return
OracleDML_OracleDMLKeys::servererror_key()
{
    OracleDML_OracleDMLKeys::servererror_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID191 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID191_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1087:5: ({...}? => REGULAR_ID -> SERVERERROR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1087:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SERVERERROR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SERVERERROR\"" );
                    ex->set_ruleName( "servererror_key" );


            }

            REGULAR_ID191 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_servererror_key5128);
            if  (this->hasException())
            {
                goto ruleservererror_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID191);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1087:69: -> SERVERERROR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SERVERERROR_VK, REGULAR_ID191));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleservererror_keyEx; /* Prevent compiler warnings */
    ruleservererror_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end servererror_key */

/**
 * $ANTLR start parent_key
 * OracleDMLKeys.g:1090:1: parent_key :{...}? => REGULAR_ID -> PARENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::parent_key_return
OracleDML_OracleDMLKeys::parent_key()
{
    OracleDML_OracleDMLKeys::parent_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID192 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID192_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1091:5: ({...}? => REGULAR_ID -> PARENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1091:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PARENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PARENT\"" );
                    ex->set_ruleName( "parent_key" );


            }

            REGULAR_ID192 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parent_key5156);
            if  (this->hasException())
            {
                goto ruleparent_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID192);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1091:64: -> PARENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PARENT_VK, REGULAR_ID192));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleparent_keyEx; /* Prevent compiler warnings */
    ruleparent_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end parent_key */

/**
 * $ANTLR start follows_key
 * OracleDMLKeys.g:1094:1: follows_key :{...}? => REGULAR_ID -> FOLLOWS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::follows_key_return
OracleDML_OracleDMLKeys::follows_key()
{
    OracleDML_OracleDMLKeys::follows_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID193 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID193_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1095:5: ({...}? => REGULAR_ID -> FOLLOWS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1095:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FOLLOWS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FOLLOWS\"" );
                    ex->set_ruleName( "follows_key" );


            }

            REGULAR_ID193 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_follows_key5184);
            if  (this->hasException())
            {
                goto rulefollows_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID193);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1095:65: -> FOLLOWS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FOLLOWS_VK, REGULAR_ID193));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefollows_keyEx; /* Prevent compiler warnings */
    rulefollows_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end follows_key */

/**
 * $ANTLR start nested_key
 * OracleDMLKeys.g:1098:1: nested_key :{...}? => REGULAR_ID -> NESTED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nested_key_return
OracleDML_OracleDMLKeys::nested_key()
{
    OracleDML_OracleDMLKeys::nested_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID194 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID194_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1099:5: ({...}? => REGULAR_ID -> NESTED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1099:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NESTED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NESTED\"" );
                    ex->set_ruleName( "nested_key" );


            }

            REGULAR_ID194 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nested_key5212);
            if  (this->hasException())
            {
                goto rulenested_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID194);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1099:64: -> NESTED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NESTED_VK, REGULAR_ID194));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenested_keyEx; /* Prevent compiler warnings */
    rulenested_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nested_key */

/**
 * $ANTLR start old_key
 * OracleDMLKeys.g:1102:1: old_key :{...}? => REGULAR_ID -> OLD_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::old_key_return
OracleDML_OracleDMLKeys::old_key()
{
    OracleDML_OracleDMLKeys::old_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID195 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID195_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1103:5: ({...}? => REGULAR_ID -> OLD_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1103:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "OLD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OLD\"" );
                    ex->set_ruleName( "old_key" );


            }

            REGULAR_ID195 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_old_key5240);
            if  (this->hasException())
            {
                goto ruleold_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID195);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1103:61: -> OLD_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(OLD_VK, REGULAR_ID195));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleold_keyEx; /* Prevent compiler warnings */
    ruleold_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end old_key */

/**
 * $ANTLR start statement_key
 * OracleDMLKeys.g:1106:1: statement_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::statement_key_return
OracleDML_OracleDMLKeys::statement_key()
{
    OracleDML_OracleDMLKeys::statement_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID196 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID196_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1107:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1107:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "STATEMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STATEMENT\"" );
                    ex->set_ruleName( "statement_key" );


            }

            REGULAR_ID196 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statement_key5268);
            if  (this->hasException())
            {
                goto rulestatement_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID196_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID196));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID196_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestatement_keyEx; /* Prevent compiler warnings */
    rulestatement_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end statement_key */

/**
 * $ANTLR start db_role_change_key
 * OracleDMLKeys.g:1110:1: db_role_change_key :{...}? => REGULAR_ID -> DB_ROLE_CHANGE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::db_role_change_key_return
OracleDML_OracleDMLKeys::db_role_change_key()
{
    OracleDML_OracleDMLKeys::db_role_change_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID197 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID197_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1111:5: ({...}? => REGULAR_ID -> DB_ROLE_CHANGE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1111:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DB_ROLE_CHANGE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DB_ROLE_CHANGE\"" );
                    ex->set_ruleName( "db_role_change_key" );


            }

            REGULAR_ID197 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_db_role_change_key5291);
            if  (this->hasException())
            {
                goto ruledb_role_change_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID197);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1111:72: -> DB_ROLE_CHANGE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DB_ROLE_CHANGE_VK, REGULAR_ID197));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledb_role_change_keyEx; /* Prevent compiler warnings */
    ruledb_role_change_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end db_role_change_key */

/**
 * $ANTLR start each_key
 * OracleDMLKeys.g:1114:1: each_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::each_key_return
OracleDML_OracleDMLKeys::each_key()
{
    OracleDML_OracleDMLKeys::each_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID198 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID198_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1115:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1115:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "EACH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EACH\"" );
                    ex->set_ruleName( "each_key" );


            }

            REGULAR_ID198 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_each_key5319);
            if  (this->hasException())
            {
                goto ruleeach_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID198_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID198));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID198_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleeach_keyEx; /* Prevent compiler warnings */
    ruleeach_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end each_key */

/**
 * $ANTLR start logoff_key
 * OracleDMLKeys.g:1118:1: logoff_key :{...}? => REGULAR_ID -> LOGOFF_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::logoff_key_return
OracleDML_OracleDMLKeys::logoff_key()
{
    OracleDML_OracleDMLKeys::logoff_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID199 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID199_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1119:5: ({...}? => REGULAR_ID -> LOGOFF_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1119:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LOGOFF")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LOGOFF\"" );
                    ex->set_ruleName( "logoff_key" );


            }

            REGULAR_ID199 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_logoff_key5342);
            if  (this->hasException())
            {
                goto rulelogoff_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID199);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1119:64: -> LOGOFF_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LOGOFF_VK, REGULAR_ID199));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelogoff_keyEx; /* Prevent compiler warnings */
    rulelogoff_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end logoff_key */

/**
 * $ANTLR start analyze_key
 * OracleDMLKeys.g:1122:1: analyze_key :{...}? => REGULAR_ID -> ANALYZE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::analyze_key_return
OracleDML_OracleDMLKeys::analyze_key()
{
    OracleDML_OracleDMLKeys::analyze_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID200 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID200_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1123:5: ({...}? => REGULAR_ID -> ANALYZE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1123:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ANALYZE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ANALYZE\"" );
                    ex->set_ruleName( "analyze_key" );


            }

            REGULAR_ID200 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_analyze_key5370);
            if  (this->hasException())
            {
                goto ruleanalyze_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID200);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1123:65: -> ANALYZE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ANALYZE_VK, REGULAR_ID200));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleanalyze_keyEx; /* Prevent compiler warnings */
    ruleanalyze_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end analyze_key */

/**
 * $ANTLR start instead_key
 * OracleDMLKeys.g:1126:1: instead_key :{...}? => REGULAR_ID -> INSTEAD_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::instead_key_return
OracleDML_OracleDMLKeys::instead_key()
{
    OracleDML_OracleDMLKeys::instead_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID201 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID201_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1127:5: ({...}? => REGULAR_ID -> INSTEAD_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1127:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INSTEAD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INSTEAD\"" );
                    ex->set_ruleName( "instead_key" );


            }

            REGULAR_ID201 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instead_key5398);
            if  (this->hasException())
            {
                goto ruleinstead_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID201);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1127:65: -> INSTEAD_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INSTEAD_VK, REGULAR_ID201));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinstead_keyEx; /* Prevent compiler warnings */
    ruleinstead_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end instead_key */

/**
 * $ANTLR start associate_key
 * OracleDMLKeys.g:1130:1: associate_key :{...}? => REGULAR_ID -> ASSOCIATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::associate_key_return
OracleDML_OracleDMLKeys::associate_key()
{
    OracleDML_OracleDMLKeys::associate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID202 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID202_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1131:5: ({...}? => REGULAR_ID -> ASSOCIATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1131:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ASSOCIATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ASSOCIATE\"" );
                    ex->set_ruleName( "associate_key" );


            }

            REGULAR_ID202 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_associate_key5426);
            if  (this->hasException())
            {
                goto ruleassociate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID202);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1131:67: -> ASSOCIATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ASSOCIATE_VK, REGULAR_ID202));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleassociate_keyEx; /* Prevent compiler warnings */
    ruleassociate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end associate_key */

/**
 * $ANTLR start new_key
 * OracleDMLKeys.g:1134:1: new_key :{...}? => REGULAR_ID -> NEW_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::new_key_return
OracleDML_OracleDMLKeys::new_key()
{
    OracleDML_OracleDMLKeys::new_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID203 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID203_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1135:5: ({...}? => REGULAR_ID -> NEW_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1135:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NEW")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NEW\"" );
                    ex->set_ruleName( "new_key" );


            }

            REGULAR_ID203 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_new_key5454);
            if  (this->hasException())
            {
                goto rulenew_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID203);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1135:61: -> NEW_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NEW_VK, REGULAR_ID203));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenew_keyEx; /* Prevent compiler warnings */
    rulenew_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end new_key */

/**
 * $ANTLR start revoke_key
 * OracleDMLKeys.g:1138:1: revoke_key : SQL92_RESERVED_REVOKE ;
 */
OracleDML_OracleDMLKeys::revoke_key_return
OracleDML_OracleDMLKeys::revoke_key()
{
    OracleDML_OracleDMLKeys::revoke_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_REVOKE204 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_REVOKE204_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1139:5: ( SQL92_RESERVED_REVOKE )
        // OracleDMLKeys.g:1139:10: SQL92_RESERVED_REVOKE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_REVOKE204 =  this->matchToken(SQL92_RESERVED_REVOKE, &FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key5479);
            if  (this->hasException())
            {
                goto rulerevoke_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_REVOKE204_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_REVOKE204));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_REVOKE204_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerevoke_keyEx; /* Prevent compiler warnings */
    rulerevoke_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end revoke_key */

/**
 * $ANTLR start rename_key
 * OracleDMLKeys.g:1142:1: rename_key :{...}? => REGULAR_ID -> RENAME_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::rename_key_return
OracleDML_OracleDMLKeys::rename_key()
{
    OracleDML_OracleDMLKeys::rename_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID205 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID205_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1143:5: ({...}? => REGULAR_ID -> RENAME_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1143:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RENAME")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RENAME\"" );
                    ex->set_ruleName( "rename_key" );


            }

            REGULAR_ID205 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rename_key5502);
            if  (this->hasException())
            {
                goto rulerename_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID205);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1143:64: -> RENAME_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RENAME_VK, REGULAR_ID205));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerename_keyEx; /* Prevent compiler warnings */
    rulerename_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rename_key */

/**
 * $ANTLR start customdatum_key
 * OracleDMLKeys.g:1146:1: customdatum_key :{...}? => REGULAR_ID -> CUSTOMDATUM_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::customdatum_key_return
OracleDML_OracleDMLKeys::customdatum_key()
{
    OracleDML_OracleDMLKeys::customdatum_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID206 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID206_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1147:5: ({...}? => REGULAR_ID -> CUSTOMDATUM_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1147:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CUSTOMDATUM")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CUSTOMDATUM\"" );
                    ex->set_ruleName( "customdatum_key" );


            }

            REGULAR_ID206 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_customdatum_key5531);
            if  (this->hasException())
            {
                goto rulecustomdatum_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID206);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1147:69: -> CUSTOMDATUM_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CUSTOMDATUM_VK, REGULAR_ID206));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecustomdatum_keyEx; /* Prevent compiler warnings */
    rulecustomdatum_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end customdatum_key */

/**
 * $ANTLR start oradata_key
 * OracleDMLKeys.g:1150:1: oradata_key :{...}? => REGULAR_ID -> ORADATA_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::oradata_key_return
OracleDML_OracleDMLKeys::oradata_key()
{
    OracleDML_OracleDMLKeys::oradata_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID207 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID207_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1151:5: ({...}? => REGULAR_ID -> ORADATA_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1151:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ORADATA")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ORADATA\"" );
                    ex->set_ruleName( "oradata_key" );


            }

            REGULAR_ID207 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oradata_key5559);
            if  (this->hasException())
            {
                goto ruleoradata_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID207);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1151:65: -> ORADATA_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ORADATA_VK, REGULAR_ID207));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleoradata_keyEx; /* Prevent compiler warnings */
    ruleoradata_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end oradata_key */

/**
 * $ANTLR start constructor_key
 * OracleDMLKeys.g:1154:1: constructor_key :{...}? => REGULAR_ID -> CONSTRUCTOR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::constructor_key_return
OracleDML_OracleDMLKeys::constructor_key()
{
    OracleDML_OracleDMLKeys::constructor_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID208 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID208_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1155:5: ({...}? => REGULAR_ID -> CONSTRUCTOR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1155:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CONSTRUCTOR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONSTRUCTOR\"" );
                    ex->set_ruleName( "constructor_key" );


            }

            REGULAR_ID208 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constructor_key5587);
            if  (this->hasException())
            {
                goto ruleconstructor_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID208);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1155:69: -> CONSTRUCTOR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CONSTRUCTOR_VK, REGULAR_ID208));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconstructor_keyEx; /* Prevent compiler warnings */
    ruleconstructor_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end constructor_key */

/**
 * $ANTLR start sqldata_key
 * OracleDMLKeys.g:1158:1: sqldata_key :{...}? => REGULAR_ID -> SQLDATA_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::sqldata_key_return
OracleDML_OracleDMLKeys::sqldata_key()
{
    OracleDML_OracleDMLKeys::sqldata_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID209 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID209_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1159:5: ({...}? => REGULAR_ID -> SQLDATA_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1159:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SQLDATA")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SQLDATA\"" );
                    ex->set_ruleName( "sqldata_key" );


            }

            REGULAR_ID209 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqldata_key5615);
            if  (this->hasException())
            {
                goto rulesqldata_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID209);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1159:65: -> SQLDATA_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SQLDATA_VK, REGULAR_ID209));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesqldata_keyEx; /* Prevent compiler warnings */
    rulesqldata_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sqldata_key */

/**
 * $ANTLR start member_key
 * OracleDMLKeys.g:1162:1: member_key :{...}? => REGULAR_ID -> MEMBER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::member_key_return
OracleDML_OracleDMLKeys::member_key()
{
    OracleDML_OracleDMLKeys::member_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID210 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID210_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1163:5: ({...}? => REGULAR_ID -> MEMBER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1163:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MEMBER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MEMBER\"" );
                    ex->set_ruleName( "member_key" );


            }

            REGULAR_ID210 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_member_key5643);
            if  (this->hasException())
            {
                goto rulemember_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID210);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1163:64: -> MEMBER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MEMBER_VK, REGULAR_ID210));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemember_keyEx; /* Prevent compiler warnings */
    rulemember_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end member_key */

/**
 * $ANTLR start self_key
 * OracleDMLKeys.g:1166:1: self_key :{...}? => REGULAR_ID -> SELF_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::self_key_return
OracleDML_OracleDMLKeys::self_key()
{
    OracleDML_OracleDMLKeys::self_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID211 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID211_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1167:5: ({...}? => REGULAR_ID -> SELF_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1167:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SELF")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SELF\"" );
                    ex->set_ruleName( "self_key" );


            }

            REGULAR_ID211 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_self_key5671);
            if  (this->hasException())
            {
                goto ruleself_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID211);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1167:62: -> SELF_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SELF_VK, REGULAR_ID211));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleself_keyEx; /* Prevent compiler warnings */
    ruleself_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end self_key */

/**
 * $ANTLR start object_key
 * OracleDMLKeys.g:1170:1: object_key :{...}? => REGULAR_ID -> OBJECT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::object_key_return
OracleDML_OracleDMLKeys::object_key()
{
    OracleDML_OracleDMLKeys::object_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID212 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID212_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1171:5: ({...}? => REGULAR_ID -> OBJECT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1171:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "OBJECT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OBJECT\"" );
                    ex->set_ruleName( "object_key" );


            }

            REGULAR_ID212 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_object_key5699);
            if  (this->hasException())
            {
                goto ruleobject_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID212);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1171:64: -> OBJECT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(OBJECT_VK, REGULAR_ID212));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleobject_keyEx; /* Prevent compiler warnings */
    ruleobject_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end object_key */

/**
 * $ANTLR start variable_key
 * OracleDMLKeys.g:1174:1: variable_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::variable_key_return
OracleDML_OracleDMLKeys::variable_key()
{
    OracleDML_OracleDMLKeys::variable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID213 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID213_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1175:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1175:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "VARIABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VARIABLE\"" );
                    ex->set_ruleName( "variable_key" );


            }

            REGULAR_ID213 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_variable_key5727);
            if  (this->hasException())
            {
                goto rulevariable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID213_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID213));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID213_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevariable_keyEx; /* Prevent compiler warnings */
    rulevariable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end variable_key */

/**
 * $ANTLR start instantiable_key
 * OracleDMLKeys.g:1178:1: instantiable_key :{...}? => REGULAR_ID -> INSTANTIABLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::instantiable_key_return
OracleDML_OracleDMLKeys::instantiable_key()
{
    OracleDML_OracleDMLKeys::instantiable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID214 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID214_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1179:5: ({...}? => REGULAR_ID -> INSTANTIABLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1179:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INSTANTIABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INSTANTIABLE\"" );
                    ex->set_ruleName( "instantiable_key" );


            }

            REGULAR_ID214 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instantiable_key5750);
            if  (this->hasException())
            {
                goto ruleinstantiable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID214);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1179:70: -> INSTANTIABLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INSTANTIABLE_VK, REGULAR_ID214));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinstantiable_keyEx; /* Prevent compiler warnings */
    ruleinstantiable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end instantiable_key */

/**
 * $ANTLR start final_key
 * OracleDMLKeys.g:1182:1: final_key :{...}? => REGULAR_ID -> FINAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::final_key_return
OracleDML_OracleDMLKeys::final_key()
{
    OracleDML_OracleDMLKeys::final_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID215 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID215_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1183:5: ({...}? => REGULAR_ID -> FINAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1183:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FINAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FINAL\"" );
                    ex->set_ruleName( "final_key" );


            }

            REGULAR_ID215 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_final_key5778);
            if  (this->hasException())
            {
                goto rulefinal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID215);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1183:63: -> FINAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FINAL_VK, REGULAR_ID215));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefinal_keyEx; /* Prevent compiler warnings */
    rulefinal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end final_key */

/**
 * $ANTLR start static_key
 * OracleDMLKeys.g:1186:1: static_key :{...}? => REGULAR_ID -> STATIC_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::static_key_return
OracleDML_OracleDMLKeys::static_key()
{
    OracleDML_OracleDMLKeys::static_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID216 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID216_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1187:5: ({...}? => REGULAR_ID -> STATIC_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1187:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "STATIC")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STATIC\"" );
                    ex->set_ruleName( "static_key" );


            }

            REGULAR_ID216 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_static_key5806);
            if  (this->hasException())
            {
                goto rulestatic_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID216);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1187:64: -> STATIC_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(STATIC_VK, REGULAR_ID216));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestatic_keyEx; /* Prevent compiler warnings */
    rulestatic_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end static_key */

/**
 * $ANTLR start oid_key
 * OracleDMLKeys.g:1190:1: oid_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::oid_key_return
OracleDML_OracleDMLKeys::oid_key()
{
    OracleDML_OracleDMLKeys::oid_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID217 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID217_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1191:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1191:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "OID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OID\"" );
                    ex->set_ruleName( "oid_key" );


            }

            REGULAR_ID217 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oid_key5834);
            if  (this->hasException())
            {
                goto ruleoid_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID217_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID217));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID217_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleoid_keyEx; /* Prevent compiler warnings */
    ruleoid_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end oid_key */

/**
 * $ANTLR start result_key
 * OracleDMLKeys.g:1194:1: result_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::result_key_return
OracleDML_OracleDMLKeys::result_key()
{
    OracleDML_OracleDMLKeys::result_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID218 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID218_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1195:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1195:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "RESULT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RESULT\"" );
                    ex->set_ruleName( "result_key" );


            }

            REGULAR_ID218 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_result_key5857);
            if  (this->hasException())
            {
                goto ruleresult_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID218_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID218));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID218_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleresult_keyEx; /* Prevent compiler warnings */
    ruleresult_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end result_key */

/**
 * $ANTLR start under_key
 * OracleDMLKeys.g:1198:1: under_key :{...}? => REGULAR_ID -> UNDER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::under_key_return
OracleDML_OracleDMLKeys::under_key()
{
    OracleDML_OracleDMLKeys::under_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID219 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID219_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1199:5: ({...}? => REGULAR_ID -> UNDER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1199:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "UNDER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UNDER\"" );
                    ex->set_ruleName( "under_key" );


            }

            REGULAR_ID219 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_under_key5880);
            if  (this->hasException())
            {
                goto ruleunder_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID219);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1199:63: -> UNDER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(UNDER_VK, REGULAR_ID219));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunder_keyEx; /* Prevent compiler warnings */
    ruleunder_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end under_key */

/**
 * $ANTLR start map_key
 * OracleDMLKeys.g:1202:1: map_key :{...}? => REGULAR_ID -> MAP_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::map_key_return
OracleDML_OracleDMLKeys::map_key()
{
    OracleDML_OracleDMLKeys::map_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID220 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID220_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1203:5: ({...}? => REGULAR_ID -> MAP_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1203:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MAP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MAP\"" );
                    ex->set_ruleName( "map_key" );


            }

            REGULAR_ID220 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_map_key5908);
            if  (this->hasException())
            {
                goto rulemap_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID220);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1203:61: -> MAP_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MAP_VK, REGULAR_ID220));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemap_keyEx; /* Prevent compiler warnings */
    rulemap_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end map_key */

/**
 * $ANTLR start overriding_key
 * OracleDMLKeys.g:1206:1: overriding_key :{...}? => REGULAR_ID -> OVERRIDING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::overriding_key_return
OracleDML_OracleDMLKeys::overriding_key()
{
    OracleDML_OracleDMLKeys::overriding_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID221 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID221_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1207:5: ({...}? => REGULAR_ID -> OVERRIDING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1207:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "OVERRIDING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OVERRIDING\"" );
                    ex->set_ruleName( "overriding_key" );


            }

            REGULAR_ID221 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_overriding_key5936);
            if  (this->hasException())
            {
                goto ruleoverriding_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID221);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1207:68: -> OVERRIDING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(OVERRIDING_VK, REGULAR_ID221));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleoverriding_keyEx; /* Prevent compiler warnings */
    ruleoverriding_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end overriding_key */

/**
 * $ANTLR start add_key
 * OracleDMLKeys.g:1210:1: add_key :{...}? => REGULAR_ID -> ADD_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::add_key_return
OracleDML_OracleDMLKeys::add_key()
{
    OracleDML_OracleDMLKeys::add_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID222 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID222_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1211:5: ({...}? => REGULAR_ID -> ADD_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1211:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ADD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ADD\"" );
                    ex->set_ruleName( "add_key" );


            }

            REGULAR_ID222 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_add_key5964);
            if  (this->hasException())
            {
                goto ruleadd_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID222);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1211:61: -> ADD_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ADD_VK, REGULAR_ID222));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleadd_keyEx; /* Prevent compiler warnings */
    ruleadd_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end add_key */

/**
 * $ANTLR start modify_key
 * OracleDMLKeys.g:1214:1: modify_key :{...}? => REGULAR_ID -> MODIFY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::modify_key_return
OracleDML_OracleDMLKeys::modify_key()
{
    OracleDML_OracleDMLKeys::modify_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID223 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID223_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1215:5: ({...}? => REGULAR_ID -> MODIFY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1215:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MODIFY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MODIFY\"" );
                    ex->set_ruleName( "modify_key" );


            }

            REGULAR_ID223 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_modify_key5992);
            if  (this->hasException())
            {
                goto rulemodify_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID223);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1215:64: -> MODIFY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MODIFY_VK, REGULAR_ID223));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodify_keyEx; /* Prevent compiler warnings */
    rulemodify_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end modify_key */

/**
 * $ANTLR start including_key
 * OracleDMLKeys.g:1218:1: including_key :{...}? => REGULAR_ID -> INCLUDING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::including_key_return
OracleDML_OracleDMLKeys::including_key()
{
    OracleDML_OracleDMLKeys::including_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID224 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID224_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1219:5: ({...}? => REGULAR_ID -> INCLUDING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1219:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INCLUDING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INCLUDING\"" );
                    ex->set_ruleName( "including_key" );


            }

            REGULAR_ID224 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_including_key6020);
            if  (this->hasException())
            {
                goto ruleincluding_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID224);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1219:67: -> INCLUDING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INCLUDING_VK, REGULAR_ID224));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleincluding_keyEx; /* Prevent compiler warnings */
    ruleincluding_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end including_key */

/**
 * $ANTLR start substitutable_key
 * OracleDMLKeys.g:1222:1: substitutable_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::substitutable_key_return
OracleDML_OracleDMLKeys::substitutable_key()
{
    OracleDML_OracleDMLKeys::substitutable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID225 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID225_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1223:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1223:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SUBSTITUTABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUBSTITUTABLE\"" );
                    ex->set_ruleName( "substitutable_key" );


            }

            REGULAR_ID225 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substitutable_key6048);
            if  (this->hasException())
            {
                goto rulesubstitutable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID225_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID225));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID225_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubstitutable_keyEx; /* Prevent compiler warnings */
    rulesubstitutable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end substitutable_key */

/**
 * $ANTLR start attribute_key
 * OracleDMLKeys.g:1226:1: attribute_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::attribute_key_return
OracleDML_OracleDMLKeys::attribute_key()
{
    OracleDML_OracleDMLKeys::attribute_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID226 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID226_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1227:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1227:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ATTRIBUTE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ATTRIBUTE\"" );
                    ex->set_ruleName( "attribute_key" );


            }

            REGULAR_ID226 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_attribute_key6071);
            if  (this->hasException())
            {
                goto ruleattribute_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID226_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID226));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID226_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleattribute_keyEx; /* Prevent compiler warnings */
    ruleattribute_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end attribute_key */

/**
 * $ANTLR start cascade_key
 * OracleDMLKeys.g:1230:1: cascade_key :{...}? => REGULAR_ID -> CASCADE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::cascade_key_return
OracleDML_OracleDMLKeys::cascade_key()
{
    OracleDML_OracleDMLKeys::cascade_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID227 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID227_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1231:5: ({...}? => REGULAR_ID -> CASCADE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1231:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CASCADE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CASCADE\"" );
                    ex->set_ruleName( "cascade_key" );


            }

            REGULAR_ID227 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cascade_key6094);
            if  (this->hasException())
            {
                goto rulecascade_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID227);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1231:65: -> CASCADE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CASCADE_VK, REGULAR_ID227));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecascade_keyEx; /* Prevent compiler warnings */
    rulecascade_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cascade_key */

/**
 * $ANTLR start data_key
 * OracleDMLKeys.g:1234:1: data_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::data_key_return
OracleDML_OracleDMLKeys::data_key()
{
    OracleDML_OracleDMLKeys::data_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID228 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID228_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1235:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1235:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "DATA")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DATA\"" );
                    ex->set_ruleName( "data_key" );


            }

            REGULAR_ID228 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_data_key6123);
            if  (this->hasException())
            {
                goto ruledata_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID228_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID228));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID228_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledata_keyEx; /* Prevent compiler warnings */
    ruledata_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end data_key */

/**
 * $ANTLR start invalidate_key
 * OracleDMLKeys.g:1238:1: invalidate_key :{...}? => REGULAR_ID -> INVALIDATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::invalidate_key_return
OracleDML_OracleDMLKeys::invalidate_key()
{
    OracleDML_OracleDMLKeys::invalidate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID229 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID229_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1239:5: ({...}? => REGULAR_ID -> INVALIDATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1239:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INVALIDATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INVALIDATE\"" );
                    ex->set_ruleName( "invalidate_key" );


            }

            REGULAR_ID229 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_invalidate_key6146);
            if  (this->hasException())
            {
                goto ruleinvalidate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID229);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1239:68: -> INVALIDATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INVALIDATE_VK, REGULAR_ID229));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinvalidate_keyEx; /* Prevent compiler warnings */
    ruleinvalidate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end invalidate_key */

/**
 * $ANTLR start element_key
 * OracleDMLKeys.g:1242:1: element_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::element_key_return
OracleDML_OracleDMLKeys::element_key()
{
    OracleDML_OracleDMLKeys::element_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID230 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID230_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1243:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1243:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ELEMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ELEMENT\"" );
                    ex->set_ruleName( "element_key" );


            }

            REGULAR_ID230 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_element_key6174);
            if  (this->hasException())
            {
                goto ruleelement_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID230_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID230));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID230_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleelement_keyEx; /* Prevent compiler warnings */
    ruleelement_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end element_key */

/**
 * $ANTLR start first_key
 * OracleDMLKeys.g:1246:1: first_key :{...}? => REGULAR_ID -> FIRST_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::first_key_return
OracleDML_OracleDMLKeys::first_key()
{
    OracleDML_OracleDMLKeys::first_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID231 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID231_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1247:5: ({...}? => REGULAR_ID -> FIRST_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1247:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FIRST")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FIRST\"" );
                    ex->set_ruleName( "first_key" );


            }

            REGULAR_ID231 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_first_key6197);
            if  (this->hasException())
            {
                goto rulefirst_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID231);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1247:63: -> FIRST_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FIRST_VK, REGULAR_ID231));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefirst_keyEx; /* Prevent compiler warnings */
    rulefirst_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end first_key */

/**
 * $ANTLR start check_key
 * OracleDMLKeys.g:1250:1: check_key : SQL92_RESERVED_CHECK ;
 */
OracleDML_OracleDMLKeys::check_key_return
OracleDML_OracleDMLKeys::check_key()
{
    OracleDML_OracleDMLKeys::check_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_CHECK232 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_CHECK232_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1251:5: ( SQL92_RESERVED_CHECK )
        // OracleDMLKeys.g:1251:10: SQL92_RESERVED_CHECK
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_CHECK232 =  this->matchToken(SQL92_RESERVED_CHECK, &FOLLOW_SQL92_RESERVED_CHECK_in_check_key6222);
            if  (this->hasException())
            {
                goto rulecheck_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_CHECK232_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_CHECK232));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_CHECK232_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecheck_keyEx; /* Prevent compiler warnings */
    rulecheck_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end check_key */

/**
 * $ANTLR start option_key
 * OracleDMLKeys.g:1254:1: option_key : SQL92_RESERVED_OPTION ;
 */
OracleDML_OracleDMLKeys::option_key_return
OracleDML_OracleDMLKeys::option_key()
{
    OracleDML_OracleDMLKeys::option_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_OPTION233 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_OPTION233_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1255:5: ( SQL92_RESERVED_OPTION )
        // OracleDMLKeys.g:1255:10: SQL92_RESERVED_OPTION
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_OPTION233 =  this->matchToken(SQL92_RESERVED_OPTION, &FOLLOW_SQL92_RESERVED_OPTION_in_option_key6242);
            if  (this->hasException())
            {
                goto ruleoption_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_OPTION233_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_OPTION233));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_OPTION233_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleoption_keyEx; /* Prevent compiler warnings */
    ruleoption_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end option_key */

/**
 * $ANTLR start nocycle_key
 * OracleDMLKeys.g:1258:1: nocycle_key :{...}? => REGULAR_ID -> NOCYCLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nocycle_key_return
OracleDML_OracleDMLKeys::nocycle_key()
{
    OracleDML_OracleDMLKeys::nocycle_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID234 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID234_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1259:5: ({...}? => REGULAR_ID -> NOCYCLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1259:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOCYCLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOCYCLE\"" );
                    ex->set_ruleName( "nocycle_key" );


            }

            REGULAR_ID234 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocycle_key6265);
            if  (this->hasException())
            {
                goto rulenocycle_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID234);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1259:65: -> NOCYCLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOCYCLE_VK, REGULAR_ID234));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenocycle_keyEx; /* Prevent compiler warnings */
    rulenocycle_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nocycle_key */

/**
 * $ANTLR start locked_key
 * OracleDMLKeys.g:1262:1: locked_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::locked_key_return
OracleDML_OracleDMLKeys::locked_key()
{
    OracleDML_OracleDMLKeys::locked_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID235 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID235_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1263:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1263:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LOCKED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LOCKED\"" );
                    ex->set_ruleName( "locked_key" );


            }

            REGULAR_ID235 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_locked_key6293);
            if  (this->hasException())
            {
                goto rulelocked_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID235_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID235));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID235_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelocked_keyEx; /* Prevent compiler warnings */
    rulelocked_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end locked_key */

/**
 * $ANTLR start block_key
 * OracleDMLKeys.g:1266:1: block_key :{...}? => REGULAR_ID -> BLOCK_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::block_key_return
OracleDML_OracleDMLKeys::block_key()
{
    OracleDML_OracleDMLKeys::block_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID236 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID236_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1267:5: ({...}? => REGULAR_ID -> BLOCK_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1267:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BLOCK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BLOCK\"" );
                    ex->set_ruleName( "block_key" );


            }

            REGULAR_ID236 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_block_key6316);
            if  (this->hasException())
            {
                goto ruleblock_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID236);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1267:63: -> BLOCK_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BLOCK_VK, REGULAR_ID236));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleblock_keyEx; /* Prevent compiler warnings */
    ruleblock_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end block_key */

/**
 * $ANTLR start xml_key
 * OracleDMLKeys.g:1270:1: xml_key :{...}? => REGULAR_ID -> XML_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xml_key_return
OracleDML_OracleDMLKeys::xml_key()
{
    OracleDML_OracleDMLKeys::xml_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID237 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID237_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1271:5: ({...}? => REGULAR_ID -> XML_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1271:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XML")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XML\"" );
                    ex->set_ruleName( "xml_key" );


            }

            REGULAR_ID237 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xml_key6344);
            if  (this->hasException())
            {
                goto rulexml_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID237);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1271:61: -> XML_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XML_VK, REGULAR_ID237));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_keyEx; /* Prevent compiler warnings */
    rulexml_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_key */

/**
 * $ANTLR start pivot_key
 * OracleDMLKeys.g:1274:1: pivot_key : PLSQL_NON_RESERVED_PIVOT ;
 */
OracleDML_OracleDMLKeys::pivot_key_return
OracleDML_OracleDMLKeys::pivot_key()
{
    OracleDML_OracleDMLKeys::pivot_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_PIVOT238 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_PIVOT238_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1276:5: ( PLSQL_NON_RESERVED_PIVOT )
        // OracleDMLKeys.g:1276:10: PLSQL_NON_RESERVED_PIVOT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_PIVOT238 =  this->matchToken(PLSQL_NON_RESERVED_PIVOT, &FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key6370);
            if  (this->hasException())
            {
                goto rulepivot_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_PIVOT238_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_PIVOT238));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_PIVOT238_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepivot_keyEx; /* Prevent compiler warnings */
    rulepivot_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pivot_key */

/**
 * $ANTLR start prior_key
 * OracleDMLKeys.g:1279:1: prior_key : SQL92_RESERVED_PRIOR ;
 */
OracleDML_OracleDMLKeys::prior_key_return
OracleDML_OracleDMLKeys::prior_key()
{
    OracleDML_OracleDMLKeys::prior_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_PRIOR239 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_PRIOR239_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1280:5: ( SQL92_RESERVED_PRIOR )
        // OracleDMLKeys.g:1280:10: SQL92_RESERVED_PRIOR
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_PRIOR239 =  this->matchToken(SQL92_RESERVED_PRIOR, &FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key6390);
            if  (this->hasException())
            {
                goto ruleprior_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_PRIOR239_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_PRIOR239));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_PRIOR239_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleprior_keyEx; /* Prevent compiler warnings */
    ruleprior_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end prior_key */

/**
 * $ANTLR start sequential_key
 * OracleDMLKeys.g:1283:1: sequential_key :{...}? => REGULAR_ID -> SEQUENTIAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::sequential_key_return
OracleDML_OracleDMLKeys::sequential_key()
{
    OracleDML_OracleDMLKeys::sequential_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID240 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID240_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1284:5: ({...}? => REGULAR_ID -> SEQUENTIAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1284:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SEQUENTIAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SEQUENTIAL\"" );
                    ex->set_ruleName( "sequential_key" );


            }

            REGULAR_ID240 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sequential_key6413);
            if  (this->hasException())
            {
                goto rulesequential_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID240);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1284:68: -> SEQUENTIAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SEQUENTIAL_VK, REGULAR_ID240));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesequential_keyEx; /* Prevent compiler warnings */
    rulesequential_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sequential_key */

/**
 * $ANTLR start single_key
 * OracleDMLKeys.g:1287:1: single_key :{...}? => REGULAR_ID -> SINGLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::single_key_return
OracleDML_OracleDMLKeys::single_key()
{
    OracleDML_OracleDMLKeys::single_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID241 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID241_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1288:5: ({...}? => REGULAR_ID -> SINGLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1288:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SINGLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SINGLE\"" );
                    ex->set_ruleName( "single_key" );


            }

            REGULAR_ID241 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_single_key6441);
            if  (this->hasException())
            {
                goto rulesingle_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID241);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1288:64: -> SINGLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SINGLE_VK, REGULAR_ID241));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesingle_keyEx; /* Prevent compiler warnings */
    rulesingle_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end single_key */

/**
 * $ANTLR start skip_key
 * OracleDMLKeys.g:1291:1: skip_key :{...}? => REGULAR_ID -> SKIP_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::skip_key_return
OracleDML_OracleDMLKeys::skip_key()
{
    OracleDML_OracleDMLKeys::skip_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID242 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID242_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1292:5: ({...}? => REGULAR_ID -> SKIP_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1292:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SKIP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SKIP\"" );
                    ex->set_ruleName( "skip_key" );


            }

            REGULAR_ID242 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_skip_key6469);
            if  (this->hasException())
            {
                goto ruleskip_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID242);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1292:62: -> SKIP_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SKIP_VK, REGULAR_ID242));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleskip_keyEx; /* Prevent compiler warnings */
    ruleskip_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end skip_key */

/**
 * $ANTLR start model_key
 * OracleDMLKeys.g:1295:1: model_key : PLSQL_NON_RESERVED_MODEL ;
 */
OracleDML_OracleDMLKeys::model_key_return
OracleDML_OracleDMLKeys::model_key()
{
    OracleDML_OracleDMLKeys::model_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_MODEL243 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_MODEL243_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1296:5: ( PLSQL_NON_RESERVED_MODEL )
        // OracleDMLKeys.g:1297:9: PLSQL_NON_RESERVED_MODEL
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_MODEL243 =  this->matchToken(PLSQL_NON_RESERVED_MODEL, &FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key6503);
            if  (this->hasException())
            {
                goto rulemodel_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_MODEL243_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_MODEL243));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_MODEL243_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_keyEx; /* Prevent compiler warnings */
    rulemodel_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_key */

/**
 * $ANTLR start updated_key
 * OracleDMLKeys.g:1300:1: updated_key :{...}? => REGULAR_ID -> UPDATED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::updated_key_return
OracleDML_OracleDMLKeys::updated_key()
{
    OracleDML_OracleDMLKeys::updated_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID244 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID244_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1301:5: ({...}? => REGULAR_ID -> UPDATED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1301:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "UPDATED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UPDATED\"" );
                    ex->set_ruleName( "updated_key" );


            }

            REGULAR_ID244 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_updated_key6526);
            if  (this->hasException())
            {
                goto ruleupdated_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID244);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1301:65: -> UPDATED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(UPDATED_VK, REGULAR_ID244));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleupdated_keyEx; /* Prevent compiler warnings */
    ruleupdated_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end updated_key */

/**
 * $ANTLR start increment_key
 * OracleDMLKeys.g:1304:1: increment_key :{...}? => REGULAR_ID -> INCREMENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::increment_key_return
OracleDML_OracleDMLKeys::increment_key()
{
    OracleDML_OracleDMLKeys::increment_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID245 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID245_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1305:5: ({...}? => REGULAR_ID -> INCREMENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1305:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INCREMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INCREMENT\"" );
                    ex->set_ruleName( "increment_key" );


            }

            REGULAR_ID245 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_increment_key6554);
            if  (this->hasException())
            {
                goto ruleincrement_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID245);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1305:67: -> INCREMENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INCREMENT_VK, REGULAR_ID245));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleincrement_keyEx; /* Prevent compiler warnings */
    ruleincrement_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end increment_key */

/**
 * $ANTLR start exclude_key
 * OracleDMLKeys.g:1308:1: exclude_key :{...}? => REGULAR_ID -> EXCLUDE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::exclude_key_return
OracleDML_OracleDMLKeys::exclude_key()
{
    OracleDML_OracleDMLKeys::exclude_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID246 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID246_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1309:5: ({...}? => REGULAR_ID -> EXCLUDE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1309:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EXCLUDE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXCLUDE\"" );
                    ex->set_ruleName( "exclude_key" );


            }

            REGULAR_ID246 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exclude_key6582);
            if  (this->hasException())
            {
                goto ruleexclude_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID246);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1309:65: -> EXCLUDE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EXCLUDE_VK, REGULAR_ID246));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexclude_keyEx; /* Prevent compiler warnings */
    ruleexclude_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exclude_key */

/**
 * $ANTLR start reference_key
 * OracleDMLKeys.g:1312:1: reference_key :{...}? => REGULAR_ID -> REFERENCE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::reference_key_return
OracleDML_OracleDMLKeys::reference_key()
{
    OracleDML_OracleDMLKeys::reference_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID247 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID247_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1313:5: ({...}? => REGULAR_ID -> REFERENCE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1313:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REFERENCE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REFERENCE\"" );
                    ex->set_ruleName( "reference_key" );


            }

            REGULAR_ID247 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reference_key6610);
            if  (this->hasException())
            {
                goto rulereference_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID247);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1313:67: -> REFERENCE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REFERENCE_VK, REGULAR_ID247));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereference_keyEx; /* Prevent compiler warnings */
    rulereference_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end reference_key */

/**
 * $ANTLR start sets_key
 * OracleDMLKeys.g:1316:1: sets_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::sets_key_return
OracleDML_OracleDMLKeys::sets_key()
{
    OracleDML_OracleDMLKeys::sets_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID248 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID248_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1317:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1317:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SETS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SETS\"" );
                    ex->set_ruleName( "sets_key" );


            }

            REGULAR_ID248 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sets_key6638);
            if  (this->hasException())
            {
                goto rulesets_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID248_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID248));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID248_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesets_keyEx; /* Prevent compiler warnings */
    rulesets_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sets_key */

/**
 * $ANTLR start until_key
 * OracleDMLKeys.g:1320:1: until_key :{...}? => REGULAR_ID -> UNTIL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::until_key_return
OracleDML_OracleDMLKeys::until_key()
{
    OracleDML_OracleDMLKeys::until_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID249 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID249_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1321:5: ({...}? => REGULAR_ID -> UNTIL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1321:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "UNTIL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UNTIL\"" );
                    ex->set_ruleName( "until_key" );


            }

            REGULAR_ID249 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_until_key6661);
            if  (this->hasException())
            {
                goto ruleuntil_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID249);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1321:63: -> UNTIL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(UNTIL_VK, REGULAR_ID249));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleuntil_keyEx; /* Prevent compiler warnings */
    ruleuntil_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end until_key */

/**
 * $ANTLR start seed_key
 * OracleDMLKeys.g:1324:1: seed_key :{...}? => REGULAR_ID -> SEED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::seed_key_return
OracleDML_OracleDMLKeys::seed_key()
{
    OracleDML_OracleDMLKeys::seed_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID250 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID250_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1325:5: ({...}? => REGULAR_ID -> SEED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1325:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SEED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SEED\"" );
                    ex->set_ruleName( "seed_key" );


            }

            REGULAR_ID250 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_seed_key6689);
            if  (this->hasException())
            {
                goto ruleseed_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID250);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1325:62: -> SEED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SEED_VK, REGULAR_ID250));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleseed_keyEx; /* Prevent compiler warnings */
    ruleseed_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end seed_key */

/**
 * $ANTLR start maxvalue_key
 * OracleDMLKeys.g:1328:1: maxvalue_key :{...}? => REGULAR_ID -> MAXVALUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::maxvalue_key_return
OracleDML_OracleDMLKeys::maxvalue_key()
{
    OracleDML_OracleDMLKeys::maxvalue_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID251 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID251_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1329:5: ({...}? => REGULAR_ID -> MAXVALUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1329:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MAXVALUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MAXVALUE\"" );
                    ex->set_ruleName( "maxvalue_key" );


            }

            REGULAR_ID251 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_maxvalue_key6717);
            if  (this->hasException())
            {
                goto rulemaxvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID251);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1329:66: -> MAXVALUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MAXVALUE_VK, REGULAR_ID251));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemaxvalue_keyEx; /* Prevent compiler warnings */
    rulemaxvalue_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end maxvalue_key */

/**
 * $ANTLR start siblings_key
 * OracleDMLKeys.g:1332:1: siblings_key :{...}? => REGULAR_ID -> SIBLINGS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::siblings_key_return
OracleDML_OracleDMLKeys::siblings_key()
{
    OracleDML_OracleDMLKeys::siblings_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID252 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID252_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1333:5: ({...}? => REGULAR_ID -> SIBLINGS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1333:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SIBLINGS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SIBLINGS\"" );
                    ex->set_ruleName( "siblings_key" );


            }

            REGULAR_ID252 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_siblings_key6745);
            if  (this->hasException())
            {
                goto rulesiblings_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID252);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1333:66: -> SIBLINGS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SIBLINGS_VK, REGULAR_ID252));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesiblings_keyEx; /* Prevent compiler warnings */
    rulesiblings_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end siblings_key */

/**
 * $ANTLR start cube_key
 * OracleDMLKeys.g:1336:1: cube_key :{...}? => REGULAR_ID -> CUBE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::cube_key_return
OracleDML_OracleDMLKeys::cube_key()
{
    OracleDML_OracleDMLKeys::cube_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID253 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID253_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1337:5: ({...}? => REGULAR_ID -> CUBE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1337:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CUBE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CUBE\"" );
                    ex->set_ruleName( "cube_key" );


            }

            REGULAR_ID253 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cube_key6773);
            if  (this->hasException())
            {
                goto rulecube_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID253);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1337:62: -> CUBE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CUBE_VK, REGULAR_ID253));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecube_keyEx; /* Prevent compiler warnings */
    rulecube_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cube_key */

/**
 * $ANTLR start nulls_key
 * OracleDMLKeys.g:1340:1: nulls_key :{...}? => REGULAR_ID -> NULLS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nulls_key_return
OracleDML_OracleDMLKeys::nulls_key()
{
    OracleDML_OracleDMLKeys::nulls_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID254 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID254_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1341:5: ({...}? => REGULAR_ID -> NULLS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1341:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NULLS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NULLS\"" );
                    ex->set_ruleName( "nulls_key" );


            }

            REGULAR_ID254 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nulls_key6801);
            if  (this->hasException())
            {
                goto rulenulls_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID254);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1341:63: -> NULLS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NULLS_VK, REGULAR_ID254));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenulls_keyEx; /* Prevent compiler warnings */
    rulenulls_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nulls_key */

/**
 * $ANTLR start dimension_key
 * OracleDMLKeys.g:1344:1: dimension_key :{...}? => REGULAR_ID -> DIMENSION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::dimension_key_return
OracleDML_OracleDMLKeys::dimension_key()
{
    OracleDML_OracleDMLKeys::dimension_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID255 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID255_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1345:5: ({...}? => REGULAR_ID -> DIMENSION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1345:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DIMENSION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DIMENSION\"" );
                    ex->set_ruleName( "dimension_key" );


            }

            REGULAR_ID255 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dimension_key6829);
            if  (this->hasException())
            {
                goto ruledimension_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID255);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1345:67: -> DIMENSION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DIMENSION_VK, REGULAR_ID255));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledimension_keyEx; /* Prevent compiler warnings */
    ruledimension_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dimension_key */

/**
 * $ANTLR start scn_key
 * OracleDMLKeys.g:1348:1: scn_key :{...}? => REGULAR_ID -> SCN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::scn_key_return
OracleDML_OracleDMLKeys::scn_key()
{
    OracleDML_OracleDMLKeys::scn_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID256 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID256_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1349:5: ({...}? => REGULAR_ID -> SCN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1349:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SCN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SCN\"" );
                    ex->set_ruleName( "scn_key" );


            }

            REGULAR_ID256 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_scn_key6857);
            if  (this->hasException())
            {
                goto rulescn_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID256);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1349:61: -> SCN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SCN_VK, REGULAR_ID256));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulescn_keyEx; /* Prevent compiler warnings */
    rulescn_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end scn_key */

/**
 * $ANTLR start snapshot_key
 * OracleDMLKeys.g:1352:1: snapshot_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::snapshot_key_return
OracleDML_OracleDMLKeys::snapshot_key()
{
    OracleDML_OracleDMLKeys::snapshot_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID257 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID257_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1353:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1353:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SNAPSHOT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SNAPSHOT\"" );
                    ex->set_ruleName( "snapshot_key" );


            }

            REGULAR_ID257 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_snapshot_key6885);
            if  (this->hasException())
            {
                goto rulesnapshot_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID257_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID257));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID257_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesnapshot_keyEx; /* Prevent compiler warnings */
    rulesnapshot_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end snapshot_key */

/**
 * $ANTLR start decrement_key
 * OracleDMLKeys.g:1356:1: decrement_key :{...}? => REGULAR_ID -> DECREMENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::decrement_key_return
OracleDML_OracleDMLKeys::decrement_key()
{
    OracleDML_OracleDMLKeys::decrement_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID258 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID258_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1357:5: ({...}? => REGULAR_ID -> DECREMENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1357:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DECREMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DECREMENT\"" );
                    ex->set_ruleName( "decrement_key" );


            }

            REGULAR_ID258 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decrement_key6908);
            if  (this->hasException())
            {
                goto ruledecrement_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID258);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1357:67: -> DECREMENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DECREMENT_VK, REGULAR_ID258));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledecrement_keyEx; /* Prevent compiler warnings */
    ruledecrement_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end decrement_key */

/**
 * $ANTLR start unpivot_key
 * OracleDMLKeys.g:1360:1: unpivot_key : PLSQL_NON_RESERVED_UNPIVOT ;
 */
OracleDML_OracleDMLKeys::unpivot_key_return
OracleDML_OracleDMLKeys::unpivot_key()
{
    OracleDML_OracleDMLKeys::unpivot_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_UNPIVOT259 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_UNPIVOT259_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1362:5: ( PLSQL_NON_RESERVED_UNPIVOT )
        // OracleDMLKeys.g:1362:10: PLSQL_NON_RESERVED_UNPIVOT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_UNPIVOT259 =  this->matchToken(PLSQL_NON_RESERVED_UNPIVOT, &FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key6934);
            if  (this->hasException())
            {
                goto ruleunpivot_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_UNPIVOT259_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_UNPIVOT259));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_UNPIVOT259_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunpivot_keyEx; /* Prevent compiler warnings */
    ruleunpivot_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unpivot_key */

/**
 * $ANTLR start keep_key
 * OracleDMLKeys.g:1365:1: keep_key :{...}? => REGULAR_ID -> KEEP_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::keep_key_return
OracleDML_OracleDMLKeys::keep_key()
{
    OracleDML_OracleDMLKeys::keep_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID260 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID260_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1366:5: ({...}? => REGULAR_ID -> KEEP_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1366:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "KEEP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"KEEP\"" );
                    ex->set_ruleName( "keep_key" );


            }

            REGULAR_ID260 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_keep_key6957);
            if  (this->hasException())
            {
                goto rulekeep_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID260);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1366:62: -> KEEP_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(KEEP_VK, REGULAR_ID260));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulekeep_keyEx; /* Prevent compiler warnings */
    rulekeep_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end keep_key */

/**
 * $ANTLR start measures_key
 * OracleDMLKeys.g:1369:1: measures_key :{...}? => REGULAR_ID -> MEASURES_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::measures_key_return
OracleDML_OracleDMLKeys::measures_key()
{
    OracleDML_OracleDMLKeys::measures_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID261 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID261_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1370:5: ({...}? => REGULAR_ID -> MEASURES_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1370:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MEASURES")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MEASURES\"" );
                    ex->set_ruleName( "measures_key" );


            }

            REGULAR_ID261 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_measures_key6985);
            if  (this->hasException())
            {
                goto rulemeasures_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID261);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1370:66: -> MEASURES_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MEASURES_VK, REGULAR_ID261));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemeasures_keyEx; /* Prevent compiler warnings */
    rulemeasures_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end measures_key */

/**
 * $ANTLR start rows_key
 * OracleDMLKeys.g:1373:1: rows_key :{...}? => REGULAR_ID -> ROWS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::rows_key_return
OracleDML_OracleDMLKeys::rows_key()
{
    OracleDML_OracleDMLKeys::rows_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID262 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID262_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1374:5: ({...}? => REGULAR_ID -> ROWS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1374:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ROWS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROWS\"" );
                    ex->set_ruleName( "rows_key" );


            }

            REGULAR_ID262 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rows_key7013);
            if  (this->hasException())
            {
                goto rulerows_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID262);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1374:62: -> ROWS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ROWS_VK, REGULAR_ID262));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerows_keyEx; /* Prevent compiler warnings */
    rulerows_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rows_key */

/**
 * $ANTLR start sample_key
 * OracleDMLKeys.g:1377:1: sample_key :{...}? => REGULAR_ID -> SAMPLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::sample_key_return
OracleDML_OracleDMLKeys::sample_key()
{
    OracleDML_OracleDMLKeys::sample_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID263 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID263_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1378:5: ({...}? => REGULAR_ID -> SAMPLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1378:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SAMPLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SAMPLE\"" );
                    ex->set_ruleName( "sample_key" );


            }

            REGULAR_ID263 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sample_key7041);
            if  (this->hasException())
            {
                goto rulesample_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID263);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1378:64: -> SAMPLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SAMPLE_VK, REGULAR_ID263));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesample_keyEx; /* Prevent compiler warnings */
    rulesample_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sample_key */

/**
 * $ANTLR start upsert_key
 * OracleDMLKeys.g:1381:1: upsert_key :{...}? => REGULAR_ID -> UPSERT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::upsert_key_return
OracleDML_OracleDMLKeys::upsert_key()
{
    OracleDML_OracleDMLKeys::upsert_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID264 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID264_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1382:5: ({...}? => REGULAR_ID -> UPSERT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1382:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "UPSERT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UPSERT\"" );
                    ex->set_ruleName( "upsert_key" );


            }

            REGULAR_ID264 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_upsert_key7069);
            if  (this->hasException())
            {
                goto ruleupsert_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID264);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1382:64: -> UPSERT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(UPSERT_VK, REGULAR_ID264));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleupsert_keyEx; /* Prevent compiler warnings */
    ruleupsert_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end upsert_key */

/**
 * $ANTLR start versions_key
 * OracleDMLKeys.g:1385:1: versions_key :{...}? => REGULAR_ID -> VERSIONS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::versions_key_return
OracleDML_OracleDMLKeys::versions_key()
{
    OracleDML_OracleDMLKeys::versions_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID265 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID265_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1386:5: ({...}? => REGULAR_ID -> VERSIONS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1386:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "VERSIONS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VERSIONS\"" );
                    ex->set_ruleName( "versions_key" );


            }

            REGULAR_ID265 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_versions_key7097);
            if  (this->hasException())
            {
                goto ruleversions_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID265);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1386:66: -> VERSIONS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(VERSIONS_VK, REGULAR_ID265));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleversions_keyEx; /* Prevent compiler warnings */
    ruleversions_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end versions_key */

/**
 * $ANTLR start rules_key
 * OracleDMLKeys.g:1389:1: rules_key :{...}? => REGULAR_ID -> RULES_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::rules_key_return
OracleDML_OracleDMLKeys::rules_key()
{
    OracleDML_OracleDMLKeys::rules_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID266 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID266_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1390:5: ({...}? => REGULAR_ID -> RULES_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1390:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RULES")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RULES\"" );
                    ex->set_ruleName( "rules_key" );


            }

            REGULAR_ID266 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rules_key7125);
            if  (this->hasException())
            {
                goto rulerules_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID266);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1390:63: -> RULES_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RULES_VK, REGULAR_ID266));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerules_keyEx; /* Prevent compiler warnings */
    rulerules_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rules_key */

/**
 * $ANTLR start iterate_key
 * OracleDMLKeys.g:1393:1: iterate_key :{...}? => REGULAR_ID -> ITERATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::iterate_key_return
OracleDML_OracleDMLKeys::iterate_key()
{
    OracleDML_OracleDMLKeys::iterate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID267 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID267_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1394:5: ({...}? => REGULAR_ID -> ITERATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1394:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ITERATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ITERATE\"" );
                    ex->set_ruleName( "iterate_key" );


            }

            REGULAR_ID267 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_iterate_key7153);
            if  (this->hasException())
            {
                goto ruleiterate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID267);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1394:65: -> ITERATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ITERATE_VK, REGULAR_ID267));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleiterate_keyEx; /* Prevent compiler warnings */
    ruleiterate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end iterate_key */

/**
 * $ANTLR start minvalue_key
 * OracleDMLKeys.g:1397:1: minvalue_key :{...}? => REGULAR_ID -> MINVALUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::minvalue_key_return
OracleDML_OracleDMLKeys::minvalue_key()
{
    OracleDML_OracleDMLKeys::minvalue_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID268 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID268_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1398:5: ({...}? => REGULAR_ID -> MINVALUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1398:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MINVALUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MINVALUE\"" );
                    ex->set_ruleName( "minvalue_key" );


            }

            REGULAR_ID268 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_minvalue_key7181);
            if  (this->hasException())
            {
                goto ruleminvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID268);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1398:66: -> MINVALUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MINVALUE_VK, REGULAR_ID268));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleminvalue_keyEx; /* Prevent compiler warnings */
    ruleminvalue_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end minvalue_key */

/**
 * $ANTLR start rollup_key
 * OracleDMLKeys.g:1401:1: rollup_key :{...}? => REGULAR_ID -> ROLLUP_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::rollup_key_return
OracleDML_OracleDMLKeys::rollup_key()
{
    OracleDML_OracleDMLKeys::rollup_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID269 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID269_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1402:5: ({...}? => REGULAR_ID -> ROLLUP_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1402:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ROLLUP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROLLUP\"" );
                    ex->set_ruleName( "rollup_key" );


            }

            REGULAR_ID269 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rollup_key7209);
            if  (this->hasException())
            {
                goto rulerollup_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID269);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1402:64: -> ROLLUP_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ROLLUP_VK, REGULAR_ID269));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerollup_keyEx; /* Prevent compiler warnings */
    rulerollup_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rollup_key */

/**
 * $ANTLR start nav_key
 * OracleDMLKeys.g:1405:1: nav_key :{...}? => REGULAR_ID -> NAV_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nav_key_return
OracleDML_OracleDMLKeys::nav_key()
{
    OracleDML_OracleDMLKeys::nav_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID270 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID270_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1406:5: ({...}? => REGULAR_ID -> NAV_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1406:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NAV")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NAV\"" );
                    ex->set_ruleName( "nav_key" );


            }

            REGULAR_ID270 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nav_key7237);
            if  (this->hasException())
            {
                goto rulenav_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID270);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1406:61: -> NAV_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NAV_VK, REGULAR_ID270));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenav_keyEx; /* Prevent compiler warnings */
    rulenav_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nav_key */

/**
 * $ANTLR start automatic_key
 * OracleDMLKeys.g:1409:1: automatic_key :{...}? => REGULAR_ID -> AUTOMATIC_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::automatic_key_return
OracleDML_OracleDMLKeys::automatic_key()
{
    OracleDML_OracleDMLKeys::automatic_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID271 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID271_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1410:5: ({...}? => REGULAR_ID -> AUTOMATIC_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1410:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AUTOMATIC")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AUTOMATIC\"" );
                    ex->set_ruleName( "automatic_key" );


            }

            REGULAR_ID271 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_automatic_key7265);
            if  (this->hasException())
            {
                goto ruleautomatic_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID271);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1410:67: -> AUTOMATIC_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AUTOMATIC_VK, REGULAR_ID271));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleautomatic_keyEx; /* Prevent compiler warnings */
    ruleautomatic_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end automatic_key */

/**
 * $ANTLR start last_key
 * OracleDMLKeys.g:1413:1: last_key :{...}? => REGULAR_ID -> LAST_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::last_key_return
OracleDML_OracleDMLKeys::last_key()
{
    OracleDML_OracleDMLKeys::last_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID272 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID272_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1414:5: ({...}? => REGULAR_ID -> LAST_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1414:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LAST")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LAST\"" );
                    ex->set_ruleName( "last_key" );


            }

            REGULAR_ID272 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_last_key7293);
            if  (this->hasException())
            {
                goto rulelast_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID272);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1414:62: -> LAST_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LAST_VK, REGULAR_ID272));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelast_keyEx; /* Prevent compiler warnings */
    rulelast_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end last_key */

/**
 * $ANTLR start main_key
 * OracleDMLKeys.g:1417:1: main_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::main_key_return
OracleDML_OracleDMLKeys::main_key()
{
    OracleDML_OracleDMLKeys::main_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID273 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID273_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1418:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1418:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "MAIN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MAIN\"" );
                    ex->set_ruleName( "main_key" );


            }

            REGULAR_ID273 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_main_key7321);
            if  (this->hasException())
            {
                goto rulemain_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID273_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID273));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID273_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemain_keyEx; /* Prevent compiler warnings */
    rulemain_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end main_key */

/**
 * $ANTLR start grouping_key
 * OracleDMLKeys.g:1421:1: grouping_key :{...}? => REGULAR_ID -> GROUPING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::grouping_key_return
OracleDML_OracleDMLKeys::grouping_key()
{
    OracleDML_OracleDMLKeys::grouping_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID274 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID274_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1422:5: ({...}? => REGULAR_ID -> GROUPING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1422:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "GROUPING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"GROUPING\"" );
                    ex->set_ruleName( "grouping_key" );


            }

            REGULAR_ID274 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_grouping_key7344);
            if  (this->hasException())
            {
                goto rulegrouping_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID274);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1422:66: -> GROUPING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(GROUPING_VK, REGULAR_ID274));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegrouping_keyEx; /* Prevent compiler warnings */
    rulegrouping_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end grouping_key */

/**
 * $ANTLR start include_key
 * OracleDMLKeys.g:1425:1: include_key :{...}? => REGULAR_ID -> INCLUDE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::include_key_return
OracleDML_OracleDMLKeys::include_key()
{
    OracleDML_OracleDMLKeys::include_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID275 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID275_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1426:5: ({...}? => REGULAR_ID -> INCLUDE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1426:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INCLUDE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INCLUDE\"" );
                    ex->set_ruleName( "include_key" );


            }

            REGULAR_ID275 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_include_key7372);
            if  (this->hasException())
            {
                goto ruleinclude_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID275);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1426:65: -> INCLUDE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INCLUDE_VK, REGULAR_ID275));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinclude_keyEx; /* Prevent compiler warnings */
    ruleinclude_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end include_key */

/**
 * $ANTLR start ignore_key
 * OracleDMLKeys.g:1429:1: ignore_key :{...}? => REGULAR_ID -> IGNORE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::ignore_key_return
OracleDML_OracleDMLKeys::ignore_key()
{
    OracleDML_OracleDMLKeys::ignore_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID276 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID276_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1430:5: ({...}? => REGULAR_ID -> IGNORE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1430:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "IGNORE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"IGNORE\"" );
                    ex->set_ruleName( "ignore_key" );


            }

            REGULAR_ID276 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ignore_key7400);
            if  (this->hasException())
            {
                goto ruleignore_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID276);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1430:64: -> IGNORE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(IGNORE_VK, REGULAR_ID276));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleignore_keyEx; /* Prevent compiler warnings */
    ruleignore_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end ignore_key */

/**
 * $ANTLR start respect_key
 * OracleDMLKeys.g:1433:1: respect_key :{...}? => REGULAR_ID -> RESPECT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::respect_key_return
OracleDML_OracleDMLKeys::respect_key()
{
    OracleDML_OracleDMLKeys::respect_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID277 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID277_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1434:5: ({...}? => REGULAR_ID -> RESPECT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1434:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RESPECT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RESPECT\"" );
                    ex->set_ruleName( "respect_key" );


            }

            REGULAR_ID277 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_respect_key7428);
            if  (this->hasException())
            {
                goto rulerespect_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID277);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1434:65: -> RESPECT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RESPECT_VK, REGULAR_ID277));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerespect_keyEx; /* Prevent compiler warnings */
    rulerespect_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end respect_key */

/**
 * $ANTLR start unique_key
 * OracleDMLKeys.g:1437:1: unique_key : SQL92_RESERVED_UNIQUE ;
 */
OracleDML_OracleDMLKeys::unique_key_return
OracleDML_OracleDMLKeys::unique_key()
{
    OracleDML_OracleDMLKeys::unique_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_UNIQUE278 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_UNIQUE278_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1438:5: ( SQL92_RESERVED_UNIQUE )
        // OracleDMLKeys.g:1438:10: SQL92_RESERVED_UNIQUE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_UNIQUE278 =  this->matchToken(SQL92_RESERVED_UNIQUE, &FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key7452);
            if  (this->hasException())
            {
                goto ruleunique_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_UNIQUE278_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_UNIQUE278));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_UNIQUE278_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunique_keyEx; /* Prevent compiler warnings */
    ruleunique_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unique_key */

/**
 * $ANTLR start submultiset_key
 * OracleDMLKeys.g:1441:1: submultiset_key :{...}? => REGULAR_ID -> SUBMULTISET_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::submultiset_key_return
OracleDML_OracleDMLKeys::submultiset_key()
{
    OracleDML_OracleDMLKeys::submultiset_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID279 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID279_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1442:5: ({...}? => REGULAR_ID -> SUBMULTISET_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1442:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SUBMULTISET")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUBMULTISET\"" );
                    ex->set_ruleName( "submultiset_key" );


            }

            REGULAR_ID279 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_submultiset_key7475);
            if  (this->hasException())
            {
                goto rulesubmultiset_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID279);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1442:69: -> SUBMULTISET_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SUBMULTISET_VK, REGULAR_ID279));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubmultiset_keyEx; /* Prevent compiler warnings */
    rulesubmultiset_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end submultiset_key */

/**
 * $ANTLR start at_key
 * OracleDMLKeys.g:1445:1: at_key :{...}? => REGULAR_ID -> AT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::at_key_return
OracleDML_OracleDMLKeys::at_key()
{
    OracleDML_OracleDMLKeys::at_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID280 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID280_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1446:5: ({...}? => REGULAR_ID -> AT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1446:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AT\"" );
                    ex->set_ruleName( "at_key" );


            }

            REGULAR_ID280 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_at_key7503);
            if  (this->hasException())
            {
                goto ruleat_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID280);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1446:60: -> AT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AT_VK, REGULAR_ID280));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleat_keyEx; /* Prevent compiler warnings */
    ruleat_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end at_key */

/**
 * $ANTLR start a_key
 * OracleDMLKeys.g:1449:1: a_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::a_key_return
OracleDML_OracleDMLKeys::a_key()
{
    OracleDML_OracleDMLKeys::a_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID281 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID281_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1450:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1450:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "A")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"A\"" );
                    ex->set_ruleName( "a_key" );


            }

            REGULAR_ID281 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_a_key7531);
            if  (this->hasException())
            {
                goto rulea_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID281_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID281));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID281_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulea_keyEx; /* Prevent compiler warnings */
    rulea_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end a_key */

/**
 * $ANTLR start empty_key
 * OracleDMLKeys.g:1453:1: empty_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::empty_key_return
OracleDML_OracleDMLKeys::empty_key()
{
    OracleDML_OracleDMLKeys::empty_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID282 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID282_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1454:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1454:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "EMPTY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EMPTY\"" );
                    ex->set_ruleName( "empty_key" );


            }

            REGULAR_ID282 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_empty_key7554);
            if  (this->hasException())
            {
                goto ruleempty_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID282_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID282));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID282_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleempty_keyEx; /* Prevent compiler warnings */
    ruleempty_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end empty_key */

/**
 * $ANTLR start likec_key
 * OracleDMLKeys.g:1457:1: likec_key :{...}? => REGULAR_ID -> LIKEC_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::likec_key_return
OracleDML_OracleDMLKeys::likec_key()
{
    OracleDML_OracleDMLKeys::likec_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID283 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID283_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1458:5: ({...}? => REGULAR_ID -> LIKEC_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1458:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LIKEC")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LIKEC\"" );
                    ex->set_ruleName( "likec_key" );


            }

            REGULAR_ID283 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_likec_key7577);
            if  (this->hasException())
            {
                goto rulelikec_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID283);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1458:63: -> LIKEC_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LIKEC_VK, REGULAR_ID283));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelikec_keyEx; /* Prevent compiler warnings */
    rulelikec_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end likec_key */

/**
 * $ANTLR start nan_key
 * OracleDMLKeys.g:1461:1: nan_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::nan_key_return
OracleDML_OracleDMLKeys::nan_key()
{
    OracleDML_OracleDMLKeys::nan_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID284 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID284_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1462:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1462:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "NAN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NAN\"" );
                    ex->set_ruleName( "nan_key" );


            }

            REGULAR_ID284 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nan_key7605);
            if  (this->hasException())
            {
                goto rulenan_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID284_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID284));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID284_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenan_keyEx; /* Prevent compiler warnings */
    rulenan_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nan_key */

/**
 * $ANTLR start infinite_key
 * OracleDMLKeys.g:1465:1: infinite_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::infinite_key_return
OracleDML_OracleDMLKeys::infinite_key()
{
    OracleDML_OracleDMLKeys::infinite_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID285 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID285_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1466:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1466:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "INFINITE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INFINITE\"" );
                    ex->set_ruleName( "infinite_key" );


            }

            REGULAR_ID285 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_infinite_key7628);
            if  (this->hasException())
            {
                goto ruleinfinite_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID285_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID285));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID285_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinfinite_keyEx; /* Prevent compiler warnings */
    ruleinfinite_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end infinite_key */

/**
 * $ANTLR start like2_key
 * OracleDMLKeys.g:1469:1: like2_key :{...}? => REGULAR_ID -> LIKE2_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::like2_key_return
OracleDML_OracleDMLKeys::like2_key()
{
    OracleDML_OracleDMLKeys::like2_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID286 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID286_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1470:5: ({...}? => REGULAR_ID -> LIKE2_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1470:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LIKE2")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LIKE2\"" );
                    ex->set_ruleName( "like2_key" );


            }

            REGULAR_ID286 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_like2_key7651);
            if  (this->hasException())
            {
                goto rulelike2_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID286);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1470:63: -> LIKE2_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LIKE2_VK, REGULAR_ID286));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelike2_keyEx; /* Prevent compiler warnings */
    rulelike2_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end like2_key */

/**
 * $ANTLR start like4_key
 * OracleDMLKeys.g:1473:1: like4_key :{...}? => REGULAR_ID -> LIKE4_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::like4_key_return
OracleDML_OracleDMLKeys::like4_key()
{
    OracleDML_OracleDMLKeys::like4_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID287 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID287_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1474:5: ({...}? => REGULAR_ID -> LIKE4_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1474:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LIKE4")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LIKE4\"" );
                    ex->set_ruleName( "like4_key" );


            }

            REGULAR_ID287 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_like4_key7679);
            if  (this->hasException())
            {
                goto rulelike4_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID287);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1474:63: -> LIKE4_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LIKE4_VK, REGULAR_ID287));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelike4_keyEx; /* Prevent compiler warnings */
    rulelike4_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end like4_key */

/**
 * $ANTLR start present_key
 * OracleDMLKeys.g:1477:1: present_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::present_key_return
OracleDML_OracleDMLKeys::present_key()
{
    OracleDML_OracleDMLKeys::present_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID288 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID288_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1478:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1478:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "PRESENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PRESENT\"" );
                    ex->set_ruleName( "present_key" );


            }

            REGULAR_ID288 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_present_key7707);
            if  (this->hasException())
            {
                goto rulepresent_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID288_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID288));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID288_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepresent_keyEx; /* Prevent compiler warnings */
    rulepresent_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end present_key */

/**
 * $ANTLR start dbtimezone_key
 * OracleDMLKeys.g:1481:1: dbtimezone_key :{...}? => REGULAR_ID -> DBTIMEZONE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::dbtimezone_key_return
OracleDML_OracleDMLKeys::dbtimezone_key()
{
    OracleDML_OracleDMLKeys::dbtimezone_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID289 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID289_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1482:5: ({...}? => REGULAR_ID -> DBTIMEZONE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1482:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DBTIMEZONE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DBTIMEZONE\"" );
                    ex->set_ruleName( "dbtimezone_key" );


            }

            REGULAR_ID289 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dbtimezone_key7730);
            if  (this->hasException())
            {
                goto ruledbtimezone_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID289);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1482:68: -> DBTIMEZONE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DBTIMEZONE_VK, REGULAR_ID289));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledbtimezone_keyEx; /* Prevent compiler warnings */
    ruledbtimezone_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dbtimezone_key */

/**
 * $ANTLR start sessiontimezone_key
 * OracleDMLKeys.g:1485:1: sessiontimezone_key :{...}? => REGULAR_ID -> SESSIONTIMEZONE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::sessiontimezone_key_return
OracleDML_OracleDMLKeys::sessiontimezone_key()
{
    OracleDML_OracleDMLKeys::sessiontimezone_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID290 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID290_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1486:5: ({...}? => REGULAR_ID -> SESSIONTIMEZONE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1486:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SESSIONTIMEZONE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SESSIONTIMEZONE\"" );
                    ex->set_ruleName( "sessiontimezone_key" );


            }

            REGULAR_ID290 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sessiontimezone_key7758);
            if  (this->hasException())
            {
                goto rulesessiontimezone_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID290);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1486:73: -> SESSIONTIMEZONE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SESSIONTIMEZONE_VK, REGULAR_ID290));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesessiontimezone_keyEx; /* Prevent compiler warnings */
    rulesessiontimezone_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sessiontimezone_key */

/**
 * $ANTLR start nchar_cs_key
 * OracleDMLKeys.g:1489:1: nchar_cs_key :{...}? => REGULAR_ID -> NCHAR_CS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nchar_cs_key_return
OracleDML_OracleDMLKeys::nchar_cs_key()
{
    OracleDML_OracleDMLKeys::nchar_cs_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID291 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID291_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1490:5: ({...}? => REGULAR_ID -> NCHAR_CS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1490:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NCHAR_CS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NCHAR_CS\"" );
                    ex->set_ruleName( "nchar_cs_key" );


            }

            REGULAR_ID291 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nchar_cs_key7786);
            if  (this->hasException())
            {
                goto rulenchar_cs_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID291);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1490:66: -> NCHAR_CS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NCHAR_CS_VK, REGULAR_ID291));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenchar_cs_keyEx; /* Prevent compiler warnings */
    rulenchar_cs_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nchar_cs_key */

/**
 * $ANTLR start decompose_key
 * OracleDMLKeys.g:1493:1: decompose_key :{...}? => REGULAR_ID -> DECOMPOSE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::decompose_key_return
OracleDML_OracleDMLKeys::decompose_key()
{
    OracleDML_OracleDMLKeys::decompose_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID292 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID292_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1494:5: ({...}? => REGULAR_ID -> DECOMPOSE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1494:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DECOMPOSE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DECOMPOSE\"" );
                    ex->set_ruleName( "decompose_key" );


            }

            REGULAR_ID292 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decompose_key7814);
            if  (this->hasException())
            {
                goto ruledecompose_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID292);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1494:67: -> DECOMPOSE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DECOMPOSE_VK, REGULAR_ID292));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledecompose_keyEx; /* Prevent compiler warnings */
    ruledecompose_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end decompose_key */

/**
 * $ANTLR start following_key
 * OracleDMLKeys.g:1497:1: following_key :{...}? => REGULAR_ID -> FOLLOWING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::following_key_return
OracleDML_OracleDMLKeys::following_key()
{
    OracleDML_OracleDMLKeys::following_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID293 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID293_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1498:5: ({...}? => REGULAR_ID -> FOLLOWING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1498:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FOLLOWING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FOLLOWING\"" );
                    ex->set_ruleName( "following_key" );


            }

            REGULAR_ID293 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_following_key7842);
            if  (this->hasException())
            {
                goto rulefollowing_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID293);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1498:67: -> FOLLOWING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FOLLOWING_VK, REGULAR_ID293));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefollowing_keyEx; /* Prevent compiler warnings */
    rulefollowing_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end following_key */

/**
 * $ANTLR start first_value_key
 * OracleDMLKeys.g:1501:1: first_value_key :{...}? => REGULAR_ID -> FIRST_VALUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::first_value_key_return
OracleDML_OracleDMLKeys::first_value_key()
{
    OracleDML_OracleDMLKeys::first_value_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID294 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID294_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1502:5: ({...}? => REGULAR_ID -> FIRST_VALUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1502:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FIRST_VALUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FIRST_VALUE\"" );
                    ex->set_ruleName( "first_value_key" );


            }

            REGULAR_ID294 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_first_value_key7870);
            if  (this->hasException())
            {
                goto rulefirst_value_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID294);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1502:69: -> FIRST_VALUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FIRST_VALUE_VK, REGULAR_ID294));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefirst_value_keyEx; /* Prevent compiler warnings */
    rulefirst_value_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end first_value_key */

/**
 * $ANTLR start preceding_key
 * OracleDMLKeys.g:1505:1: preceding_key :{...}? => REGULAR_ID -> PRECEDING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::preceding_key_return
OracleDML_OracleDMLKeys::preceding_key()
{
    OracleDML_OracleDMLKeys::preceding_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID295 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID295_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1506:5: ({...}? => REGULAR_ID -> PRECEDING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1506:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PRECEDING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PRECEDING\"" );
                    ex->set_ruleName( "preceding_key" );


            }

            REGULAR_ID295 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_preceding_key7898);
            if  (this->hasException())
            {
                goto rulepreceding_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID295);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1506:67: -> PRECEDING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PRECEDING_VK, REGULAR_ID295));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepreceding_keyEx; /* Prevent compiler warnings */
    rulepreceding_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end preceding_key */

/**
 * $ANTLR start within_key
 * OracleDMLKeys.g:1509:1: within_key :{...}? => REGULAR_ID -> WITHIN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::within_key_return
OracleDML_OracleDMLKeys::within_key()
{
    OracleDML_OracleDMLKeys::within_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID296 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID296_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1510:5: ({...}? => REGULAR_ID -> WITHIN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1510:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "WITHIN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WITHIN\"" );
                    ex->set_ruleName( "within_key" );


            }

            REGULAR_ID296 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_within_key7926);
            if  (this->hasException())
            {
                goto rulewithin_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID296);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1510:64: -> WITHIN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(WITHIN_VK, REGULAR_ID296));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewithin_keyEx; /* Prevent compiler warnings */
    rulewithin_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end within_key */

/**
 * $ANTLR start canonical_key
 * OracleDMLKeys.g:1513:1: canonical_key :{...}? => REGULAR_ID -> CANONICAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::canonical_key_return
OracleDML_OracleDMLKeys::canonical_key()
{
    OracleDML_OracleDMLKeys::canonical_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID297 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID297_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1514:5: ({...}? => REGULAR_ID -> CANONICAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1514:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CANONICAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CANONICAL\"" );
                    ex->set_ruleName( "canonical_key" );


            }

            REGULAR_ID297 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_canonical_key7954);
            if  (this->hasException())
            {
                goto rulecanonical_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID297);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1514:67: -> CANONICAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CANONICAL_VK, REGULAR_ID297));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecanonical_keyEx; /* Prevent compiler warnings */
    rulecanonical_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end canonical_key */

/**
 * $ANTLR start compatibility_key
 * OracleDMLKeys.g:1517:1: compatibility_key :{...}? => REGULAR_ID -> COMPATIBILITY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::compatibility_key_return
OracleDML_OracleDMLKeys::compatibility_key()
{
    OracleDML_OracleDMLKeys::compatibility_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID298 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID298_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1518:5: ({...}? => REGULAR_ID -> COMPATIBILITY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1518:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COMPATIBILITY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COMPATIBILITY\"" );
                    ex->set_ruleName( "compatibility_key" );


            }

            REGULAR_ID298 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compatibility_key7982);
            if  (this->hasException())
            {
                goto rulecompatibility_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID298);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1518:71: -> COMPATIBILITY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COMPATIBILITY_VK, REGULAR_ID298));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecompatibility_keyEx; /* Prevent compiler warnings */
    rulecompatibility_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end compatibility_key */

/**
 * $ANTLR start over_key
 * OracleDMLKeys.g:1521:1: over_key :{...}? => REGULAR_ID -> OVER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::over_key_return
OracleDML_OracleDMLKeys::over_key()
{
    OracleDML_OracleDMLKeys::over_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID299 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID299_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1522:5: ({...}? => REGULAR_ID -> OVER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1522:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "OVER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OVER\"" );
                    ex->set_ruleName( "over_key" );


            }

            REGULAR_ID299 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_over_key8010);
            if  (this->hasException())
            {
                goto ruleover_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID299);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1522:62: -> OVER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(OVER_VK, REGULAR_ID299));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleover_keyEx; /* Prevent compiler warnings */
    ruleover_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end over_key */

/**
 * $ANTLR start multiset_key
 * OracleDMLKeys.g:1525:1: multiset_key : PLSQL_NON_RESERVED_MULTISET ;
 */
OracleDML_OracleDMLKeys::multiset_key_return
OracleDML_OracleDMLKeys::multiset_key()
{
    OracleDML_OracleDMLKeys::multiset_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_MULTISET300 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_MULTISET300_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1527:5: ( PLSQL_NON_RESERVED_MULTISET )
        // OracleDMLKeys.g:1527:10: PLSQL_NON_RESERVED_MULTISET
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_MULTISET300 =  this->matchToken(PLSQL_NON_RESERVED_MULTISET, &FOLLOW_PLSQL_NON_RESERVED_MULTISET_in_multiset_key8036);
            if  (this->hasException())
            {
                goto rulemultiset_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_MULTISET300_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_MULTISET300));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_MULTISET300_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemultiset_keyEx; /* Prevent compiler warnings */
    rulemultiset_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multiset_key */

/**
 * $ANTLR start connect_by_root_key
 * OracleDMLKeys.g:1530:1: connect_by_root_key : PLSQL_NON_RESERVED_CONNECT_BY_ROOT ;
 */
OracleDML_OracleDMLKeys::connect_by_root_key_return
OracleDML_OracleDMLKeys::connect_by_root_key()
{
    OracleDML_OracleDMLKeys::connect_by_root_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_CONNECT_BY_ROOT301 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_CONNECT_BY_ROOT301_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1531:5: ( PLSQL_NON_RESERVED_CONNECT_BY_ROOT )
        // OracleDMLKeys.g:1531:10: PLSQL_NON_RESERVED_CONNECT_BY_ROOT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_CONNECT_BY_ROOT301 =  this->matchToken(PLSQL_NON_RESERVED_CONNECT_BY_ROOT, &FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key8056);
            if  (this->hasException())
            {
                goto ruleconnect_by_root_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_CONNECT_BY_ROOT301_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_CONNECT_BY_ROOT301));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_CONNECT_BY_ROOT301_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconnect_by_root_keyEx; /* Prevent compiler warnings */
    ruleconnect_by_root_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end connect_by_root_key */

/**
 * $ANTLR start last_value_key
 * OracleDMLKeys.g:1534:1: last_value_key :{...}? => REGULAR_ID -> LAST_VALUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::last_value_key_return
OracleDML_OracleDMLKeys::last_value_key()
{
    OracleDML_OracleDMLKeys::last_value_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID302 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID302_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1535:5: ({...}? => REGULAR_ID -> LAST_VALUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1535:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LAST_VALUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LAST_VALUE\"" );
                    ex->set_ruleName( "last_value_key" );


            }

            REGULAR_ID302 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_last_value_key8079);
            if  (this->hasException())
            {
                goto rulelast_value_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID302);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1535:68: -> LAST_VALUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LAST_VALUE_VK, REGULAR_ID302));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelast_value_keyEx; /* Prevent compiler warnings */
    rulelast_value_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end last_value_key */

/**
 * $ANTLR start current_key
 * OracleDMLKeys.g:1538:1: current_key : SQL92_RESERVED_CURRENT ;
 */
OracleDML_OracleDMLKeys::current_key_return
OracleDML_OracleDMLKeys::current_key()
{
    OracleDML_OracleDMLKeys::current_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_CURRENT303 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_CURRENT303_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1539:5: ( SQL92_RESERVED_CURRENT )
        // OracleDMLKeys.g:1539:10: SQL92_RESERVED_CURRENT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_CURRENT303 =  this->matchToken(SQL92_RESERVED_CURRENT, &FOLLOW_SQL92_RESERVED_CURRENT_in_current_key8104);
            if  (this->hasException())
            {
                goto rulecurrent_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_CURRENT303_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_CURRENT303));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_CURRENT303_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecurrent_keyEx; /* Prevent compiler warnings */
    rulecurrent_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end current_key */

/**
 * $ANTLR start unbounded_key
 * OracleDMLKeys.g:1542:1: unbounded_key :{...}? => REGULAR_ID -> UNBOUNDED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::unbounded_key_return
OracleDML_OracleDMLKeys::unbounded_key()
{
    OracleDML_OracleDMLKeys::unbounded_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID304 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID304_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1543:5: ({...}? => REGULAR_ID -> UNBOUNDED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1543:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "UNBOUNDED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UNBOUNDED\"" );
                    ex->set_ruleName( "unbounded_key" );


            }

            REGULAR_ID304 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unbounded_key8127);
            if  (this->hasException())
            {
                goto ruleunbounded_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID304);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1543:67: -> UNBOUNDED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(UNBOUNDED_VK, REGULAR_ID304));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunbounded_keyEx; /* Prevent compiler warnings */
    ruleunbounded_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unbounded_key */

/**
 * $ANTLR start dense_rank_key
 * OracleDMLKeys.g:1546:1: dense_rank_key :{...}? => REGULAR_ID -> DENSE_RANK_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::dense_rank_key_return
OracleDML_OracleDMLKeys::dense_rank_key()
{
    OracleDML_OracleDMLKeys::dense_rank_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID305 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID305_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1547:5: ({...}? => REGULAR_ID -> DENSE_RANK_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1547:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DENSE_RANK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DENSE_RANK\"" );
                    ex->set_ruleName( "dense_rank_key" );


            }

            REGULAR_ID305 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dense_rank_key8155);
            if  (this->hasException())
            {
                goto ruledense_rank_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID305);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1547:68: -> DENSE_RANK_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DENSE_RANK_VK, REGULAR_ID305));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledense_rank_keyEx; /* Prevent compiler warnings */
    ruledense_rank_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dense_rank_key */

/**
 * $ANTLR start cost_key
 * OracleDMLKeys.g:1550:1: cost_key :{...}? => REGULAR_ID -> COST_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::cost_key_return
OracleDML_OracleDMLKeys::cost_key()
{
    OracleDML_OracleDMLKeys::cost_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID306 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID306_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1551:5: ({...}? => REGULAR_ID -> COST_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1551:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COST")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COST\"" );
                    ex->set_ruleName( "cost_key" );


            }

            REGULAR_ID306 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cost_key8183);
            if  (this->hasException())
            {
                goto rulecost_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID306);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1551:62: -> COST_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COST_VK, REGULAR_ID306));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecost_keyEx; /* Prevent compiler warnings */
    rulecost_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cost_key */

/**
 * $ANTLR start char_cs_key
 * OracleDMLKeys.g:1554:1: char_cs_key :{...}? => REGULAR_ID -> CHAR_CS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::char_cs_key_return
OracleDML_OracleDMLKeys::char_cs_key()
{
    OracleDML_OracleDMLKeys::char_cs_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID307 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID307_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1555:5: ({...}? => REGULAR_ID -> CHAR_CS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1555:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CHAR_CS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CHAR_CS\"" );
                    ex->set_ruleName( "char_cs_key" );


            }

            REGULAR_ID307 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_cs_key8211);
            if  (this->hasException())
            {
                goto rulechar_cs_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID307);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1555:65: -> CHAR_CS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CHAR_CS_VK, REGULAR_ID307));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulechar_cs_keyEx; /* Prevent compiler warnings */
    rulechar_cs_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end char_cs_key */

/**
 * $ANTLR start auto_key
 * OracleDMLKeys.g:1558:1: auto_key :{...}? => REGULAR_ID -> AUTO_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::auto_key_return
OracleDML_OracleDMLKeys::auto_key()
{
    OracleDML_OracleDMLKeys::auto_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID308 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID308_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1559:5: ({...}? => REGULAR_ID -> AUTO_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1559:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "AUTO")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AUTO\"" );
                    ex->set_ruleName( "auto_key" );


            }

            REGULAR_ID308 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_auto_key8239);
            if  (this->hasException())
            {
                goto ruleauto_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID308);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1559:62: -> AUTO_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(AUTO_VK, REGULAR_ID308));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleauto_keyEx; /* Prevent compiler warnings */
    ruleauto_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end auto_key */

/**
 * $ANTLR start treat_key
 * OracleDMLKeys.g:1562:1: treat_key :{...}? => REGULAR_ID -> TREAT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::treat_key_return
OracleDML_OracleDMLKeys::treat_key()
{
    OracleDML_OracleDMLKeys::treat_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID309 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID309_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1563:5: ({...}? => REGULAR_ID -> TREAT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1563:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TREAT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TREAT\"" );
                    ex->set_ruleName( "treat_key" );


            }

            REGULAR_ID309 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_treat_key8267);
            if  (this->hasException())
            {
                goto ruletreat_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID309);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1563:63: -> TREAT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TREAT_VK, REGULAR_ID309));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletreat_keyEx; /* Prevent compiler warnings */
    ruletreat_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end treat_key */

/**
 * $ANTLR start content_key
 * OracleDMLKeys.g:1566:1: content_key :{...}? => REGULAR_ID -> CONTENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::content_key_return
OracleDML_OracleDMLKeys::content_key()
{
    OracleDML_OracleDMLKeys::content_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID310 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID310_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1567:5: ({...}? => REGULAR_ID -> CONTENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1567:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CONTENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONTENT\"" );
                    ex->set_ruleName( "content_key" );


            }

            REGULAR_ID310 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_content_key8295);
            if  (this->hasException())
            {
                goto rulecontent_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID310);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1567:65: -> CONTENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CONTENT_VK, REGULAR_ID310));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecontent_keyEx; /* Prevent compiler warnings */
    rulecontent_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end content_key */

/**
 * $ANTLR start xmlparse_key
 * OracleDMLKeys.g:1570:1: xmlparse_key :{...}? => REGULAR_ID -> XMLPARSE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlparse_key_return
OracleDML_OracleDMLKeys::xmlparse_key()
{
    OracleDML_OracleDMLKeys::xmlparse_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID311 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID311_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1571:5: ({...}? => REGULAR_ID -> XMLPARSE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1571:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLPARSE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLPARSE\"" );
                    ex->set_ruleName( "xmlparse_key" );


            }

            REGULAR_ID311 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlparse_key8323);
            if  (this->hasException())
            {
                goto rulexmlparse_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID311);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1571:66: -> XMLPARSE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLPARSE_VK, REGULAR_ID311));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlparse_keyEx; /* Prevent compiler warnings */
    rulexmlparse_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlparse_key */

/**
 * $ANTLR start xmlelement_key
 * OracleDMLKeys.g:1574:1: xmlelement_key :{...}? => REGULAR_ID -> XMLELEMENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlelement_key_return
OracleDML_OracleDMLKeys::xmlelement_key()
{
    OracleDML_OracleDMLKeys::xmlelement_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID312 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID312_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1575:5: ({...}? => REGULAR_ID -> XMLELEMENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1575:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLELEMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLELEMENT\"" );
                    ex->set_ruleName( "xmlelement_key" );


            }

            REGULAR_ID312 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlelement_key8351);
            if  (this->hasException())
            {
                goto rulexmlelement_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID312);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1575:68: -> XMLELEMENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLELEMENT_VK, REGULAR_ID312));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlelement_keyEx; /* Prevent compiler warnings */
    rulexmlelement_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlelement_key */

/**
 * $ANTLR start entityescaping_key
 * OracleDMLKeys.g:1578:1: entityescaping_key :{...}? => REGULAR_ID -> ENTITYESCAPING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::entityescaping_key_return
OracleDML_OracleDMLKeys::entityescaping_key()
{
    OracleDML_OracleDMLKeys::entityescaping_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID313 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID313_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1579:5: ({...}? => REGULAR_ID -> ENTITYESCAPING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1579:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ENTITYESCAPING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ENTITYESCAPING\"" );
                    ex->set_ruleName( "entityescaping_key" );


            }

            REGULAR_ID313 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_entityescaping_key8379);
            if  (this->hasException())
            {
                goto ruleentityescaping_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID313);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1579:72: -> ENTITYESCAPING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ENTITYESCAPING_VK, REGULAR_ID313));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleentityescaping_keyEx; /* Prevent compiler warnings */
    ruleentityescaping_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end entityescaping_key */

/**
 * $ANTLR start standalone_key
 * OracleDMLKeys.g:1582:1: standalone_key :{...}? => REGULAR_ID -> STANDALONE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::standalone_key_return
OracleDML_OracleDMLKeys::standalone_key()
{
    OracleDML_OracleDMLKeys::standalone_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID314 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID314_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1583:5: ({...}? => REGULAR_ID -> STANDALONE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1583:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "STANDALONE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STANDALONE\"" );
                    ex->set_ruleName( "standalone_key" );


            }

            REGULAR_ID314 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_standalone_key8407);
            if  (this->hasException())
            {
                goto rulestandalone_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID314);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1583:68: -> STANDALONE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(STANDALONE_VK, REGULAR_ID314));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestandalone_keyEx; /* Prevent compiler warnings */
    rulestandalone_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end standalone_key */

/**
 * $ANTLR start wellformed_key
 * OracleDMLKeys.g:1586:1: wellformed_key :{...}? => REGULAR_ID -> WELLFORMED_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::wellformed_key_return
OracleDML_OracleDMLKeys::wellformed_key()
{
    OracleDML_OracleDMLKeys::wellformed_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID315 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID315_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1587:5: ({...}? => REGULAR_ID -> WELLFORMED_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1587:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "WELLFORMED")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WELLFORMED\"" );
                    ex->set_ruleName( "wellformed_key" );


            }

            REGULAR_ID315 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_wellformed_key8435);
            if  (this->hasException())
            {
                goto rulewellformed_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID315);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1587:68: -> WELLFORMED_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(WELLFORMED_VK, REGULAR_ID315));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewellformed_keyEx; /* Prevent compiler warnings */
    rulewellformed_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end wellformed_key */

/**
 * $ANTLR start xmlexists_key
 * OracleDMLKeys.g:1590:1: xmlexists_key :{...}? => REGULAR_ID -> XMLEXISTS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlexists_key_return
OracleDML_OracleDMLKeys::xmlexists_key()
{
    OracleDML_OracleDMLKeys::xmlexists_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID316 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID316_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1591:5: ({...}? => REGULAR_ID -> XMLEXISTS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1591:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLEXISTS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLEXISTS\"" );
                    ex->set_ruleName( "xmlexists_key" );


            }

            REGULAR_ID316 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlexists_key8463);
            if  (this->hasException())
            {
                goto rulexmlexists_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID316);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1591:67: -> XMLEXISTS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLEXISTS_VK, REGULAR_ID316));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlexists_keyEx; /* Prevent compiler warnings */
    rulexmlexists_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlexists_key */

/**
 * $ANTLR start version_key
 * OracleDMLKeys.g:1594:1: version_key :{...}? => REGULAR_ID -> VERSION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::version_key_return
OracleDML_OracleDMLKeys::version_key()
{
    OracleDML_OracleDMLKeys::version_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID317 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID317_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1595:5: ({...}? => REGULAR_ID -> VERSION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1595:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "VERSION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VERSION\"" );
                    ex->set_ruleName( "version_key" );


            }

            REGULAR_ID317 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_version_key8491);
            if  (this->hasException())
            {
                goto ruleversion_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID317);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1595:65: -> VERSION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(VERSION_VK, REGULAR_ID317));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleversion_keyEx; /* Prevent compiler warnings */
    ruleversion_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end version_key */

/**
 * $ANTLR start xmlcast_key
 * OracleDMLKeys.g:1598:1: xmlcast_key :{...}? => REGULAR_ID -> XMLCAST_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlcast_key_return
OracleDML_OracleDMLKeys::xmlcast_key()
{
    OracleDML_OracleDMLKeys::xmlcast_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID318 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID318_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1599:5: ({...}? => REGULAR_ID -> XMLCAST_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1599:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLCAST")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLCAST\"" );
                    ex->set_ruleName( "xmlcast_key" );


            }

            REGULAR_ID318 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlcast_key8519);
            if  (this->hasException())
            {
                goto rulexmlcast_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID318);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1599:65: -> XMLCAST_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLCAST_VK, REGULAR_ID318));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlcast_keyEx; /* Prevent compiler warnings */
    rulexmlcast_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlcast_key */

/**
 * $ANTLR start yes_key
 * OracleDMLKeys.g:1602:1: yes_key :{...}? => REGULAR_ID -> YES_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::yes_key_return
OracleDML_OracleDMLKeys::yes_key()
{
    OracleDML_OracleDMLKeys::yes_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID319 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID319_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1603:5: ({...}? => REGULAR_ID -> YES_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1603:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "YES")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"YES\"" );
                    ex->set_ruleName( "yes_key" );


            }

            REGULAR_ID319 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_yes_key8547);
            if  (this->hasException())
            {
                goto ruleyes_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID319);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1603:61: -> YES_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(YES_VK, REGULAR_ID319));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleyes_keyEx; /* Prevent compiler warnings */
    ruleyes_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end yes_key */

/**
 * $ANTLR start no_key
 * OracleDMLKeys.g:1606:1: no_key :{...}? => REGULAR_ID -> NO_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::no_key_return
OracleDML_OracleDMLKeys::no_key()
{
    OracleDML_OracleDMLKeys::no_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID320 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID320_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1607:5: ({...}? => REGULAR_ID -> NO_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1607:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NO")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NO\"" );
                    ex->set_ruleName( "no_key" );


            }

            REGULAR_ID320 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_no_key8575);
            if  (this->hasException())
            {
                goto ruleno_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID320);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1607:60: -> NO_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NO_VK, REGULAR_ID320));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleno_keyEx; /* Prevent compiler warnings */
    ruleno_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end no_key */

/**
 * $ANTLR start evalname_key
 * OracleDMLKeys.g:1610:1: evalname_key :{...}? => REGULAR_ID -> EVALNAME_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::evalname_key_return
OracleDML_OracleDMLKeys::evalname_key()
{
    OracleDML_OracleDMLKeys::evalname_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID321 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID321_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1611:5: ({...}? => REGULAR_ID -> EVALNAME_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1611:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EVALNAME")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EVALNAME\"" );
                    ex->set_ruleName( "evalname_key" );


            }

            REGULAR_ID321 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_evalname_key8603);
            if  (this->hasException())
            {
                goto ruleevalname_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID321);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1611:66: -> EVALNAME_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EVALNAME_VK, REGULAR_ID321));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleevalname_keyEx; /* Prevent compiler warnings */
    ruleevalname_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end evalname_key */

/**
 * $ANTLR start xmlpi_key
 * OracleDMLKeys.g:1614:1: xmlpi_key :{...}? => REGULAR_ID -> XMLPI_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlpi_key_return
OracleDML_OracleDMLKeys::xmlpi_key()
{
    OracleDML_OracleDMLKeys::xmlpi_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID322 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID322_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1615:5: ({...}? => REGULAR_ID -> XMLPI_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1615:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLPI")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLPI\"" );
                    ex->set_ruleName( "xmlpi_key" );


            }

            REGULAR_ID322 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlpi_key8631);
            if  (this->hasException())
            {
                goto rulexmlpi_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID322);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1615:63: -> XMLPI_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLPI_VK, REGULAR_ID322));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlpi_keyEx; /* Prevent compiler warnings */
    rulexmlpi_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlpi_key */

/**
 * $ANTLR start xmlcolattval_key
 * OracleDMLKeys.g:1618:1: xmlcolattval_key :{...}? => REGULAR_ID -> XMLCOLATTVAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlcolattval_key_return
OracleDML_OracleDMLKeys::xmlcolattval_key()
{
    OracleDML_OracleDMLKeys::xmlcolattval_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID323 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID323_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1619:5: ({...}? => REGULAR_ID -> XMLCOLATTVAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1619:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLCOLATTVAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLCOLATTVAL\"" );
                    ex->set_ruleName( "xmlcolattval_key" );


            }

            REGULAR_ID323 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlcolattval_key8659);
            if  (this->hasException())
            {
                goto rulexmlcolattval_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID323);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1619:70: -> XMLCOLATTVAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLCOLATTVAL_VK, REGULAR_ID323));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlcolattval_keyEx; /* Prevent compiler warnings */
    rulexmlcolattval_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlcolattval_key */

/**
 * $ANTLR start document_key
 * OracleDMLKeys.g:1622:1: document_key :{...}? => REGULAR_ID -> DOCUMENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::document_key_return
OracleDML_OracleDMLKeys::document_key()
{
    OracleDML_OracleDMLKeys::document_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID324 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID324_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1623:5: ({...}? => REGULAR_ID -> DOCUMENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1623:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DOCUMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DOCUMENT\"" );
                    ex->set_ruleName( "document_key" );


            }

            REGULAR_ID324 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_document_key8687);
            if  (this->hasException())
            {
                goto ruledocument_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID324);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1623:66: -> DOCUMENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DOCUMENT_VK, REGULAR_ID324));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledocument_keyEx; /* Prevent compiler warnings */
    ruledocument_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end document_key */

/**
 * $ANTLR start xmlforest_key
 * OracleDMLKeys.g:1626:1: xmlforest_key :{...}? => REGULAR_ID -> XMLFOREST_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlforest_key_return
OracleDML_OracleDMLKeys::xmlforest_key()
{
    OracleDML_OracleDMLKeys::xmlforest_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID325 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID325_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1627:5: ({...}? => REGULAR_ID -> XMLFOREST_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1627:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLFOREST")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLFOREST\"" );
                    ex->set_ruleName( "xmlforest_key" );


            }

            REGULAR_ID325 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlforest_key8715);
            if  (this->hasException())
            {
                goto rulexmlforest_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID325);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1627:67: -> XMLFOREST_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLFOREST_VK, REGULAR_ID325));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlforest_keyEx; /* Prevent compiler warnings */
    rulexmlforest_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlforest_key */

/**
 * $ANTLR start passing_key
 * OracleDMLKeys.g:1630:1: passing_key :{...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::passing_key_return
OracleDML_OracleDMLKeys::passing_key()
{
    OracleDML_OracleDMLKeys::passing_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID326 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID326_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1631:5: ({...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1631:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PASSING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PASSING\"" );
                    ex->set_ruleName( "passing_key" );


            }

            REGULAR_ID326 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_passing_key8743);
            if  (this->hasException())
            {
                goto rulepassing_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID326);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1631:65: -> PASSING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PASSING_VK, REGULAR_ID326));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepassing_keyEx; /* Prevent compiler warnings */
    rulepassing_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end passing_key */

/**
 * $ANTLR start columns_key
 * OracleDMLKeys.g:1634:1: columns_key :{...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::columns_key_return
OracleDML_OracleDMLKeys::columns_key()
{
    OracleDML_OracleDMLKeys::columns_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID327 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID327_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1635:5: ({...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1635:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COLUMNS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COLUMNS\"" );
                    ex->set_ruleName( "columns_key" );


            }

            REGULAR_ID327 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_columns_key8771);
            if  (this->hasException())
            {
                goto rulecolumns_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID327);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1635:65: -> PASSING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PASSING_VK, REGULAR_ID327));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecolumns_keyEx; /* Prevent compiler warnings */
    rulecolumns_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end columns_key */

/**
 * $ANTLR start indent_key
 * OracleDMLKeys.g:1638:1: indent_key :{...}? => REGULAR_ID -> INDENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::indent_key_return
OracleDML_OracleDMLKeys::indent_key()
{
    OracleDML_OracleDMLKeys::indent_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID328 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID328_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1639:5: ({...}? => REGULAR_ID -> INDENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1639:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INDENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INDENT\"" );
                    ex->set_ruleName( "indent_key" );


            }

            REGULAR_ID328 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indent_key8800);
            if  (this->hasException())
            {
                goto ruleindent_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID328);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1639:64: -> INDENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INDENT_VK, REGULAR_ID328));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleindent_keyEx; /* Prevent compiler warnings */
    ruleindent_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end indent_key */

/**
 * $ANTLR start hide_key
 * OracleDMLKeys.g:1642:1: hide_key :{...}? => REGULAR_ID -> HIDE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::hide_key_return
OracleDML_OracleDMLKeys::hide_key()
{
    OracleDML_OracleDMLKeys::hide_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID329 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID329_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1643:5: ({...}? => REGULAR_ID -> HIDE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1643:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "HIDE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"HIDE\"" );
                    ex->set_ruleName( "hide_key" );


            }

            REGULAR_ID329 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hide_key8828);
            if  (this->hasException())
            {
                goto rulehide_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID329);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1643:62: -> HIDE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(HIDE_VK, REGULAR_ID329));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulehide_keyEx; /* Prevent compiler warnings */
    rulehide_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end hide_key */

/**
 * $ANTLR start xmlagg_key
 * OracleDMLKeys.g:1646:1: xmlagg_key :{...}? => REGULAR_ID -> XMLAGG_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlagg_key_return
OracleDML_OracleDMLKeys::xmlagg_key()
{
    OracleDML_OracleDMLKeys::xmlagg_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID330 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID330_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1647:5: ({...}? => REGULAR_ID -> XMLAGG_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1647:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLAGG")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLAGG\"" );
                    ex->set_ruleName( "xmlagg_key" );


            }

            REGULAR_ID330 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlagg_key8856);
            if  (this->hasException())
            {
                goto rulexmlagg_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID330);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1647:64: -> XMLAGG_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLAGG_VK, REGULAR_ID330));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlagg_keyEx; /* Prevent compiler warnings */
    rulexmlagg_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlagg_key */

/**
 * $ANTLR start path_key
 * OracleDMLKeys.g:1650:1: path_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::path_key_return
OracleDML_OracleDMLKeys::path_key()
{
    OracleDML_OracleDMLKeys::path_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID331 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID331_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1651:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1651:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "PATH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PATH\"" );
                    ex->set_ruleName( "path_key" );


            }

            REGULAR_ID331 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_path_key8884);
            if  (this->hasException())
            {
                goto rulepath_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID331_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID331));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID331_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepath_keyEx; /* Prevent compiler warnings */
    rulepath_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end path_key */

/**
 * $ANTLR start xmlnamespaces_key
 * OracleDMLKeys.g:1654:1: xmlnamespaces_key :{...}? => REGULAR_ID -> XMLNAMESPACES_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlnamespaces_key_return
OracleDML_OracleDMLKeys::xmlnamespaces_key()
{
    OracleDML_OracleDMLKeys::xmlnamespaces_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID332 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID332_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1655:5: ({...}? => REGULAR_ID -> XMLNAMESPACES_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1655:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLNAMESPACES")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLNAMESPACES\"" );
                    ex->set_ruleName( "xmlnamespaces_key" );


            }

            REGULAR_ID332 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlnamespaces_key8907);
            if  (this->hasException())
            {
                goto rulexmlnamespaces_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID332);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1655:71: -> XMLNAMESPACES_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLNAMESPACES_VK, REGULAR_ID332));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlnamespaces_keyEx; /* Prevent compiler warnings */
    rulexmlnamespaces_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlnamespaces_key */

/**
 * $ANTLR start size_key
 * OracleDMLKeys.g:1658:1: size_key : SQL92_RESERVED_SIZE ;
 */
OracleDML_OracleDMLKeys::size_key_return
OracleDML_OracleDMLKeys::size_key()
{
    OracleDML_OracleDMLKeys::size_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_SIZE333 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_SIZE333_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1659:5: ( SQL92_RESERVED_SIZE )
        // OracleDMLKeys.g:1659:10: SQL92_RESERVED_SIZE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_SIZE333 =  this->matchToken(SQL92_RESERVED_SIZE, &FOLLOW_SQL92_RESERVED_SIZE_in_size_key8932);
            if  (this->hasException())
            {
                goto rulesize_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_SIZE333_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_SIZE333));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_SIZE333_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesize_keyEx; /* Prevent compiler warnings */
    rulesize_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end size_key */

/**
 * $ANTLR start noschemacheck_key
 * OracleDMLKeys.g:1662:1: noschemacheck_key :{...}? => REGULAR_ID -> NOSCHEMACHECK_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::noschemacheck_key_return
OracleDML_OracleDMLKeys::noschemacheck_key()
{
    OracleDML_OracleDMLKeys::noschemacheck_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID334 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID334_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1663:5: ({...}? => REGULAR_ID -> NOSCHEMACHECK_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1663:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOSCHEMACHECK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOSCHEMACHECK\"" );
                    ex->set_ruleName( "noschemacheck_key" );


            }

            REGULAR_ID334 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noschemacheck_key8955);
            if  (this->hasException())
            {
                goto rulenoschemacheck_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID334);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1663:71: -> NOSCHEMACHECK_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOSCHEMACHECK_VK, REGULAR_ID334));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenoschemacheck_keyEx; /* Prevent compiler warnings */
    rulenoschemacheck_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end noschemacheck_key */

/**
 * $ANTLR start noentityescaping_key
 * OracleDMLKeys.g:1666:1: noentityescaping_key :{...}? => REGULAR_ID -> NOENTITYESCAPING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::noentityescaping_key_return
OracleDML_OracleDMLKeys::noentityescaping_key()
{
    OracleDML_OracleDMLKeys::noentityescaping_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID335 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID335_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1667:5: ({...}? => REGULAR_ID -> NOENTITYESCAPING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1667:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOENTITYESCAPING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOENTITYESCAPING\"" );
                    ex->set_ruleName( "noentityescaping_key" );


            }

            REGULAR_ID335 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noentityescaping_key8983);
            if  (this->hasException())
            {
                goto rulenoentityescaping_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID335);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1667:74: -> NOENTITYESCAPING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOENTITYESCAPING_VK, REGULAR_ID335));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenoentityescaping_keyEx; /* Prevent compiler warnings */
    rulenoentityescaping_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end noentityescaping_key */

/**
 * $ANTLR start xmlquery_key
 * OracleDMLKeys.g:1670:1: xmlquery_key :{...}? => REGULAR_ID -> XMLQUERY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlquery_key_return
OracleDML_OracleDMLKeys::xmlquery_key()
{
    OracleDML_OracleDMLKeys::xmlquery_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID336 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID336_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1671:5: ({...}? => REGULAR_ID -> XMLQUERY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1671:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLQUERY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLQUERY\"" );
                    ex->set_ruleName( "xmlquery_key" );


            }

            REGULAR_ID336 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlquery_key9011);
            if  (this->hasException())
            {
                goto rulexmlquery_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID336);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1671:66: -> XMLQUERY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLQUERY_VK, REGULAR_ID336));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlquery_keyEx; /* Prevent compiler warnings */
    rulexmlquery_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlquery_key */

/**
 * $ANTLR start xmltable_key
 * OracleDMLKeys.g:1674:1: xmltable_key :{...}? => REGULAR_ID -> XMLTABLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmltable_key_return
OracleDML_OracleDMLKeys::xmltable_key()
{
    OracleDML_OracleDMLKeys::xmltable_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID337 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID337_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1675:5: ({...}? => REGULAR_ID -> XMLTABLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1675:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLTABLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLTABLE\"" );
                    ex->set_ruleName( "xmltable_key" );


            }

            REGULAR_ID337 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmltable_key9039);
            if  (this->hasException())
            {
                goto rulexmltable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID337);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1675:66: -> XMLTABLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLTABLE_VK, REGULAR_ID337));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmltable_keyEx; /* Prevent compiler warnings */
    rulexmltable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmltable_key */

/**
 * $ANTLR start xmlroot_key
 * OracleDMLKeys.g:1678:1: xmlroot_key :{...}? => REGULAR_ID -> XMLROOT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlroot_key_return
OracleDML_OracleDMLKeys::xmlroot_key()
{
    OracleDML_OracleDMLKeys::xmlroot_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID338 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID338_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1679:5: ({...}? => REGULAR_ID -> XMLROOT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1679:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLROOT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLROOT\"" );
                    ex->set_ruleName( "xmlroot_key" );


            }

            REGULAR_ID338 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlroot_key9067);
            if  (this->hasException())
            {
                goto rulexmlroot_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID338);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1679:65: -> XMLROOT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLROOT_VK, REGULAR_ID338));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlroot_keyEx; /* Prevent compiler warnings */
    rulexmlroot_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlroot_key */

/**
 * $ANTLR start schemacheck_key
 * OracleDMLKeys.g:1682:1: schemacheck_key :{...}? => REGULAR_ID -> SCHEMACHECK_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::schemacheck_key_return
OracleDML_OracleDMLKeys::schemacheck_key()
{
    OracleDML_OracleDMLKeys::schemacheck_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID339 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID339_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1683:5: ({...}? => REGULAR_ID -> SCHEMACHECK_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1683:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SCHEMACHECK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SCHEMACHECK\"" );
                    ex->set_ruleName( "schemacheck_key" );


            }

            REGULAR_ID339 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_schemacheck_key9095);
            if  (this->hasException())
            {
                goto ruleschemacheck_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID339);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1683:69: -> SCHEMACHECK_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SCHEMACHECK_VK, REGULAR_ID339));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleschemacheck_keyEx; /* Prevent compiler warnings */
    ruleschemacheck_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end schemacheck_key */

/**
 * $ANTLR start xmlattributes_key
 * OracleDMLKeys.g:1686:1: xmlattributes_key :{...}? => REGULAR_ID -> XMLATTRIBUTES_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlattributes_key_return
OracleDML_OracleDMLKeys::xmlattributes_key()
{
    OracleDML_OracleDMLKeys::xmlattributes_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID340 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID340_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1687:5: ({...}? => REGULAR_ID -> XMLATTRIBUTES_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1687:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLATTRIBUTES")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLATTRIBUTES\"" );
                    ex->set_ruleName( "xmlattributes_key" );


            }

            REGULAR_ID340 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlattributes_key9123);
            if  (this->hasException())
            {
                goto rulexmlattributes_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID340);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1687:71: -> XMLATTRIBUTES_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLATTRIBUTES_VK, REGULAR_ID340));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlattributes_keyEx; /* Prevent compiler warnings */
    rulexmlattributes_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlattributes_key */

/**
 * $ANTLR start encoding_key
 * OracleDMLKeys.g:1690:1: encoding_key :{...}? => REGULAR_ID -> ENCODING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::encoding_key_return
OracleDML_OracleDMLKeys::encoding_key()
{
    OracleDML_OracleDMLKeys::encoding_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID341 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID341_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1691:5: ({...}? => REGULAR_ID -> ENCODING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1691:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ENCODING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ENCODING\"" );
                    ex->set_ruleName( "encoding_key" );


            }

            REGULAR_ID341 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_encoding_key9151);
            if  (this->hasException())
            {
                goto ruleencoding_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID341);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1691:66: -> ENCODING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ENCODING_VK, REGULAR_ID341));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleencoding_keyEx; /* Prevent compiler warnings */
    ruleencoding_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end encoding_key */

/**
 * $ANTLR start show_key
 * OracleDMLKeys.g:1694:1: show_key :{...}? => REGULAR_ID -> SHOW_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::show_key_return
OracleDML_OracleDMLKeys::show_key()
{
    OracleDML_OracleDMLKeys::show_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID342 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID342_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1695:5: ({...}? => REGULAR_ID -> SHOW_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1695:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SHOW")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SHOW\"" );
                    ex->set_ruleName( "show_key" );


            }

            REGULAR_ID342 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_show_key9179);
            if  (this->hasException())
            {
                goto ruleshow_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID342);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1695:62: -> SHOW_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SHOW_VK, REGULAR_ID342));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleshow_keyEx; /* Prevent compiler warnings */
    ruleshow_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end show_key */

/**
 * $ANTLR start xmlserialize_key
 * OracleDMLKeys.g:1698:1: xmlserialize_key :{...}? => REGULAR_ID -> XMLSERIALIZE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::xmlserialize_key_return
OracleDML_OracleDMLKeys::xmlserialize_key()
{
    OracleDML_OracleDMLKeys::xmlserialize_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID343 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID343_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1699:5: ({...}? => REGULAR_ID -> XMLSERIALIZE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1699:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "XMLSERIALIZE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"XMLSERIALIZE\"" );
                    ex->set_ruleName( "xmlserialize_key" );


            }

            REGULAR_ID343 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlserialize_key9207);
            if  (this->hasException())
            {
                goto rulexmlserialize_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID343);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1699:70: -> XMLSERIALIZE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(XMLSERIALIZE_VK, REGULAR_ID343));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_keyEx; /* Prevent compiler warnings */
    rulexmlserialize_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlserialize_key */

/**
 * $ANTLR start ordinality_key
 * OracleDMLKeys.g:1702:1: ordinality_key :{...}? => REGULAR_ID -> ORDINALITY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::ordinality_key_return
OracleDML_OracleDMLKeys::ordinality_key()
{
    OracleDML_OracleDMLKeys::ordinality_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID344 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID344_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1703:5: ({...}? => REGULAR_ID -> ORDINALITY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1703:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ORDINALITY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ORDINALITY\"" );
                    ex->set_ruleName( "ordinality_key" );


            }

            REGULAR_ID344 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ordinality_key9235);
            if  (this->hasException())
            {
                goto ruleordinality_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID344);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1703:68: -> ORDINALITY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ORDINALITY_VK, REGULAR_ID344));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleordinality_keyEx; /* Prevent compiler warnings */
    ruleordinality_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end ordinality_key */

/**
 * $ANTLR start defaults_key
 * OracleDMLKeys.g:1706:1: defaults_key :{...}? => REGULAR_ID -> DEFAULTS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::defaults_key_return
OracleDML_OracleDMLKeys::defaults_key()
{
    OracleDML_OracleDMLKeys::defaults_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID345 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID345_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1707:5: ({...}? => REGULAR_ID -> DEFAULTS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1707:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DEFAULTS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DEFAULTS\"" );
                    ex->set_ruleName( "defaults_key" );


            }

            REGULAR_ID345 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_defaults_key9263);
            if  (this->hasException())
            {
                goto ruledefaults_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID345);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1707:66: -> DEFAULTS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DEFAULTS_VK, REGULAR_ID345));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledefaults_keyEx; /* Prevent compiler warnings */
    ruledefaults_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end defaults_key */

/**
 * $ANTLR start sqlerror_key
 * OracleDMLKeys.g:1710:1: sqlerror_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::sqlerror_key_return
OracleDML_OracleDMLKeys::sqlerror_key()
{
    OracleDML_OracleDMLKeys::sqlerror_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID346 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID346_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1711:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1711:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SQLERROR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SQLERROR\"" );
                    ex->set_ruleName( "sqlerror_key" );


            }

            REGULAR_ID346 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqlerror_key9290);
            if  (this->hasException())
            {
                goto rulesqlerror_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID346_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID346));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID346_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesqlerror_keyEx; /* Prevent compiler warnings */
    rulesqlerror_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sqlerror_key */

/**
 * $ANTLR start oserror_key
 * OracleDMLKeys.g:1714:1: oserror_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::oserror_key_return
OracleDML_OracleDMLKeys::oserror_key()
{
    OracleDML_OracleDMLKeys::oserror_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID347 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID347_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1715:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1715:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "OSERROR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OSERROR\"" );
                    ex->set_ruleName( "oserror_key" );


            }

            REGULAR_ID347 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oserror_key9314);
            if  (this->hasException())
            {
                goto ruleoserror_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID347_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID347));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID347_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleoserror_keyEx; /* Prevent compiler warnings */
    ruleoserror_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end oserror_key */

/**
 * $ANTLR start success_key
 * OracleDMLKeys.g:1718:1: success_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::success_key_return
OracleDML_OracleDMLKeys::success_key()
{
    OracleDML_OracleDMLKeys::success_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID348 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID348_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1719:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1719:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SUCCESS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUCCESS\"" );
                    ex->set_ruleName( "success_key" );


            }

            REGULAR_ID348 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_success_key9337);
            if  (this->hasException())
            {
                goto rulesuccess_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID348_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID348));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID348_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesuccess_keyEx; /* Prevent compiler warnings */
    rulesuccess_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end success_key */

/**
 * $ANTLR start warning_key
 * OracleDMLKeys.g:1722:1: warning_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::warning_key_return
OracleDML_OracleDMLKeys::warning_key()
{
    OracleDML_OracleDMLKeys::warning_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID349 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID349_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1723:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1723:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "WARNING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WARNING\"" );
                    ex->set_ruleName( "warning_key" );


            }

            REGULAR_ID349 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_warning_key9360);
            if  (this->hasException())
            {
                goto rulewarning_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID349_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID349));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID349_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewarning_keyEx; /* Prevent compiler warnings */
    rulewarning_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end warning_key */

/**
 * $ANTLR start failure_key
 * OracleDMLKeys.g:1726:1: failure_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::failure_key_return
OracleDML_OracleDMLKeys::failure_key()
{
    OracleDML_OracleDMLKeys::failure_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID350 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID350_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1727:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1727:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "FAILURE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FAILURE\"" );
                    ex->set_ruleName( "failure_key" );


            }

            REGULAR_ID350 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_failure_key9383);
            if  (this->hasException())
            {
                goto rulefailure_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID350_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID350));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID350_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefailure_keyEx; /* Prevent compiler warnings */
    rulefailure_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end failure_key */

/**
 * $ANTLR start insert_key
 * OracleDMLKeys.g:1730:1: insert_key : SQL92_RESERVED_INSERT ;
 */
OracleDML_OracleDMLKeys::insert_key_return
OracleDML_OracleDMLKeys::insert_key()
{
    OracleDML_OracleDMLKeys::insert_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_INSERT351 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_INSERT351_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1731:5: ( SQL92_RESERVED_INSERT )
        // OracleDMLKeys.g:1731:10: SQL92_RESERVED_INSERT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_INSERT351 =  this->matchToken(SQL92_RESERVED_INSERT, &FOLLOW_SQL92_RESERVED_INSERT_in_insert_key9404);
            if  (this->hasException())
            {
                goto ruleinsert_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_INSERT351_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_INSERT351));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_INSERT351_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinsert_keyEx; /* Prevent compiler warnings */
    ruleinsert_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end insert_key */

/**
 * $ANTLR start order_key
 * OracleDMLKeys.g:1734:1: order_key : SQL92_RESERVED_ORDER ;
 */
OracleDML_OracleDMLKeys::order_key_return
OracleDML_OracleDMLKeys::order_key()
{
    OracleDML_OracleDMLKeys::order_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_ORDER352 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_ORDER352_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1735:5: ( SQL92_RESERVED_ORDER )
        // OracleDMLKeys.g:1735:10: SQL92_RESERVED_ORDER
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_ORDER352 =  this->matchToken(SQL92_RESERVED_ORDER, &FOLLOW_SQL92_RESERVED_ORDER_in_order_key9424);
            if  (this->hasException())
            {
                goto ruleorder_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_ORDER352_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_ORDER352));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_ORDER352_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleorder_keyEx; /* Prevent compiler warnings */
    ruleorder_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end order_key */

/**
 * $ANTLR start minus_key
 * OracleDMLKeys.g:1738:1: minus_key : PLSQL_RESERVED_MINUS ;
 */
OracleDML_OracleDMLKeys::minus_key_return
OracleDML_OracleDMLKeys::minus_key()
{
    OracleDML_OracleDMLKeys::minus_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_MINUS353 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_MINUS353_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1739:5: ( PLSQL_RESERVED_MINUS )
        // OracleDMLKeys.g:1739:10: PLSQL_RESERVED_MINUS
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_MINUS353 =  this->matchToken(PLSQL_RESERVED_MINUS, &FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key9444);
            if  (this->hasException())
            {
                goto ruleminus_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_MINUS353_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_MINUS353));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_MINUS353_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleminus_keyEx; /* Prevent compiler warnings */
    ruleminus_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end minus_key */

/**
 * $ANTLR start row_key
 * OracleDMLKeys.g:1742:1: row_key :{...}? REGULAR_ID -> ROW_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::row_key_return
OracleDML_OracleDMLKeys::row_key()
{
    OracleDML_OracleDMLKeys::row_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID354 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID354_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1743:5: ({...}? REGULAR_ID -> ROW_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1743:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ROW")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROW\"" );
                    ex->set_ruleName( "row_key" );


            }

            REGULAR_ID354 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_row_key9466);
            if  (this->hasException())
            {
                goto rulerow_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID354);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1743:59: -> ROW_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ROW_VK, REGULAR_ID354));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerow_keyEx; /* Prevent compiler warnings */
    rulerow_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end row_key */

/**
 * $ANTLR start mod_key
 * OracleDMLKeys.g:1746:1: mod_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::mod_key_return
OracleDML_OracleDMLKeys::mod_key()
{
    OracleDML_OracleDMLKeys::mod_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID355 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID355_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1747:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1747:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "MOD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MOD\"" );
                    ex->set_ruleName( "mod_key" );


            }

            REGULAR_ID355 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_mod_key9493);
            if  (this->hasException())
            {
                goto rulemod_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID355_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID355));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID355_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemod_keyEx; /* Prevent compiler warnings */
    rulemod_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end mod_key */

/**
 * $ANTLR start raw_key
 * OracleDMLKeys.g:1750:1: raw_key :{...}? => REGULAR_ID -> RAW_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::raw_key_return
OracleDML_OracleDMLKeys::raw_key()
{
    OracleDML_OracleDMLKeys::raw_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID356 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID356_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1751:5: ({...}? => REGULAR_ID -> RAW_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1751:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RAW")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RAW\"" );
                    ex->set_ruleName( "raw_key" );


            }

            REGULAR_ID356 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_raw_key9516);
            if  (this->hasException())
            {
                goto ruleraw_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID356);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1751:61: -> RAW_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RAW_VK, REGULAR_ID356));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleraw_keyEx; /* Prevent compiler warnings */
    ruleraw_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end raw_key */

/**
 * $ANTLR start power_key
 * OracleDMLKeys.g:1754:1: power_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::power_key_return
OracleDML_OracleDMLKeys::power_key()
{
    OracleDML_OracleDMLKeys::power_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID357 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID357_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1755:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1755:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "POWER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"POWER\"" );
                    ex->set_ruleName( "power_key" );


            }

            REGULAR_ID357 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_power_key9543);
            if  (this->hasException())
            {
                goto rulepower_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID357_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID357));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID357_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepower_keyEx; /* Prevent compiler warnings */
    rulepower_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end power_key */

/**
 * $ANTLR start lock_key
 * OracleDMLKeys.g:1758:1: lock_key : PLSQL_RESERVED_LOCK ;
 */
OracleDML_OracleDMLKeys::lock_key_return
OracleDML_OracleDMLKeys::lock_key()
{
    OracleDML_OracleDMLKeys::lock_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_LOCK358 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_LOCK358_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1759:5: ( PLSQL_RESERVED_LOCK )
        // OracleDMLKeys.g:1759:10: PLSQL_RESERVED_LOCK
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_LOCK358 =  this->matchToken(PLSQL_RESERVED_LOCK, &FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key9563);
            if  (this->hasException())
            {
                goto rulelock_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_LOCK358_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_LOCK358));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_LOCK358_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelock_keyEx; /* Prevent compiler warnings */
    rulelock_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end lock_key */

/**
 * $ANTLR start exists_key
 * OracleDMLKeys.g:1762:1: exists_key : SQL92_RESERVED_EXISTS ;
 */
OracleDML_OracleDMLKeys::exists_key_return
OracleDML_OracleDMLKeys::exists_key()
{
    OracleDML_OracleDMLKeys::exists_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_EXISTS359 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_EXISTS359_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1763:5: ( SQL92_RESERVED_EXISTS )
        // OracleDMLKeys.g:1763:10: SQL92_RESERVED_EXISTS
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_EXISTS359 =  this->matchToken(SQL92_RESERVED_EXISTS, &FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key9583);
            if  (this->hasException())
            {
                goto ruleexists_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_EXISTS359_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_EXISTS359));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_EXISTS359_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexists_keyEx; /* Prevent compiler warnings */
    ruleexists_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exists_key */

/**
 * $ANTLR start having_key
 * OracleDMLKeys.g:1766:1: having_key : SQL92_RESERVED_HAVING ;
 */
OracleDML_OracleDMLKeys::having_key_return
OracleDML_OracleDMLKeys::having_key()
{
    OracleDML_OracleDMLKeys::having_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_HAVING360 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_HAVING360_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1767:5: ( SQL92_RESERVED_HAVING )
        // OracleDMLKeys.g:1767:10: SQL92_RESERVED_HAVING
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_HAVING360 =  this->matchToken(SQL92_RESERVED_HAVING, &FOLLOW_SQL92_RESERVED_HAVING_in_having_key9603);
            if  (this->hasException())
            {
                goto rulehaving_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_HAVING360_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_HAVING360));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_HAVING360_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulehaving_keyEx; /* Prevent compiler warnings */
    rulehaving_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end having_key */

/**
 * $ANTLR start any_key
 * OracleDMLKeys.g:1770:1: any_key : SQL92_RESERVED_ANY ;
 */
OracleDML_OracleDMLKeys::any_key_return
OracleDML_OracleDMLKeys::any_key()
{
    OracleDML_OracleDMLKeys::any_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_ANY361 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_ANY361_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1771:5: ( SQL92_RESERVED_ANY )
        // OracleDMLKeys.g:1771:10: SQL92_RESERVED_ANY
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_ANY361 =  this->matchToken(SQL92_RESERVED_ANY, &FOLLOW_SQL92_RESERVED_ANY_in_any_key9623);
            if  (this->hasException())
            {
                goto ruleany_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_ANY361_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_ANY361));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_ANY361_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleany_keyEx; /* Prevent compiler warnings */
    ruleany_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end any_key */

/**
 * $ANTLR start with_key
 * OracleDMLKeys.g:1774:1: with_key : SQL92_RESERVED_WITH ;
 */
OracleDML_OracleDMLKeys::with_key_return
OracleDML_OracleDMLKeys::with_key()
{
    OracleDML_OracleDMLKeys::with_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_WITH362 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_WITH362_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1775:5: ( SQL92_RESERVED_WITH )
        // OracleDMLKeys.g:1775:10: SQL92_RESERVED_WITH
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_WITH362 =  this->matchToken(SQL92_RESERVED_WITH, &FOLLOW_SQL92_RESERVED_WITH_in_with_key9643);
            if  (this->hasException())
            {
                goto rulewith_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_WITH362_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_WITH362));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_WITH362_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewith_keyEx; /* Prevent compiler warnings */
    rulewith_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end with_key */

/**
 * $ANTLR start transaction_key
 * OracleDMLKeys.g:1778:1: transaction_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::transaction_key_return
OracleDML_OracleDMLKeys::transaction_key()
{
    OracleDML_OracleDMLKeys::transaction_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID363 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID363_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1779:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:1779:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "TRANSACTION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TRANSACTION\"" );
                    ex->set_ruleName( "transaction_key" );


            }

            REGULAR_ID363 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_transaction_key9666);
            if  (this->hasException())
            {
                goto ruletransaction_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID363_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID363));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID363_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletransaction_keyEx; /* Prevent compiler warnings */
    ruletransaction_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end transaction_key */

/**
 * $ANTLR start rawtohex_key
 * OracleDMLKeys.g:1782:1: rawtohex_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::rawtohex_key_return
OracleDML_OracleDMLKeys::rawtohex_key()
{
    OracleDML_OracleDMLKeys::rawtohex_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID364 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID364_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1783:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1783:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "RAWTOHEX")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RAWTOHEX\"" );
                    ex->set_ruleName( "rawtohex_key" );


            }

            REGULAR_ID364 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rawtohex_key9688);
            if  (this->hasException())
            {
                goto rulerawtohex_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID364_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID364));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID364_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerawtohex_keyEx; /* Prevent compiler warnings */
    rulerawtohex_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rawtohex_key */

/**
 * $ANTLR start number_key
 * OracleDMLKeys.g:1786:1: number_key :{...}? => REGULAR_ID -> NUMBER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::number_key_return
OracleDML_OracleDMLKeys::number_key()
{
    OracleDML_OracleDMLKeys::number_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID365 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID365_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1787:5: ({...}? => REGULAR_ID -> NUMBER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1787:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NUMBER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NUMBER\"" );
                    ex->set_ruleName( "number_key" );


            }

            REGULAR_ID365 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_number_key9711);
            if  (this->hasException())
            {
                goto rulenumber_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID365);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1787:64: -> NUMBER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NUMBER_VK, REGULAR_ID365));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenumber_keyEx; /* Prevent compiler warnings */
    rulenumber_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end number_key */

/**
 * $ANTLR start nocopy_key
 * OracleDMLKeys.g:1790:1: nocopy_key :{...}? => REGULAR_ID -> NOCOPY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nocopy_key_return
OracleDML_OracleDMLKeys::nocopy_key()
{
    OracleDML_OracleDMLKeys::nocopy_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID366 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID366_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1791:5: ({...}? => REGULAR_ID -> NOCOPY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1791:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOCOPY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOCOPY\"" );
                    ex->set_ruleName( "nocopy_key" );


            }

            REGULAR_ID366 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocopy_key9739);
            if  (this->hasException())
            {
                goto rulenocopy_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID366);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1791:64: -> NOCOPY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOCOPY_VK, REGULAR_ID366));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenocopy_keyEx; /* Prevent compiler warnings */
    rulenocopy_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nocopy_key */

/**
 * $ANTLR start to_key
 * OracleDMLKeys.g:1794:1: to_key : SQL92_RESERVED_TO ;
 */
OracleDML_OracleDMLKeys::to_key_return
OracleDML_OracleDMLKeys::to_key()
{
    OracleDML_OracleDMLKeys::to_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_TO367 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_TO367_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1795:5: ( SQL92_RESERVED_TO )
        // OracleDMLKeys.g:1795:10: SQL92_RESERVED_TO
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_TO367 =  this->matchToken(SQL92_RESERVED_TO, &FOLLOW_SQL92_RESERVED_TO_in_to_key9764);
            if  (this->hasException())
            {
                goto ruleto_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_TO367_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_TO367));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_TO367_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleto_keyEx; /* Prevent compiler warnings */
    ruleto_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end to_key */

/**
 * $ANTLR start abs_key
 * OracleDMLKeys.g:1798:1: abs_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::abs_key_return
OracleDML_OracleDMLKeys::abs_key()
{
    OracleDML_OracleDMLKeys::abs_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID368 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID368_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1799:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1799:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ABS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ABS\"" );
                    ex->set_ruleName( "abs_key" );


            }

            REGULAR_ID368 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_abs_key9786);
            if  (this->hasException())
            {
                goto ruleabs_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID368_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID368));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID368_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleabs_keyEx; /* Prevent compiler warnings */
    ruleabs_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end abs_key */

/**
 * $ANTLR start rollback_key
 * OracleDMLKeys.g:1802:1: rollback_key :{...}? => REGULAR_ID -> ROLLBACK_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::rollback_key_return
OracleDML_OracleDMLKeys::rollback_key()
{
    OracleDML_OracleDMLKeys::rollback_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID369 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID369_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1803:5: ({...}? => REGULAR_ID -> ROLLBACK_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1803:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ROLLBACK")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROLLBACK\"" );
                    ex->set_ruleName( "rollback_key" );


            }

            REGULAR_ID369 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rollback_key9809);
            if  (this->hasException())
            {
                goto rulerollback_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID369);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1803:66: -> ROLLBACK_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ROLLBACK_VK, REGULAR_ID369));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerollback_keyEx; /* Prevent compiler warnings */
    rulerollback_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rollback_key */

/**
 * $ANTLR start share_key
 * OracleDMLKeys.g:1806:1: share_key : PLSQL_RESERVED_SHARE ;
 */
OracleDML_OracleDMLKeys::share_key_return
OracleDML_OracleDMLKeys::share_key()
{
    OracleDML_OracleDMLKeys::share_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_SHARE370 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_SHARE370_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1807:5: ( PLSQL_RESERVED_SHARE )
        // OracleDMLKeys.g:1807:10: PLSQL_RESERVED_SHARE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_SHARE370 =  this->matchToken(PLSQL_RESERVED_SHARE, &FOLLOW_PLSQL_RESERVED_SHARE_in_share_key9834);
            if  (this->hasException())
            {
                goto ruleshare_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_SHARE370_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_SHARE370));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_SHARE370_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleshare_keyEx; /* Prevent compiler warnings */
    ruleshare_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end share_key */

/**
 * $ANTLR start greatest_key
 * OracleDMLKeys.g:1810:1: greatest_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::greatest_key_return
OracleDML_OracleDMLKeys::greatest_key()
{
    OracleDML_OracleDMLKeys::greatest_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID371 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID371_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1811:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1811:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "GREATEST")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"GREATEST\"" );
                    ex->set_ruleName( "greatest_key" );


            }

            REGULAR_ID371 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_greatest_key9856);
            if  (this->hasException())
            {
                goto rulegreatest_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID371_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID371));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID371_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegreatest_keyEx; /* Prevent compiler warnings */
    rulegreatest_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end greatest_key */

/**
 * $ANTLR start vsize_key
 * OracleDMLKeys.g:1814:1: vsize_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::vsize_key_return
OracleDML_OracleDMLKeys::vsize_key()
{
    OracleDML_OracleDMLKeys::vsize_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID372 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID372_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1815:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1815:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "VSIZE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VSIZE\"" );
                    ex->set_ruleName( "vsize_key" );


            }

            REGULAR_ID372 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_vsize_key9878);
            if  (this->hasException())
            {
                goto rulevsize_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID372_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID372));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID372_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevsize_keyEx; /* Prevent compiler warnings */
    rulevsize_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end vsize_key */

/**
 * $ANTLR start exclusive_key
 * OracleDMLKeys.g:1818:1: exclusive_key : PLSQL_RESERVED_EXCLUSIVE ;
 */
OracleDML_OracleDMLKeys::exclusive_key_return
OracleDML_OracleDMLKeys::exclusive_key()
{
    OracleDML_OracleDMLKeys::exclusive_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_EXCLUSIVE373 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_EXCLUSIVE373_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1819:5: ( PLSQL_RESERVED_EXCLUSIVE )
        // OracleDMLKeys.g:1819:10: PLSQL_RESERVED_EXCLUSIVE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_EXCLUSIVE373 =  this->matchToken(PLSQL_RESERVED_EXCLUSIVE, &FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key9898);
            if  (this->hasException())
            {
                goto ruleexclusive_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_EXCLUSIVE373_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_EXCLUSIVE373));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_EXCLUSIVE373_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexclusive_keyEx; /* Prevent compiler warnings */
    ruleexclusive_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exclusive_key */

/**
 * $ANTLR start varchar2_key
 * OracleDMLKeys.g:1822:1: varchar2_key :{...}? => REGULAR_ID -> VARCHAR2_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::varchar2_key_return
OracleDML_OracleDMLKeys::varchar2_key()
{
    OracleDML_OracleDMLKeys::varchar2_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID374 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID374_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1823:5: ({...}? => REGULAR_ID -> VARCHAR2_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1823:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "VARCHAR2")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VARCHAR2\"" );
                    ex->set_ruleName( "varchar2_key" );


            }

            REGULAR_ID374 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varchar2_key9921);
            if  (this->hasException())
            {
                goto rulevarchar2_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID374);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1823:66: -> VARCHAR2_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(VARCHAR2_VK, REGULAR_ID374));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevarchar2_keyEx; /* Prevent compiler warnings */
    rulevarchar2_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end varchar2_key */

/**
 * $ANTLR start rowidtochar_key
 * OracleDMLKeys.g:1826:1: rowidtochar_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::rowidtochar_key_return
OracleDML_OracleDMLKeys::rowidtochar_key()
{
    OracleDML_OracleDMLKeys::rowidtochar_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID375 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID375_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1827:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1827:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ROWIDTOCHAR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROWIDTOCHAR\"" );
                    ex->set_ruleName( "rowidtochar_key" );


            }

            REGULAR_ID375 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rowidtochar_key9948);
            if  (this->hasException())
            {
                goto rulerowidtochar_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID375_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID375));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID375_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerowidtochar_keyEx; /* Prevent compiler warnings */
    rulerowidtochar_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rowidtochar_key */

/**
 * $ANTLR start open_key
 * OracleDMLKeys.g:1830:1: open_key :{...}? => REGULAR_ID -> OPEN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::open_key_return
OracleDML_OracleDMLKeys::open_key()
{
    OracleDML_OracleDMLKeys::open_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID376 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID376_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1831:5: ({...}? => REGULAR_ID -> OPEN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1831:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "OPEN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OPEN\"" );
                    ex->set_ruleName( "open_key" );


            }

            REGULAR_ID376 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_open_key9971);
            if  (this->hasException())
            {
                goto ruleopen_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID376);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1831:62: -> OPEN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(OPEN_VK, REGULAR_ID376));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleopen_keyEx; /* Prevent compiler warnings */
    ruleopen_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end open_key */

/**
 * $ANTLR start comment_key
 * OracleDMLKeys.g:1834:1: comment_key :{...}? => REGULAR_ID -> COMMENT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::comment_key_return
OracleDML_OracleDMLKeys::comment_key()
{
    OracleDML_OracleDMLKeys::comment_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID377 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID377_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1835:5: ({...}? => REGULAR_ID -> COMMENT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1835:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COMMENT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COMMENT\"" );
                    ex->set_ruleName( "comment_key" );


            }

            REGULAR_ID377 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_comment_key9999);
            if  (this->hasException())
            {
                goto rulecomment_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID377);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1835:65: -> COMMENT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COMMENT_VK, REGULAR_ID377));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecomment_keyEx; /* Prevent compiler warnings */
    rulecomment_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end comment_key */

/**
 * $ANTLR start sqrt_key
 * OracleDMLKeys.g:1838:1: sqrt_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::sqrt_key_return
OracleDML_OracleDMLKeys::sqrt_key()
{
    OracleDML_OracleDMLKeys::sqrt_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID378 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID378_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1839:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1839:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SQRT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SQRT\"" );
                    ex->set_ruleName( "sqrt_key" );


            }

            REGULAR_ID378 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqrt_key10026);
            if  (this->hasException())
            {
                goto rulesqrt_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID378_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID378));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID378_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesqrt_keyEx; /* Prevent compiler warnings */
    rulesqrt_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sqrt_key */

/**
 * $ANTLR start instr_key
 * OracleDMLKeys.g:1842:1: instr_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::instr_key_return
OracleDML_OracleDMLKeys::instr_key()
{
    OracleDML_OracleDMLKeys::instr_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID379 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID379_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1843:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1843:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "INSTR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INSTR\"" );
                    ex->set_ruleName( "instr_key" );


            }

            REGULAR_ID379 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instr_key10048);
            if  (this->hasException())
            {
                goto ruleinstr_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID379_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID379));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID379_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinstr_keyEx; /* Prevent compiler warnings */
    ruleinstr_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end instr_key */

/**
 * $ANTLR start nowait_key
 * OracleDMLKeys.g:1846:1: nowait_key : PLSQL_RESERVED_NOWAIT ;
 */
OracleDML_OracleDMLKeys::nowait_key_return
OracleDML_OracleDMLKeys::nowait_key()
{
    OracleDML_OracleDMLKeys::nowait_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_NOWAIT380 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_NOWAIT380_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1847:5: ( PLSQL_RESERVED_NOWAIT )
        // OracleDMLKeys.g:1847:10: PLSQL_RESERVED_NOWAIT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_NOWAIT380 =  this->matchToken(PLSQL_RESERVED_NOWAIT, &FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key10068);
            if  (this->hasException())
            {
                goto rulenowait_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_NOWAIT380_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_NOWAIT380));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_NOWAIT380_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenowait_keyEx; /* Prevent compiler warnings */
    rulenowait_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nowait_key */

/**
 * $ANTLR start lpad_key
 * OracleDMLKeys.g:1850:1: lpad_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::lpad_key_return
OracleDML_OracleDMLKeys::lpad_key()
{
    OracleDML_OracleDMLKeys::lpad_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID381 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID381_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1851:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1851:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LPAD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LPAD\"" );
                    ex->set_ruleName( "lpad_key" );


            }

            REGULAR_ID381 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_lpad_key10090);
            if  (this->hasException())
            {
                goto rulelpad_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID381_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID381));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID381_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelpad_keyEx; /* Prevent compiler warnings */
    rulelpad_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end lpad_key */

/**
 * $ANTLR start boolean_key
 * OracleDMLKeys.g:1854:1: boolean_key :{...}? => REGULAR_ID -> BOOLEAN_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::boolean_key_return
OracleDML_OracleDMLKeys::boolean_key()
{
    OracleDML_OracleDMLKeys::boolean_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID382 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID382_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1855:5: ({...}? => REGULAR_ID -> BOOLEAN_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1855:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BOOLEAN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BOOLEAN\"" );
                    ex->set_ruleName( "boolean_key" );


            }

            REGULAR_ID382 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_boolean_key10113);
            if  (this->hasException())
            {
                goto ruleboolean_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID382);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1855:65: -> BOOLEAN_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BOOLEAN_VK, REGULAR_ID382));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleboolean_keyEx; /* Prevent compiler warnings */
    ruleboolean_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end boolean_key */

/**
 * $ANTLR start rpad_key
 * OracleDMLKeys.g:1858:1: rpad_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::rpad_key_return
OracleDML_OracleDMLKeys::rpad_key()
{
    OracleDML_OracleDMLKeys::rpad_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID383 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID383_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1859:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1859:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "RPAD")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RPAD\"" );
                    ex->set_ruleName( "rpad_key" );


            }

            REGULAR_ID383 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rpad_key10140);
            if  (this->hasException())
            {
                goto rulerpad_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID383_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID383));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID383_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerpad_keyEx; /* Prevent compiler warnings */
    rulerpad_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rpad_key */

/**
 * $ANTLR start savepoint_key
 * OracleDMLKeys.g:1862:1: savepoint_key :{...}? => REGULAR_ID -> SAVEPOINT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::savepoint_key_return
OracleDML_OracleDMLKeys::savepoint_key()
{
    OracleDML_OracleDMLKeys::savepoint_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID384 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID384_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1863:5: ({...}? => REGULAR_ID -> SAVEPOINT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1863:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SAVEPOINT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SAVEPOINT\"" );
                    ex->set_ruleName( "savepoint_key" );


            }

            REGULAR_ID384 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_savepoint_key10163);
            if  (this->hasException())
            {
                goto rulesavepoint_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID384);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1863:67: -> SAVEPOINT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SAVEPOINT_VK, REGULAR_ID384));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesavepoint_keyEx; /* Prevent compiler warnings */
    rulesavepoint_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end savepoint_key */

/**
 * $ANTLR start decode_key
 * OracleDMLKeys.g:1866:1: decode_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::decode_key_return
OracleDML_OracleDMLKeys::decode_key()
{
    OracleDML_OracleDMLKeys::decode_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID385 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID385_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1867:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1867:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "DECODE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DECODE\"" );
                    ex->set_ruleName( "decode_key" );


            }

            REGULAR_ID385 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decode_key10190);
            if  (this->hasException())
            {
                goto ruledecode_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID385_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID385));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID385_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledecode_keyEx; /* Prevent compiler warnings */
    ruledecode_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end decode_key */

/**
 * $ANTLR start reverse_key
 * OracleDMLKeys.g:1870:1: reverse_key :{...}? REGULAR_ID -> REVERSE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::reverse_key_return
OracleDML_OracleDMLKeys::reverse_key()
{
    OracleDML_OracleDMLKeys::reverse_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID386 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID386_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1871:5: ({...}? REGULAR_ID -> REVERSE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1871:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REVERSE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REVERSE\"" );
                    ex->set_ruleName( "reverse_key" );


            }

            REGULAR_ID386 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reverse_key10212);
            if  (this->hasException())
            {
                goto rulereverse_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID386);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1871:63: -> REVERSE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REVERSE_VK, REGULAR_ID386));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereverse_keyEx; /* Prevent compiler warnings */
    rulereverse_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end reverse_key */

/**
 * $ANTLR start least_key
 * OracleDMLKeys.g:1874:1: least_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::least_key_return
OracleDML_OracleDMLKeys::least_key()
{
    OracleDML_OracleDMLKeys::least_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID387 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID387_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1875:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1875:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LEAST")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LEAST\"" );
                    ex->set_ruleName( "least_key" );


            }

            REGULAR_ID387 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_least_key10239);
            if  (this->hasException())
            {
                goto ruleleast_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID387_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID387));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID387_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleleast_keyEx; /* Prevent compiler warnings */
    ruleleast_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end least_key */

/**
 * $ANTLR start nvl_key
 * OracleDMLKeys.g:1878:1: nvl_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::nvl_key_return
OracleDML_OracleDMLKeys::nvl_key()
{
    OracleDML_OracleDMLKeys::nvl_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID388 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID388_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1879:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1879:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "NVL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NVL\"" );
                    ex->set_ruleName( "nvl_key" );


            }

            REGULAR_ID388 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nvl_key10261);
            if  (this->hasException())
            {
                goto rulenvl_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID388_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID388));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID388_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenvl_keyEx; /* Prevent compiler warnings */
    rulenvl_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nvl_key */

/**
 * $ANTLR start variance_key
 * OracleDMLKeys.g:1882:1: variance_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::variance_key_return
OracleDML_OracleDMLKeys::variance_key()
{
    OracleDML_OracleDMLKeys::variance_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID389 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID389_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1883:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1883:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "VARIANCE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VARIANCE\"" );
                    ex->set_ruleName( "variance_key" );


            }

            REGULAR_ID389 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_variance_key10283);
            if  (this->hasException())
            {
                goto rulevariance_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID389_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID389));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID389_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevariance_keyEx; /* Prevent compiler warnings */
    rulevariance_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end variance_key */

/**
 * $ANTLR start start_key
 * OracleDMLKeys.g:1886:1: start_key : PLSQL_RESERVED_START ;
 */
OracleDML_OracleDMLKeys::start_key_return
OracleDML_OracleDMLKeys::start_key()
{
    OracleDML_OracleDMLKeys::start_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_START390 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_START390_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1887:5: ( PLSQL_RESERVED_START )
        // OracleDMLKeys.g:1887:10: PLSQL_RESERVED_START
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_START390 =  this->matchToken(PLSQL_RESERVED_START, &FOLLOW_PLSQL_RESERVED_START_in_start_key10303);
            if  (this->hasException())
            {
                goto rulestart_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_START390_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_START390));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_START390_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestart_keyEx; /* Prevent compiler warnings */
    rulestart_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end start_key */

/**
 * $ANTLR start desc_key
 * OracleDMLKeys.g:1890:1: desc_key : SQL92_RESERVED_DESC ;
 */
OracleDML_OracleDMLKeys::desc_key_return
OracleDML_OracleDMLKeys::desc_key()
{
    OracleDML_OracleDMLKeys::desc_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_DESC391 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_DESC391_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1891:5: ( SQL92_RESERVED_DESC )
        // OracleDMLKeys.g:1891:10: SQL92_RESERVED_DESC
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_DESC391 =  this->matchToken(SQL92_RESERVED_DESC, &FOLLOW_SQL92_RESERVED_DESC_in_desc_key10323);
            if  (this->hasException())
            {
                goto ruledesc_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_DESC391_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_DESC391));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_DESC391_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledesc_keyEx; /* Prevent compiler warnings */
    ruledesc_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end desc_key */

/**
 * $ANTLR start concat_key
 * OracleDMLKeys.g:1894:1: concat_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::concat_key_return
OracleDML_OracleDMLKeys::concat_key()
{
    OracleDML_OracleDMLKeys::concat_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID392 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID392_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1895:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1895:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CONCAT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONCAT\"" );
                    ex->set_ruleName( "concat_key" );


            }

            REGULAR_ID392 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_concat_key10345);
            if  (this->hasException())
            {
                goto ruleconcat_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID392_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID392));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID392_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconcat_keyEx; /* Prevent compiler warnings */
    ruleconcat_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end concat_key */

/**
 * $ANTLR start dump_key
 * OracleDMLKeys.g:1898:1: dump_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::dump_key_return
OracleDML_OracleDMLKeys::dump_key()
{
    OracleDML_OracleDMLKeys::dump_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID393 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID393_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1899:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1899:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "DUMP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DUMP\"" );
                    ex->set_ruleName( "dump_key" );


            }

            REGULAR_ID393 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dump_key10367);
            if  (this->hasException())
            {
                goto ruledump_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID393_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID393));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID393_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledump_keyEx; /* Prevent compiler warnings */
    ruledump_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dump_key */

/**
 * $ANTLR start soundex_key
 * OracleDMLKeys.g:1902:1: soundex_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::soundex_key_return
OracleDML_OracleDMLKeys::soundex_key()
{
    OracleDML_OracleDMLKeys::soundex_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID394 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID394_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1903:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1903:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SOUNDEX")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SOUNDEX\"" );
                    ex->set_ruleName( "soundex_key" );


            }

            REGULAR_ID394 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_soundex_key10389);
            if  (this->hasException())
            {
                goto rulesoundex_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID394_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID394));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID394_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesoundex_keyEx; /* Prevent compiler warnings */
    rulesoundex_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end soundex_key */

/**
 * $ANTLR start positive_key
 * OracleDMLKeys.g:1906:1: positive_key :{...}? => REGULAR_ID -> POSITIVE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::positive_key_return
OracleDML_OracleDMLKeys::positive_key()
{
    OracleDML_OracleDMLKeys::positive_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID395 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID395_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1907:5: ({...}? => REGULAR_ID -> POSITIVE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1907:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "POSITIVE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"POSITIVE\"" );
                    ex->set_ruleName( "positive_key" );


            }

            REGULAR_ID395 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_positive_key10412);
            if  (this->hasException())
            {
                goto rulepositive_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID395);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1907:66: -> POSITIVE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(POSITIVE_VK, REGULAR_ID395));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepositive_keyEx; /* Prevent compiler warnings */
    rulepositive_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end positive_key */

/**
 * $ANTLR start union_key
 * OracleDMLKeys.g:1910:1: union_key : SQL92_RESERVED_UNION ;
 */
OracleDML_OracleDMLKeys::union_key_return
OracleDML_OracleDMLKeys::union_key()
{
    OracleDML_OracleDMLKeys::union_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_UNION396 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_UNION396_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1911:5: ( SQL92_RESERVED_UNION )
        // OracleDMLKeys.g:1911:10: SQL92_RESERVED_UNION
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_UNION396 =  this->matchToken(SQL92_RESERVED_UNION, &FOLLOW_SQL92_RESERVED_UNION_in_union_key10437);
            if  (this->hasException())
            {
                goto ruleunion_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_UNION396_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_UNION396));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_UNION396_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunion_keyEx; /* Prevent compiler warnings */
    ruleunion_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end union_key */

/**
 * $ANTLR start ascii_key
 * OracleDMLKeys.g:1914:1: ascii_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::ascii_key_return
OracleDML_OracleDMLKeys::ascii_key()
{
    OracleDML_OracleDMLKeys::ascii_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID397 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID397_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1915:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1915:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ASCII")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ASCII\"" );
                    ex->set_ruleName( "ascii_key" );


            }

            REGULAR_ID397 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ascii_key10459);
            if  (this->hasException())
            {
                goto ruleascii_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID397_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID397));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID397_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleascii_keyEx; /* Prevent compiler warnings */
    ruleascii_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end ascii_key */

/**
 * $ANTLR start connect_key
 * OracleDMLKeys.g:1918:1: connect_key : SQL92_RESERVED_CONNECT ;
 */
OracleDML_OracleDMLKeys::connect_key_return
OracleDML_OracleDMLKeys::connect_key()
{
    OracleDML_OracleDMLKeys::connect_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_CONNECT398 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_CONNECT398_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1919:5: ( SQL92_RESERVED_CONNECT )
        // OracleDMLKeys.g:1919:10: SQL92_RESERVED_CONNECT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_CONNECT398 =  this->matchToken(SQL92_RESERVED_CONNECT, &FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key10479);
            if  (this->hasException())
            {
                goto ruleconnect_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_CONNECT398_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_CONNECT398));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_CONNECT398_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconnect_keyEx; /* Prevent compiler warnings */
    ruleconnect_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end connect_key */

/**
 * $ANTLR start asc_key
 * OracleDMLKeys.g:1922:1: asc_key : SQL92_RESERVED_ASC ;
 */
OracleDML_OracleDMLKeys::asc_key_return
OracleDML_OracleDMLKeys::asc_key()
{
    OracleDML_OracleDMLKeys::asc_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_ASC399 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_ASC399_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1923:5: ( SQL92_RESERVED_ASC )
        // OracleDMLKeys.g:1923:10: SQL92_RESERVED_ASC
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_ASC399 =  this->matchToken(SQL92_RESERVED_ASC, &FOLLOW_SQL92_RESERVED_ASC_in_asc_key10499);
            if  (this->hasException())
            {
                goto ruleasc_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_ASC399_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_ASC399));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_ASC399_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleasc_keyEx; /* Prevent compiler warnings */
    ruleasc_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end asc_key */

/**
 * $ANTLR start hextoraw_key
 * OracleDMLKeys.g:1926:1: hextoraw_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::hextoraw_key_return
OracleDML_OracleDMLKeys::hextoraw_key()
{
    OracleDML_OracleDMLKeys::hextoraw_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID400 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID400_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1927:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1927:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "HEXTORAW")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"HEXTORAW\"" );
                    ex->set_ruleName( "hextoraw_key" );


            }

            REGULAR_ID400 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hextoraw_key10521);
            if  (this->hasException())
            {
                goto rulehextoraw_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID400_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID400));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID400_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulehextoraw_keyEx; /* Prevent compiler warnings */
    rulehextoraw_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end hextoraw_key */

/**
 * $ANTLR start to_date_key
 * OracleDMLKeys.g:1930:1: to_date_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::to_date_key_return
OracleDML_OracleDMLKeys::to_date_key()
{
    OracleDML_OracleDMLKeys::to_date_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID401 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID401_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1931:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1931:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "TO_DATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TO_DATE\"" );
                    ex->set_ruleName( "to_date_key" );


            }

            REGULAR_ID401 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_date_key10543);
            if  (this->hasException())
            {
                goto ruleto_date_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID401_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID401));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID401_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleto_date_keyEx; /* Prevent compiler warnings */
    ruleto_date_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end to_date_key */

/**
 * $ANTLR start floor_key
 * OracleDMLKeys.g:1934:1: floor_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::floor_key_return
OracleDML_OracleDMLKeys::floor_key()
{
    OracleDML_OracleDMLKeys::floor_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID402 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID402_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1935:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1935:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "FLOOR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FLOOR\"" );
                    ex->set_ruleName( "floor_key" );


            }

            REGULAR_ID402 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_floor_key10565);
            if  (this->hasException())
            {
                goto rulefloor_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID402_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID402));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID402_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefloor_keyEx; /* Prevent compiler warnings */
    rulefloor_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end floor_key */

/**
 * $ANTLR start sign_key
 * OracleDMLKeys.g:1938:1: sign_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::sign_key_return
OracleDML_OracleDMLKeys::sign_key()
{
    OracleDML_OracleDMLKeys::sign_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID403 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID403_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1939:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1939:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SIGN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SIGN\"" );
                    ex->set_ruleName( "sign_key" );


            }

            REGULAR_ID403 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sign_key10587);
            if  (this->hasException())
            {
                goto rulesign_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID403_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID403));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID403_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesign_keyEx; /* Prevent compiler warnings */
    rulesign_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sign_key */

/**
 * $ANTLR start update_key
 * OracleDMLKeys.g:1942:1: update_key : SQL92_RESERVED_UPDATE ;
 */
OracleDML_OracleDMLKeys::update_key_return
OracleDML_OracleDMLKeys::update_key()
{
    OracleDML_OracleDMLKeys::update_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_UPDATE404 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_UPDATE404_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1943:5: ( SQL92_RESERVED_UPDATE )
        // OracleDMLKeys.g:1943:10: SQL92_RESERVED_UPDATE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_UPDATE404 =  this->matchToken(SQL92_RESERVED_UPDATE, &FOLLOW_SQL92_RESERVED_UPDATE_in_update_key10607);
            if  (this->hasException())
            {
                goto ruleupdate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_UPDATE404_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_UPDATE404));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_UPDATE404_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleupdate_keyEx; /* Prevent compiler warnings */
    ruleupdate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end update_key */

/**
 * $ANTLR start trunc_key
 * OracleDMLKeys.g:1946:1: trunc_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::trunc_key_return
OracleDML_OracleDMLKeys::trunc_key()
{
    OracleDML_OracleDMLKeys::trunc_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID405 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID405_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1947:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1947:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "TRUNC")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TRUNC\"" );
                    ex->set_ruleName( "trunc_key" );


            }

            REGULAR_ID405 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trunc_key10629);
            if  (this->hasException())
            {
                goto ruletrunc_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID405_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID405));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID405_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletrunc_keyEx; /* Prevent compiler warnings */
    ruletrunc_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end trunc_key */

/**
 * $ANTLR start rtrim_key
 * OracleDMLKeys.g:1950:1: rtrim_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::rtrim_key_return
OracleDML_OracleDMLKeys::rtrim_key()
{
    OracleDML_OracleDMLKeys::rtrim_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID406 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID406_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1951:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1951:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "RTRIM")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RTRIM\"" );
                    ex->set_ruleName( "rtrim_key" );


            }

            REGULAR_ID406 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rtrim_key10651);
            if  (this->hasException())
            {
                goto rulertrim_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID406_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID406));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID406_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulertrim_keyEx; /* Prevent compiler warnings */
    rulertrim_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rtrim_key */

/**
 * $ANTLR start close_key
 * OracleDMLKeys.g:1954:1: close_key :{...}? => REGULAR_ID -> CLOSE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::close_key_return
OracleDML_OracleDMLKeys::close_key()
{
    OracleDML_OracleDMLKeys::close_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID407 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID407_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1955:5: ({...}? => REGULAR_ID -> CLOSE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1955:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CLOSE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CLOSE\"" );
                    ex->set_ruleName( "close_key" );


            }

            REGULAR_ID407 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_close_key10674);
            if  (this->hasException())
            {
                goto ruleclose_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID407);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1955:63: -> CLOSE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CLOSE_VK, REGULAR_ID407));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleclose_keyEx; /* Prevent compiler warnings */
    ruleclose_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end close_key */

/**
 * $ANTLR start to_char_key
 * OracleDMLKeys.g:1958:1: to_char_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::to_char_key_return
OracleDML_OracleDMLKeys::to_char_key()
{
    OracleDML_OracleDMLKeys::to_char_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID408 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID408_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1959:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1959:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "TO_CHAR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TO_CHAR\"" );
                    ex->set_ruleName( "to_char_key" );


            }

            REGULAR_ID408 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_char_key10701);
            if  (this->hasException())
            {
                goto ruleto_char_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID408_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID408));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID408_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleto_char_keyEx; /* Prevent compiler warnings */
    ruleto_char_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end to_char_key */

/**
 * $ANTLR start ltrim_key
 * OracleDMLKeys.g:1962:1: ltrim_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::ltrim_key_return
OracleDML_OracleDMLKeys::ltrim_key()
{
    OracleDML_OracleDMLKeys::ltrim_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID409 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID409_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1963:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1963:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LTRIM")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LTRIM\"" );
                    ex->set_ruleName( "ltrim_key" );


            }

            REGULAR_ID409 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ltrim_key10723);
            if  (this->hasException())
            {
                goto ruleltrim_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID409_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID409));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID409_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleltrim_keyEx; /* Prevent compiler warnings */
    ruleltrim_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end ltrim_key */

/**
 * $ANTLR start mode_key
 * OracleDMLKeys.g:1966:1: mode_key : PLSQL_RESERVED_MODE ;
 */
OracleDML_OracleDMLKeys::mode_key_return
OracleDML_OracleDMLKeys::mode_key()
{
    OracleDML_OracleDMLKeys::mode_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_RESERVED_MODE410 = NULL;

    ImplTraits::TreeTypePtr PLSQL_RESERVED_MODE410_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1967:5: ( PLSQL_RESERVED_MODE )
        // OracleDMLKeys.g:1967:10: PLSQL_RESERVED_MODE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_RESERVED_MODE410 =  this->matchToken(PLSQL_RESERVED_MODE, &FOLLOW_PLSQL_RESERVED_MODE_in_mode_key10743);
            if  (this->hasException())
            {
                goto rulemode_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_RESERVED_MODE410_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_RESERVED_MODE410));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_RESERVED_MODE410_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemode_keyEx; /* Prevent compiler warnings */
    rulemode_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end mode_key */

/**
 * $ANTLR start uid_key
 * OracleDMLKeys.g:1970:1: uid_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::uid_key_return
OracleDML_OracleDMLKeys::uid_key()
{
    OracleDML_OracleDMLKeys::uid_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID411 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID411_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1971:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1971:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "UID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UID\"" );
                    ex->set_ruleName( "uid_key" );


            }

            REGULAR_ID411 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_uid_key10765);
            if  (this->hasException())
            {
                goto ruleuid_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID411_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID411));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID411_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleuid_keyEx; /* Prevent compiler warnings */
    ruleuid_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end uid_key */

/**
 * $ANTLR start chr_key
 * OracleDMLKeys.g:1974:1: chr_key :{...}? REGULAR_ID -> CHR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::chr_key_return
OracleDML_OracleDMLKeys::chr_key()
{
    OracleDML_OracleDMLKeys::chr_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID412 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID412_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1975:5: ({...}? REGULAR_ID -> CHR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1975:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CHR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CHR\"" );
                    ex->set_ruleName( "chr_key" );


            }

            REGULAR_ID412 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_chr_key10787);
            if  (this->hasException())
            {
                goto rulechr_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID412);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1975:59: -> CHR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CHR_VK, REGULAR_ID412));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulechr_keyEx; /* Prevent compiler warnings */
    rulechr_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end chr_key */

/**
 * $ANTLR start intersect_key
 * OracleDMLKeys.g:1978:1: intersect_key : SQL92_RESERVED_INTERSECT ;
 */
OracleDML_OracleDMLKeys::intersect_key_return
OracleDML_OracleDMLKeys::intersect_key()
{
    OracleDML_OracleDMLKeys::intersect_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_INTERSECT413 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_INTERSECT413_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1979:5: ( SQL92_RESERVED_INTERSECT )
        // OracleDMLKeys.g:1979:10: SQL92_RESERVED_INTERSECT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_INTERSECT413 =  this->matchToken(SQL92_RESERVED_INTERSECT, &FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key10812);
            if  (this->hasException())
            {
                goto ruleintersect_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_INTERSECT413_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_INTERSECT413));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_INTERSECT413_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleintersect_keyEx; /* Prevent compiler warnings */
    ruleintersect_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end intersect_key */

/**
 * $ANTLR start chartorowid_key
 * OracleDMLKeys.g:1982:1: chartorowid_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::chartorowid_key_return
OracleDML_OracleDMLKeys::chartorowid_key()
{
    OracleDML_OracleDMLKeys::chartorowid_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID414 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID414_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1983:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1983:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CHARTOROWID")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CHARTOROWID\"" );
                    ex->set_ruleName( "chartorowid_key" );


            }

            REGULAR_ID414 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_chartorowid_key10834);
            if  (this->hasException())
            {
                goto rulechartorowid_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID414_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID414));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID414_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulechartorowid_keyEx; /* Prevent compiler warnings */
    rulechartorowid_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end chartorowid_key */

/**
 * $ANTLR start mlslabel_key
 * OracleDMLKeys.g:1986:1: mlslabel_key :{...}? => REGULAR_ID -> MLSLABEL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::mlslabel_key_return
OracleDML_OracleDMLKeys::mlslabel_key()
{
    OracleDML_OracleDMLKeys::mlslabel_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID415 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID415_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1987:5: ({...}? => REGULAR_ID -> MLSLABEL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:1987:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MLSLABEL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MLSLABEL\"" );
                    ex->set_ruleName( "mlslabel_key" );


            }

            REGULAR_ID415 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_mlslabel_key10857);
            if  (this->hasException())
            {
                goto rulemlslabel_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID415);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1987:66: -> MLSLABEL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MLSLABEL_VK, REGULAR_ID415));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemlslabel_keyEx; /* Prevent compiler warnings */
    rulemlslabel_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end mlslabel_key */

/**
 * $ANTLR start userenv_key
 * OracleDMLKeys.g:1990:1: userenv_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::userenv_key_return
OracleDML_OracleDMLKeys::userenv_key()
{
    OracleDML_OracleDMLKeys::userenv_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID416 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID416_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1991:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1991:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "USERENV")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"USERENV\"" );
                    ex->set_ruleName( "userenv_key" );


            }

            REGULAR_ID416 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_userenv_key10884);
            if  (this->hasException())
            {
                goto ruleuserenv_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID416_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID416));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID416_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleuserenv_keyEx; /* Prevent compiler warnings */
    ruleuserenv_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end userenv_key */

/**
 * $ANTLR start stddev_key
 * OracleDMLKeys.g:1994:1: stddev_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::stddev_key_return
OracleDML_OracleDMLKeys::stddev_key()
{
    OracleDML_OracleDMLKeys::stddev_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID417 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID417_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1995:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1995:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "STDDEV")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"STDDEV\"" );
                    ex->set_ruleName( "stddev_key" );


            }

            REGULAR_ID417 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stddev_key10906);
            if  (this->hasException())
            {
                goto rulestddev_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID417_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID417));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID417_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestddev_keyEx; /* Prevent compiler warnings */
    rulestddev_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end stddev_key */

/**
 * $ANTLR start length_key
 * OracleDMLKeys.g:1998:1: length_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::length_key_return
OracleDML_OracleDMLKeys::length_key()
{
    OracleDML_OracleDMLKeys::length_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID418 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID418_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:1999:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:1999:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LENGTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LENGTH\"" );
                    ex->set_ruleName( "length_key" );


            }

            REGULAR_ID418 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_length_key10928);
            if  (this->hasException())
            {
                goto rulelength_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID418_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID418));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID418_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelength_keyEx; /* Prevent compiler warnings */
    rulelength_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end length_key */

/**
 * $ANTLR start fetch_key
 * OracleDMLKeys.g:2002:1: fetch_key : SQL92_RESERVED_FETCH ;
 */
OracleDML_OracleDMLKeys::fetch_key_return
OracleDML_OracleDMLKeys::fetch_key()
{
    OracleDML_OracleDMLKeys::fetch_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_FETCH419 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_FETCH419_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2003:5: ( SQL92_RESERVED_FETCH )
        // OracleDMLKeys.g:2003:10: SQL92_RESERVED_FETCH
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_FETCH419 =  this->matchToken(SQL92_RESERVED_FETCH, &FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key10948);
            if  (this->hasException())
            {
                goto rulefetch_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_FETCH419_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_FETCH419));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_FETCH419_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefetch_keyEx; /* Prevent compiler warnings */
    rulefetch_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end fetch_key */

/**
 * $ANTLR start group_key
 * OracleDMLKeys.g:2006:1: group_key : SQL92_RESERVED_GROUP ;
 */
OracleDML_OracleDMLKeys::group_key_return
OracleDML_OracleDMLKeys::group_key()
{
    OracleDML_OracleDMLKeys::group_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_GROUP420 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_GROUP420_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2007:5: ( SQL92_RESERVED_GROUP )
        // OracleDMLKeys.g:2007:10: SQL92_RESERVED_GROUP
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_GROUP420 =  this->matchToken(SQL92_RESERVED_GROUP, &FOLLOW_SQL92_RESERVED_GROUP_in_group_key10968);
            if  (this->hasException())
            {
                goto rulegroup_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_GROUP420_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_GROUP420));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_GROUP420_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegroup_keyEx; /* Prevent compiler warnings */
    rulegroup_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end group_key */

/**
 * $ANTLR start sysdate_key
 * OracleDMLKeys.g:2010:1: sysdate_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::sysdate_key_return
OracleDML_OracleDMLKeys::sysdate_key()
{
    OracleDML_OracleDMLKeys::sysdate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID421 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID421_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2011:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2011:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SYSDATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SYSDATE\"" );
                    ex->set_ruleName( "sysdate_key" );


            }

            REGULAR_ID421 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sysdate_key10990);
            if  (this->hasException())
            {
                goto rulesysdate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID421_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID421));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID421_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesysdate_keyEx; /* Prevent compiler warnings */
    rulesysdate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sysdate_key */

/**
 * $ANTLR start binary_integer_key
 * OracleDMLKeys.g:2014:1: binary_integer_key :{...}? => REGULAR_ID -> BINARY_INTEGER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::binary_integer_key_return
OracleDML_OracleDMLKeys::binary_integer_key()
{
    OracleDML_OracleDMLKeys::binary_integer_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID422 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID422_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2015:5: ({...}? => REGULAR_ID -> BINARY_INTEGER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2015:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BINARY_INTEGER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BINARY_INTEGER\"" );
                    ex->set_ruleName( "binary_integer_key" );


            }

            REGULAR_ID422 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_integer_key11013);
            if  (this->hasException())
            {
                goto rulebinary_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID422);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2015:72: -> BINARY_INTEGER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BINARY_INTEGER_VK, REGULAR_ID422));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebinary_integer_keyEx; /* Prevent compiler warnings */
    rulebinary_integer_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end binary_integer_key */

/**
 * $ANTLR start to_number_key
 * OracleDMLKeys.g:2018:1: to_number_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::to_number_key_return
OracleDML_OracleDMLKeys::to_number_key()
{
    OracleDML_OracleDMLKeys::to_number_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID423 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID423_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2019:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2019:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "TO_NUMBER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TO_NUMBER\"" );
                    ex->set_ruleName( "to_number_key" );


            }

            REGULAR_ID423 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_number_key11040);
            if  (this->hasException())
            {
                goto ruleto_number_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID423_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID423));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID423_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleto_number_keyEx; /* Prevent compiler warnings */
    ruleto_number_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end to_number_key */

/**
 * $ANTLR start substr_key
 * OracleDMLKeys.g:2022:1: substr_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::substr_key_return
OracleDML_OracleDMLKeys::substr_key()
{
    OracleDML_OracleDMLKeys::substr_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID424 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID424_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2023:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2023:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SUBSTR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUBSTR\"" );
                    ex->set_ruleName( "substr_key" );


            }

            REGULAR_ID424 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substr_key11062);
            if  (this->hasException())
            {
                goto rulesubstr_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID424_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID424));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID424_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubstr_keyEx; /* Prevent compiler warnings */
    rulesubstr_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end substr_key */

/**
 * $ANTLR start ceil_key
 * OracleDMLKeys.g:2026:1: ceil_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::ceil_key_return
OracleDML_OracleDMLKeys::ceil_key()
{
    OracleDML_OracleDMLKeys::ceil_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID425 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID425_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2027:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2027:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CEIL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CEIL\"" );
                    ex->set_ruleName( "ceil_key" );


            }

            REGULAR_ID425 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ceil_key11084);
            if  (this->hasException())
            {
                goto ruleceil_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID425_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID425));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID425_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleceil_keyEx; /* Prevent compiler warnings */
    ruleceil_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end ceil_key */

/**
 * $ANTLR start initcap_key
 * OracleDMLKeys.g:2030:1: initcap_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::initcap_key_return
OracleDML_OracleDMLKeys::initcap_key()
{
    OracleDML_OracleDMLKeys::initcap_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID426 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID426_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2031:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2031:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "INITCAP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INITCAP\"" );
                    ex->set_ruleName( "initcap_key" );


            }

            REGULAR_ID426 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_initcap_key11106);
            if  (this->hasException())
            {
                goto ruleinitcap_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID426_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID426));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID426_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinitcap_keyEx; /* Prevent compiler warnings */
    ruleinitcap_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end initcap_key */

/**
 * $ANTLR start round_key
 * OracleDMLKeys.g:2034:1: round_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::round_key_return
OracleDML_OracleDMLKeys::round_key()
{
    OracleDML_OracleDMLKeys::round_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID427 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID427_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2035:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2035:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ROUND")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ROUND\"" );
                    ex->set_ruleName( "round_key" );


            }

            REGULAR_ID427 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_round_key11128);
            if  (this->hasException())
            {
                goto ruleround_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID427_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID427));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID427_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleround_keyEx; /* Prevent compiler warnings */
    ruleround_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end round_key */

/**
 * $ANTLR start long_key
 * OracleDMLKeys.g:2038:1: long_key :{...}? => REGULAR_ID -> LONG_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::long_key_return
OracleDML_OracleDMLKeys::long_key()
{
    OracleDML_OracleDMLKeys::long_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID428 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID428_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2039:5: ({...}? => REGULAR_ID -> LONG_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2039:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LONG")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LONG\"" );
                    ex->set_ruleName( "long_key" );


            }

            REGULAR_ID428 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_long_key11151);
            if  (this->hasException())
            {
                goto rulelong_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID428);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2039:62: -> LONG_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LONG_VK, REGULAR_ID428));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelong_keyEx; /* Prevent compiler warnings */
    rulelong_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end long_key */

/**
 * $ANTLR start read_key
 * OracleDMLKeys.g:2042:1: read_key :{...}? => REGULAR_ID -> READ_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::read_key_return
OracleDML_OracleDMLKeys::read_key()
{
    OracleDML_OracleDMLKeys::read_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID429 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID429_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2043:5: ({...}? => REGULAR_ID -> READ_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2043:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "READ")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"READ\"" );
                    ex->set_ruleName( "read_key" );


            }

            REGULAR_ID429 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_read_key11179);
            if  (this->hasException())
            {
                goto ruleread_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID429);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2043:62: -> READ_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(READ_VK, REGULAR_ID429));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleread_keyEx; /* Prevent compiler warnings */
    ruleread_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end read_key */

/**
 * $ANTLR start only_key
 * OracleDMLKeys.g:2046:1: only_key :{...}? REGULAR_ID -> ONLY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::only_key_return
OracleDML_OracleDMLKeys::only_key()
{
    OracleDML_OracleDMLKeys::only_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID430 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID430_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2047:5: ({...}? REGULAR_ID -> ONLY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2047:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "ONLY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ONLY\"" );
                    ex->set_ruleName( "only_key" );


            }

            REGULAR_ID430 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_only_key11206);
            if  (this->hasException())
            {
                goto ruleonly_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID430);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2047:60: -> ONLY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ONLY_VK, REGULAR_ID430));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleonly_keyEx; /* Prevent compiler warnings */
    ruleonly_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end only_key */

/**
 * $ANTLR start set_key
 * OracleDMLKeys.g:2050:1: set_key :{...}? => REGULAR_ID -> SET_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::set_key_return
OracleDML_OracleDMLKeys::set_key()
{
    OracleDML_OracleDMLKeys::set_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID431 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID431_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2051:5: ({...}? => REGULAR_ID -> SET_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2051:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SET")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SET\"" );
                    ex->set_ruleName( "set_key" );


            }

            REGULAR_ID431 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_set_key11234);
            if  (this->hasException())
            {
                goto ruleset_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID431);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2051:61: -> SET_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SET_VK, REGULAR_ID431));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleset_keyEx; /* Prevent compiler warnings */
    ruleset_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end set_key */

/**
 * $ANTLR start nullif_key
 * OracleDMLKeys.g:2054:1: nullif_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::nullif_key_return
OracleDML_OracleDMLKeys::nullif_key()
{
    OracleDML_OracleDMLKeys::nullif_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID432 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID432_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2055:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2055:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "NULLIF")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NULLIF\"" );
                    ex->set_ruleName( "nullif_key" );


            }

            REGULAR_ID432 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nullif_key11261);
            if  (this->hasException())
            {
                goto rulenullif_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID432_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID432));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID432_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenullif_keyEx; /* Prevent compiler warnings */
    rulenullif_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nullif_key */

/**
 * $ANTLR start coalesce_key
 * OracleDMLKeys.g:2058:1: coalesce_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::coalesce_key_return
OracleDML_OracleDMLKeys::coalesce_key()
{
    OracleDML_OracleDMLKeys::coalesce_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID433 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID433_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2059:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2059:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "COALESCE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COALESCE\"" );
                    ex->set_ruleName( "coalesce_key" );


            }

            REGULAR_ID433 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_coalesce_key11283);
            if  (this->hasException())
            {
                goto rulecoalesce_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID433_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID433));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID433_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecoalesce_keyEx; /* Prevent compiler warnings */
    rulecoalesce_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end coalesce_key */

/**
 * $ANTLR start count_key
 * OracleDMLKeys.g:2062:1: count_key :{...}? REGULAR_ID -> COUNT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::count_key_return
OracleDML_OracleDMLKeys::count_key()
{
    OracleDML_OracleDMLKeys::count_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID434 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID434_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2063:5: ({...}? REGULAR_ID -> COUNT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2063:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "COUNT" )) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COUNT\" " );
                    ex->set_ruleName( "count_key" );


            }

            REGULAR_ID434 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_count_key11305);
            if  (this->hasException())
            {
                goto rulecount_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID434);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2063:62: -> COUNT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(COUNT_VK, REGULAR_ID434));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecount_keyEx; /* Prevent compiler warnings */
    rulecount_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end count_key */

/**
 * $ANTLR start avg_key
 * OracleDMLKeys.g:2066:1: avg_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::avg_key_return
OracleDML_OracleDMLKeys::avg_key()
{
    OracleDML_OracleDMLKeys::avg_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID435 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID435_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2066:12: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2066:17: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "AVG")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"AVG\"" );
                    ex->set_ruleName( "avg_key" );


            }

            REGULAR_ID435 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_avg_key11331);
            if  (this->hasException())
            {
                goto ruleavg_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID435_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID435));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID435_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleavg_keyEx; /* Prevent compiler warnings */
    ruleavg_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end avg_key */

/**
 * $ANTLR start max_key
 * OracleDMLKeys.g:2069:1: max_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::max_key_return
OracleDML_OracleDMLKeys::max_key()
{
    OracleDML_OracleDMLKeys::max_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID436 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID436_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2069:12: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2069:17: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "MAX")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MAX\"" );
                    ex->set_ruleName( "max_key" );


            }

            REGULAR_ID436 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_max_key11352);
            if  (this->hasException())
            {
                goto rulemax_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID436_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID436));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID436_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemax_keyEx; /* Prevent compiler warnings */
    rulemax_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end max_key */

/**
 * $ANTLR start min_key
 * OracleDMLKeys.g:2072:1: min_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::min_key_return
OracleDML_OracleDMLKeys::min_key()
{
    OracleDML_OracleDMLKeys::min_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID437 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID437_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2072:12: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2072:17: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "MIN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MIN\"" );
                    ex->set_ruleName( "min_key" );


            }

            REGULAR_ID437 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_min_key11373);
            if  (this->hasException())
            {
                goto rulemin_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID437_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID437));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID437_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemin_keyEx; /* Prevent compiler warnings */
    rulemin_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end min_key */

/**
 * $ANTLR start sum_key
 * OracleDMLKeys.g:2075:1: sum_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::sum_key_return
OracleDML_OracleDMLKeys::sum_key()
{
    OracleDML_OracleDMLKeys::sum_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID438 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID438_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2075:12: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2075:17: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SUM")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUM\"" );
                    ex->set_ruleName( "sum_key" );


            }

            REGULAR_ID438 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sum_key11394);
            if  (this->hasException())
            {
                goto rulesum_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID438_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID438));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID438_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesum_keyEx; /* Prevent compiler warnings */
    rulesum_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sum_key */

/**
 * $ANTLR start unknown_key
 * OracleDMLKeys.g:2078:1: unknown_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::unknown_key_return
OracleDML_OracleDMLKeys::unknown_key()
{
    OracleDML_OracleDMLKeys::unknown_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID439 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID439_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2079:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2079:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "UNKNOWN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UNKNOWN\"" );
                    ex->set_ruleName( "unknown_key" );


            }

            REGULAR_ID439 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unknown_key11416);
            if  (this->hasException())
            {
                goto ruleunknown_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID439_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID439));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID439_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunknown_keyEx; /* Prevent compiler warnings */
    ruleunknown_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unknown_key */

/**
 * $ANTLR start escape_key
 * OracleDMLKeys.g:2082:1: escape_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::escape_key_return
OracleDML_OracleDMLKeys::escape_key()
{
    OracleDML_OracleDMLKeys::escape_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID440 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID440_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2083:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2083:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ESCAPE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ESCAPE\"" );
                    ex->set_ruleName( "escape_key" );


            }

            REGULAR_ID440 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_escape_key11438);
            if  (this->hasException())
            {
                goto ruleescape_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID440_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID440));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID440_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleescape_keyEx; /* Prevent compiler warnings */
    ruleescape_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end escape_key */

/**
 * $ANTLR start some_key
 * OracleDMLKeys.g:2086:1: some_key :{...}? REGULAR_ID -> SOME_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::some_key_return
OracleDML_OracleDMLKeys::some_key()
{
    OracleDML_OracleDMLKeys::some_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID441 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID441_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2087:5: ({...}? REGULAR_ID -> SOME_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2087:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SOME")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SOME\"" );
                    ex->set_ruleName( "some_key" );


            }

            REGULAR_ID441 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_some_key11460);
            if  (this->hasException())
            {
                goto rulesome_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID441);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2087:60: -> SOME_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SOME_VK, REGULAR_ID441));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesome_keyEx; /* Prevent compiler warnings */
    rulesome_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end some_key */

/**
 * $ANTLR start match_key
 * OracleDMLKeys.g:2090:1: match_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::match_key_return
OracleDML_OracleDMLKeys::match_key()
{
    OracleDML_OracleDMLKeys::match_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID442 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID442_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2091:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2091:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "MATCH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MATCH\"" );
                    ex->set_ruleName( "match_key" );


            }

            REGULAR_ID442 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_match_key11487);
            if  (this->hasException())
            {
                goto rulematch_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID442_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID442));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID442_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulematch_keyEx; /* Prevent compiler warnings */
    rulematch_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end match_key */

/**
 * $ANTLR start cast_key
 * OracleDMLKeys.g:2094:1: cast_key : PLSQL_NON_RESERVED_CAST ;
 */
OracleDML_OracleDMLKeys::cast_key_return
OracleDML_OracleDMLKeys::cast_key()
{
    OracleDML_OracleDMLKeys::cast_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_CAST443 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_CAST443_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2096:5: ( PLSQL_NON_RESERVED_CAST )
        // OracleDMLKeys.g:2096:10: PLSQL_NON_RESERVED_CAST
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_CAST443 =  this->matchToken(PLSQL_NON_RESERVED_CAST, &FOLLOW_PLSQL_NON_RESERVED_CAST_in_cast_key11508);
            if  (this->hasException())
            {
                goto rulecast_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_CAST443_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_CAST443));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_CAST443_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecast_keyEx; /* Prevent compiler warnings */
    rulecast_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cast_key */

/**
 * $ANTLR start full_key
 * OracleDMLKeys.g:2099:1: full_key :{...}? => REGULAR_ID -> FULL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::full_key_return
OracleDML_OracleDMLKeys::full_key()
{
    OracleDML_OracleDMLKeys::full_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID444 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID444_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2099:9: ({...}? => REGULAR_ID -> FULL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2099:14: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FULL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FULL\"" );
                    ex->set_ruleName( "full_key" );


            }

            REGULAR_ID444 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_full_key11526);
            if  (this->hasException())
            {
                goto rulefull_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID444);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2099:66: -> FULL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FULL_VK, REGULAR_ID444));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefull_keyEx; /* Prevent compiler warnings */
    rulefull_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end full_key */

/**
 * $ANTLR start partial_key
 * OracleDMLKeys.g:2102:1: partial_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::partial_key_return
OracleDML_OracleDMLKeys::partial_key()
{
    OracleDML_OracleDMLKeys::partial_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID445 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID445_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2103:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2103:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "PARTIAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PARTIAL\"" );
                    ex->set_ruleName( "partial_key" );


            }

            REGULAR_ID445 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_partial_key11553);
            if  (this->hasException())
            {
                goto rulepartial_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID445_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID445));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID445_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepartial_keyEx; /* Prevent compiler warnings */
    rulepartial_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end partial_key */

/**
 * $ANTLR start character_key
 * OracleDMLKeys.g:2106:1: character_key :{...}? => REGULAR_ID -> CHARACTER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::character_key_return
OracleDML_OracleDMLKeys::character_key()
{
    OracleDML_OracleDMLKeys::character_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID446 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID446_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2107:5: ({...}? => REGULAR_ID -> CHARACTER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2107:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CHARACTER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CHARACTER\"" );
                    ex->set_ruleName( "character_key" );


            }

            REGULAR_ID446 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_character_key11576);
            if  (this->hasException())
            {
                goto rulecharacter_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID446);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2107:67: -> CHARACTER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CHARACTER_VK, REGULAR_ID446));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecharacter_keyEx; /* Prevent compiler warnings */
    rulecharacter_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end character_key */

/**
 * $ANTLR start except_key
 * OracleDMLKeys.g:2110:1: except_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::except_key_return
OracleDML_OracleDMLKeys::except_key()
{
    OracleDML_OracleDMLKeys::except_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID447 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID447_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2111:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2111:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "EXCEPT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXCEPT\"" );
                    ex->set_ruleName( "except_key" );


            }

            REGULAR_ID447 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_except_key11603);
            if  (this->hasException())
            {
                goto ruleexcept_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID447_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID447));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID447_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexcept_keyEx; /* Prevent compiler warnings */
    ruleexcept_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end except_key */

/**
 * $ANTLR start char_key
 * OracleDMLKeys.g:2114:1: char_key :{...}? => REGULAR_ID -> CHAR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::char_key_return
OracleDML_OracleDMLKeys::char_key()
{
    OracleDML_OracleDMLKeys::char_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID448 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID448_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2114:9: ({...}? => REGULAR_ID -> CHAR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2114:14: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CHAR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CHAR\"" );
                    ex->set_ruleName( "char_key" );


            }

            REGULAR_ID448 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_key11621);
            if  (this->hasException())
            {
                goto rulechar_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID448);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2114:66: -> CHAR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CHAR_VK, REGULAR_ID448));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulechar_keyEx; /* Prevent compiler warnings */
    rulechar_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end char_key */

/**
 * $ANTLR start varying_key
 * OracleDMLKeys.g:2117:1: varying_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::varying_key_return
OracleDML_OracleDMLKeys::varying_key()
{
    OracleDML_OracleDMLKeys::varying_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID449 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID449_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2118:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:2118:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "VARYING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VARYING\"" );
                    ex->set_ruleName( "varying_key" );


            }

            REGULAR_ID449 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varying_key11649);
            if  (this->hasException())
            {
                goto rulevarying_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID449_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID449));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID449_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevarying_keyEx; /* Prevent compiler warnings */
    rulevarying_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end varying_key */

/**
 * $ANTLR start varchar_key
 * OracleDMLKeys.g:2121:1: varchar_key :{...}? => REGULAR_ID -> VARCHAR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::varchar_key_return
OracleDML_OracleDMLKeys::varchar_key()
{
    OracleDML_OracleDMLKeys::varchar_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID450 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID450_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2122:5: ({...}? => REGULAR_ID -> VARCHAR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2122:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "VARCHAR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VARCHAR\"" );
                    ex->set_ruleName( "varchar_key" );


            }

            REGULAR_ID450 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varchar_key11672);
            if  (this->hasException())
            {
                goto rulevarchar_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID450);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2122:65: -> VARCHAR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(VARCHAR_VK, REGULAR_ID450));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevarchar_keyEx; /* Prevent compiler warnings */
    rulevarchar_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end varchar_key */

/**
 * $ANTLR start national_key
 * OracleDMLKeys.g:2125:1: national_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::national_key_return
OracleDML_OracleDMLKeys::national_key()
{
    OracleDML_OracleDMLKeys::national_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID451 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID451_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2126:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2126:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "NATIONAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NATIONAL\"" );
                    ex->set_ruleName( "national_key" );


            }

            REGULAR_ID451 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_national_key11699);
            if  (this->hasException())
            {
                goto rulenational_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID451_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID451));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID451_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenational_keyEx; /* Prevent compiler warnings */
    rulenational_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end national_key */

/**
 * $ANTLR start nchar_key
 * OracleDMLKeys.g:2129:1: nchar_key :{...}? REGULAR_ID -> NCHAR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nchar_key_return
OracleDML_OracleDMLKeys::nchar_key()
{
    OracleDML_OracleDMLKeys::nchar_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID452 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID452_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2130:5: ({...}? REGULAR_ID -> NCHAR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2130:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NCHAR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NCHAR\"" );
                    ex->set_ruleName( "nchar_key" );


            }

            REGULAR_ID452 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nchar_key11721);
            if  (this->hasException())
            {
                goto rulenchar_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID452);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2130:61: -> NCHAR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NCHAR_VK, REGULAR_ID452));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenchar_keyEx; /* Prevent compiler warnings */
    rulenchar_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nchar_key */

/**
 * $ANTLR start bit_key
 * OracleDMLKeys.g:2133:1: bit_key :{...}? REGULAR_ID -> BIT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::bit_key_return
OracleDML_OracleDMLKeys::bit_key()
{
    OracleDML_OracleDMLKeys::bit_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID453 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID453_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2133:12: ({...}? REGULAR_ID -> BIT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2133:17: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BIT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BIT\"" );
                    ex->set_ruleName( "bit_key" );


            }

            REGULAR_ID453 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bit_key11747);
            if  (this->hasException())
            {
                goto rulebit_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID453);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2133:66: -> BIT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BIT_VK, REGULAR_ID453));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebit_keyEx; /* Prevent compiler warnings */
    rulebit_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end bit_key */

/**
 * $ANTLR start float_key
 * OracleDMLKeys.g:2136:1: float_key :{...}? REGULAR_ID -> FLOAT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::float_key_return
OracleDML_OracleDMLKeys::float_key()
{
    OracleDML_OracleDMLKeys::float_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID454 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID454_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2137:5: ({...}? REGULAR_ID -> FLOAT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2137:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "FLOAT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"FLOAT\"" );
                    ex->set_ruleName( "float_key" );


            }

            REGULAR_ID454 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_float_key11774);
            if  (this->hasException())
            {
                goto rulefloat_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID454);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2137:61: -> FLOAT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FLOAT_VK, REGULAR_ID454));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefloat_keyEx; /* Prevent compiler warnings */
    rulefloat_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end float_key */

/**
 * $ANTLR start real_key
 * OracleDMLKeys.g:2140:1: real_key :{...}? => REGULAR_ID -> REAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::real_key_return
OracleDML_OracleDMLKeys::real_key()
{
    OracleDML_OracleDMLKeys::real_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID455 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID455_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2140:9: ({...}? => REGULAR_ID -> REAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2140:14: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "REAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"REAL\"" );
                    ex->set_ruleName( "real_key" );


            }

            REGULAR_ID455 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_real_key11801);
            if  (this->hasException())
            {
                goto rulereal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID455);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2140:66: -> REAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(REAL_VK, REGULAR_ID455));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereal_keyEx; /* Prevent compiler warnings */
    rulereal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end real_key */

/**
 * $ANTLR start double_key
 * OracleDMLKeys.g:2143:1: double_key :{...}? => REGULAR_ID -> DOUBLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::double_key_return
OracleDML_OracleDMLKeys::double_key()
{
    OracleDML_OracleDMLKeys::double_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID456 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID456_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2144:5: ({...}? => REGULAR_ID -> DOUBLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2144:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DOUBLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DOUBLE\"" );
                    ex->set_ruleName( "double_key" );


            }

            REGULAR_ID456 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_double_key11829);
            if  (this->hasException())
            {
                goto ruledouble_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID456);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2144:64: -> DOUBLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DOUBLE_VK, REGULAR_ID456));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledouble_keyEx; /* Prevent compiler warnings */
    ruledouble_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end double_key */

/**
 * $ANTLR start precision_key
 * OracleDMLKeys.g:2147:1: precision_key :{...}? REGULAR_ID -> PRECISION_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::precision_key_return
OracleDML_OracleDMLKeys::precision_key()
{
    OracleDML_OracleDMLKeys::precision_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID457 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID457_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2148:5: ({...}? REGULAR_ID -> PRECISION_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2148:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "PRECISION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"PRECISION\"" );
                    ex->set_ruleName( "precision_key" );


            }

            REGULAR_ID457 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_precision_key11856);
            if  (this->hasException())
            {
                goto ruleprecision_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID457);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2148:65: -> PRECISION_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PRECISION_VK, REGULAR_ID457));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleprecision_keyEx; /* Prevent compiler warnings */
    ruleprecision_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end precision_key */

/**
 * $ANTLR start interval_key
 * OracleDMLKeys.g:2151:1: interval_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::interval_key_return
OracleDML_OracleDMLKeys::interval_key()
{
    OracleDML_OracleDMLKeys::interval_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID458 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID458_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2152:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:2152:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "INTERVAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INTERVAL\"" );
                    ex->set_ruleName( "interval_key" );


            }

            REGULAR_ID458 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_interval_key11884);
            if  (this->hasException())
            {
                goto ruleinterval_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID458_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID458));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID458_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinterval_keyEx; /* Prevent compiler warnings */
    ruleinterval_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end interval_key */

/**
 * $ANTLR start time_key
 * OracleDMLKeys.g:2155:1: time_key :{...}? REGULAR_ID -> TIME_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::time_key_return
OracleDML_OracleDMLKeys::time_key()
{
    OracleDML_OracleDMLKeys::time_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID459 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID459_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2156:5: ({...}? REGULAR_ID -> TIME_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2156:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIME")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIME\"" );
                    ex->set_ruleName( "time_key" );


            }

            REGULAR_ID459 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_time_key11906);
            if  (this->hasException())
            {
                goto ruletime_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID459);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2156:60: -> TIME_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIME_VK, REGULAR_ID459));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletime_keyEx; /* Prevent compiler warnings */
    ruletime_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end time_key */

/**
 * $ANTLR start zone_key
 * OracleDMLKeys.g:2159:1: zone_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::zone_key_return
OracleDML_OracleDMLKeys::zone_key()
{
    OracleDML_OracleDMLKeys::zone_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID460 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID460_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2159:9: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2159:14: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "ZONE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"ZONE\"" );
                    ex->set_ruleName( "zone_key" );


            }

            REGULAR_ID460 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_zone_key11929);
            if  (this->hasException())
            {
                goto rulezone_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID460_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID460));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID460_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulezone_keyEx; /* Prevent compiler warnings */
    rulezone_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end zone_key */

/**
 * $ANTLR start timestamp_key
 * OracleDMLKeys.g:2162:1: timestamp_key :{...}? REGULAR_ID -> TIMESTAMP_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timestamp_key_return
OracleDML_OracleDMLKeys::timestamp_key()
{
    OracleDML_OracleDMLKeys::timestamp_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID461 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID461_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2163:5: ({...}? REGULAR_ID -> TIMESTAMP_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2163:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMESTAMP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMESTAMP\"" );
                    ex->set_ruleName( "timestamp_key" );


            }

            REGULAR_ID461 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_key11951);
            if  (this->hasException())
            {
                goto ruletimestamp_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID461);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2163:65: -> TIMESTAMP_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMESTAMP_VK, REGULAR_ID461));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimestamp_keyEx; /* Prevent compiler warnings */
    ruletimestamp_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timestamp_key */

/**
 * $ANTLR start date_key
 * OracleDMLKeys.g:2166:1: date_key : SQL92_RESERVED_DATE ;
 */
OracleDML_OracleDMLKeys::date_key_return
OracleDML_OracleDMLKeys::date_key()
{
    OracleDML_OracleDMLKeys::date_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_DATE462 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_DATE462_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2167:5: ( SQL92_RESERVED_DATE )
        // OracleDMLKeys.g:2167:10: SQL92_RESERVED_DATE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_DATE462 =  this->matchToken(SQL92_RESERVED_DATE, &FOLLOW_SQL92_RESERVED_DATE_in_date_key11976);
            if  (this->hasException())
            {
                goto ruledate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_DATE462_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_DATE462));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_DATE462_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledate_keyEx; /* Prevent compiler warnings */
    ruledate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end date_key */

/**
 * $ANTLR start numeric_key
 * OracleDMLKeys.g:2170:1: numeric_key :{...}? => REGULAR_ID -> NUMERIC_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::numeric_key_return
OracleDML_OracleDMLKeys::numeric_key()
{
    OracleDML_OracleDMLKeys::numeric_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID463 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID463_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2171:5: ({...}? => REGULAR_ID -> NUMERIC_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2171:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NUMERIC")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NUMERIC\"" );
                    ex->set_ruleName( "numeric_key" );


            }

            REGULAR_ID463 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_numeric_key11999);
            if  (this->hasException())
            {
                goto rulenumeric_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID463);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2171:65: -> NUMERIC_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NUMERIC_VK, REGULAR_ID463));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenumeric_keyEx; /* Prevent compiler warnings */
    rulenumeric_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end numeric_key */

/**
 * $ANTLR start decimal_key
 * OracleDMLKeys.g:2174:1: decimal_key :{...}? => REGULAR_ID -> DECIMAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::decimal_key_return
OracleDML_OracleDMLKeys::decimal_key()
{
    OracleDML_OracleDMLKeys::decimal_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID464 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID464_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2175:5: ({...}? => REGULAR_ID -> DECIMAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2175:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DECIMAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DECIMAL\"" );
                    ex->set_ruleName( "decimal_key" );


            }

            REGULAR_ID464 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decimal_key12027);
            if  (this->hasException())
            {
                goto ruledecimal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID464);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2175:65: -> DECIMAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DECIMAL_VK, REGULAR_ID464));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledecimal_keyEx; /* Prevent compiler warnings */
    ruledecimal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end decimal_key */

/**
 * $ANTLR start dec_key
 * OracleDMLKeys.g:2178:1: dec_key :{...}? => REGULAR_ID -> DEC_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::dec_key_return
OracleDML_OracleDMLKeys::dec_key()
{
    OracleDML_OracleDMLKeys::dec_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID465 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID465_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2178:12: ({...}? => REGULAR_ID -> DEC_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2178:17: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DEC")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DEC\"" );
                    ex->set_ruleName( "dec_key" );


            }

            REGULAR_ID465 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dec_key12054);
            if  (this->hasException())
            {
                goto ruledec_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID465);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2178:68: -> DEC_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DEC_VK, REGULAR_ID465));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledec_keyEx; /* Prevent compiler warnings */
    ruledec_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dec_key */

/**
 * $ANTLR start integer_key
 * OracleDMLKeys.g:2181:1: integer_key :{...}? => REGULAR_ID -> INTEGER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::integer_key_return
OracleDML_OracleDMLKeys::integer_key()
{
    OracleDML_OracleDMLKeys::integer_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID466 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID466_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2182:5: ({...}? => REGULAR_ID -> INTEGER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2182:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INTEGER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INTEGER\"" );
                    ex->set_ruleName( "integer_key" );


            }

            REGULAR_ID466 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_integer_key12082);
            if  (this->hasException())
            {
                goto ruleinteger_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID466);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2182:65: -> INTEGER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INTEGER_VK, REGULAR_ID466));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinteger_keyEx; /* Prevent compiler warnings */
    ruleinteger_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end integer_key */

/**
 * $ANTLR start int_key
 * OracleDMLKeys.g:2185:1: int_key :{...}? => REGULAR_ID -> INT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::int_key_return
OracleDML_OracleDMLKeys::int_key()
{
    OracleDML_OracleDMLKeys::int_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID467 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID467_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2185:12: ({...}? => REGULAR_ID -> INT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2185:17: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INT\"" );
                    ex->set_ruleName( "int_key" );


            }

            REGULAR_ID467 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_int_key12109);
            if  (this->hasException())
            {
                goto ruleint_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID467);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2185:68: -> INT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INT_VK, REGULAR_ID467));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleint_keyEx; /* Prevent compiler warnings */
    ruleint_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end int_key */

/**
 * $ANTLR start smallint_key
 * OracleDMLKeys.g:2188:1: smallint_key :{...}? => REGULAR_ID -> SMALLINT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::smallint_key_return
OracleDML_OracleDMLKeys::smallint_key()
{
    OracleDML_OracleDMLKeys::smallint_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID468 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID468_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2189:5: ({...}? => REGULAR_ID -> SMALLINT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2189:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SMALLINT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SMALLINT\"" );
                    ex->set_ruleName( "smallint_key" );


            }

            REGULAR_ID468 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_smallint_key12137);
            if  (this->hasException())
            {
                goto rulesmallint_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID468);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2189:66: -> SMALLINT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SMALLINT_VK, REGULAR_ID468));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesmallint_keyEx; /* Prevent compiler warnings */
    rulesmallint_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end smallint_key */

/**
 * $ANTLR start corresponding_key
 * OracleDMLKeys.g:2192:1: corresponding_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::corresponding_key_return
OracleDML_OracleDMLKeys::corresponding_key()
{
    OracleDML_OracleDMLKeys::corresponding_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID469 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID469_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2193:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2193:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CORRESPONDING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CORRESPONDING\"" );
                    ex->set_ruleName( "corresponding_key" );


            }

            REGULAR_ID469 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corresponding_key12164);
            if  (this->hasException())
            {
                goto rulecorresponding_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID469_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID469));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID469_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecorresponding_keyEx; /* Prevent compiler warnings */
    rulecorresponding_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end corresponding_key */

/**
 * $ANTLR start cross_key
 * OracleDMLKeys.g:2196:1: cross_key :{...}? => REGULAR_ID -> CROSS_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::cross_key_return
OracleDML_OracleDMLKeys::cross_key()
{
    OracleDML_OracleDMLKeys::cross_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID470 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID470_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2197:5: ({...}? => REGULAR_ID -> CROSS_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2197:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CROSS")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CROSS\"" );
                    ex->set_ruleName( "cross_key" );


            }

            REGULAR_ID470 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cross_key12187);
            if  (this->hasException())
            {
                goto rulecross_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID470);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2197:63: -> CROSS_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CROSS_VK, REGULAR_ID470));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecross_keyEx; /* Prevent compiler warnings */
    rulecross_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cross_key */

/**
 * $ANTLR start join_key
 * OracleDMLKeys.g:2200:1: join_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::join_key_return
OracleDML_OracleDMLKeys::join_key()
{
    OracleDML_OracleDMLKeys::join_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID471 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID471_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2201:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:2201:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "JOIN")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"JOIN\"" );
                    ex->set_ruleName( "join_key" );


            }

            REGULAR_ID471 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_join_key12215);
            if  (this->hasException())
            {
                goto rulejoin_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID471_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID471));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID471_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulejoin_keyEx; /* Prevent compiler warnings */
    rulejoin_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end join_key */

/**
 * $ANTLR start left_key
 * OracleDMLKeys.g:2204:1: left_key :{...}? => REGULAR_ID -> LEFT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::left_key_return
OracleDML_OracleDMLKeys::left_key()
{
    OracleDML_OracleDMLKeys::left_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID472 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID472_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2205:5: ({...}? => REGULAR_ID -> LEFT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2205:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LEFT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LEFT\"" );
                    ex->set_ruleName( "left_key" );


            }

            REGULAR_ID472 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_left_key12238);
            if  (this->hasException())
            {
                goto ruleleft_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID472);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2205:62: -> LEFT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LEFT_VK, REGULAR_ID472));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleleft_keyEx; /* Prevent compiler warnings */
    ruleleft_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end left_key */

/**
 * $ANTLR start right_key
 * OracleDMLKeys.g:2208:1: right_key :{...}? => REGULAR_ID -> RIGHT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::right_key_return
OracleDML_OracleDMLKeys::right_key()
{
    OracleDML_OracleDMLKeys::right_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID473 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID473_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2209:5: ({...}? => REGULAR_ID -> RIGHT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2209:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "RIGHT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"RIGHT\"" );
                    ex->set_ruleName( "right_key" );


            }

            REGULAR_ID473 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_right_key12266);
            if  (this->hasException())
            {
                goto ruleright_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID473);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2209:63: -> RIGHT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(RIGHT_VK, REGULAR_ID473));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleright_keyEx; /* Prevent compiler warnings */
    ruleright_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end right_key */

/**
 * $ANTLR start inner_key
 * OracleDMLKeys.g:2212:1: inner_key :{...}? => REGULAR_ID -> INNER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::inner_key_return
OracleDML_OracleDMLKeys::inner_key()
{
    OracleDML_OracleDMLKeys::inner_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID474 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID474_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2213:5: ({...}? => REGULAR_ID -> INNER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2213:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "INNER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INNER\"" );
                    ex->set_ruleName( "inner_key" );


            }

            REGULAR_ID474 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inner_key12294);
            if  (this->hasException())
            {
                goto ruleinner_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID474);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2213:63: -> INNER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(INNER_VK, REGULAR_ID474));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinner_keyEx; /* Prevent compiler warnings */
    ruleinner_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end inner_key */

/**
 * $ANTLR start natural_key
 * OracleDMLKeys.g:2216:1: natural_key :{...}? => REGULAR_ID -> NATURAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::natural_key_return
OracleDML_OracleDMLKeys::natural_key()
{
    OracleDML_OracleDMLKeys::natural_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID475 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID475_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2217:5: ({...}? => REGULAR_ID -> NATURAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2217:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NATURAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NATURAL\"" );
                    ex->set_ruleName( "natural_key" );


            }

            REGULAR_ID475 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_natural_key12322);
            if  (this->hasException())
            {
                goto rulenatural_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID475);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2217:65: -> NATURAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NATURAL_VK, REGULAR_ID475));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenatural_keyEx; /* Prevent compiler warnings */
    rulenatural_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end natural_key */

/**
 * $ANTLR start outer_key
 * OracleDMLKeys.g:2220:1: outer_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::outer_key_return
OracleDML_OracleDMLKeys::outer_key()
{
    OracleDML_OracleDMLKeys::outer_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID476 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID476_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2221:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:2221:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "OUTER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OUTER\"" );
                    ex->set_ruleName( "outer_key" );


            }

            REGULAR_ID476 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_outer_key12350);
            if  (this->hasException())
            {
                goto ruleouter_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID476_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID476));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID476_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleouter_keyEx; /* Prevent compiler warnings */
    ruleouter_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end outer_key */

/**
 * $ANTLR start using_key
 * OracleDMLKeys.g:2224:1: using_key : PLSQL_NON_RESERVED_USING ;
 */
OracleDML_OracleDMLKeys::using_key_return
OracleDML_OracleDMLKeys::using_key()
{
    OracleDML_OracleDMLKeys::using_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLSQL_NON_RESERVED_USING477 = NULL;

    ImplTraits::TreeTypePtr PLSQL_NON_RESERVED_USING477_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2225:5: ( PLSQL_NON_RESERVED_USING )
        // OracleDMLKeys.g:2225:10: PLSQL_NON_RESERVED_USING
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            PLSQL_NON_RESERVED_USING477 =  this->matchToken(PLSQL_NON_RESERVED_USING, &FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key12370);
            if  (this->hasException())
            {
                goto ruleusing_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLSQL_NON_RESERVED_USING477_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLSQL_NON_RESERVED_USING477));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLSQL_NON_RESERVED_USING477_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleusing_keyEx; /* Prevent compiler warnings */
    ruleusing_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end using_key */

/**
 * $ANTLR start indicator_key
 * OracleDMLKeys.g:2228:1: indicator_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::indicator_key_return
OracleDML_OracleDMLKeys::indicator_key()
{
    OracleDML_OracleDMLKeys::indicator_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID478 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID478_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2229:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2229:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "INDICATOR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"INDICATOR\"" );
                    ex->set_ruleName( "indicator_key" );


            }

            REGULAR_ID478 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indicator_key12392);
            if  (this->hasException())
            {
                goto ruleindicator_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID478_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID478));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID478_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleindicator_keyEx; /* Prevent compiler warnings */
    ruleindicator_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end indicator_key */

/**
 * $ANTLR start user_key
 * OracleDMLKeys.g:2232:1: user_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::user_key_return
OracleDML_OracleDMLKeys::user_key()
{
    OracleDML_OracleDMLKeys::user_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID479 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID479_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2233:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2233:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "USER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"USER\"" );
                    ex->set_ruleName( "user_key" );


            }

            REGULAR_ID479 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_user_key12414);
            if  (this->hasException())
            {
                goto ruleuser_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID479_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID479));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID479_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleuser_keyEx; /* Prevent compiler warnings */
    ruleuser_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end user_key */

/**
 * $ANTLR start current_user_key
 * OracleDMLKeys.g:2236:1: current_user_key :{...}? REGULAR_ID -> CURRENT_USER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::current_user_key_return
OracleDML_OracleDMLKeys::current_user_key()
{
    OracleDML_OracleDMLKeys::current_user_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID480 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID480_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2237:5: ({...}? REGULAR_ID -> CURRENT_USER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2237:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CURRENT_USER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CURRENT_USER\"" );
                    ex->set_ruleName( "current_user_key" );


            }

            REGULAR_ID480 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_user_key12436);
            if  (this->hasException())
            {
                goto rulecurrent_user_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID480);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2237:68: -> CURRENT_USER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CURRENT_USER_VK, REGULAR_ID480));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecurrent_user_keyEx; /* Prevent compiler warnings */
    rulecurrent_user_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end current_user_key */

/**
 * $ANTLR start session_user_key
 * OracleDMLKeys.g:2240:1: session_user_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::session_user_key_return
OracleDML_OracleDMLKeys::session_user_key()
{
    OracleDML_OracleDMLKeys::session_user_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID481 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID481_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2241:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2241:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SESSION_USER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SESSION_USER\"" );
                    ex->set_ruleName( "session_user_key" );


            }

            REGULAR_ID481 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_session_user_key12463);
            if  (this->hasException())
            {
                goto rulesession_user_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID481_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID481));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID481_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesession_user_keyEx; /* Prevent compiler warnings */
    rulesession_user_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end session_user_key */

/**
 * $ANTLR start system_user_key
 * OracleDMLKeys.g:2244:1: system_user_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::system_user_key_return
OracleDML_OracleDMLKeys::system_user_key()
{
    OracleDML_OracleDMLKeys::system_user_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID482 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID482_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2245:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2245:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SYSTEM_USER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SYSTEM_USER\"" );
                    ex->set_ruleName( "system_user_key" );


            }

            REGULAR_ID482 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_system_user_key12485);
            if  (this->hasException())
            {
                goto rulesystem_user_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID482_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID482));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID482_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesystem_user_keyEx; /* Prevent compiler warnings */
    rulesystem_user_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end system_user_key */

/**
 * $ANTLR start value_key
 * OracleDMLKeys.g:2248:1: value_key :{...}? REGULAR_ID -> VALUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::value_key_return
OracleDML_OracleDMLKeys::value_key()
{
    OracleDML_OracleDMLKeys::value_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID483 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID483_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2249:5: ({...}? REGULAR_ID -> VALUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2249:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "VALUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"VALUE\"" );
                    ex->set_ruleName( "value_key" );


            }

            REGULAR_ID483 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_value_key12507);
            if  (this->hasException())
            {
                goto rulevalue_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID483);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2249:61: -> VALUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(VALUE_VK, REGULAR_ID483));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevalue_keyEx; /* Prevent compiler warnings */
    rulevalue_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end value_key */

/**
 * $ANTLR start substring_key
 * OracleDMLKeys.g:2252:1: substring_key :{...}? => REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::substring_key_return
OracleDML_OracleDMLKeys::substring_key()
{
    OracleDML_OracleDMLKeys::substring_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID484 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID484_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2253:5: ({...}? => REGULAR_ID )
        // OracleDMLKeys.g:2253:10: {...}? => REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "SUBSTRING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SUBSTRING\"" );
                    ex->set_ruleName( "substring_key" );


            }

            REGULAR_ID484 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substring_key12535);
            if  (this->hasException())
            {
                goto rulesubstring_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID484_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID484));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID484_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubstring_keyEx; /* Prevent compiler warnings */
    rulesubstring_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end substring_key */

/**
 * $ANTLR start upper_key
 * OracleDMLKeys.g:2256:1: upper_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::upper_key_return
OracleDML_OracleDMLKeys::upper_key()
{
    OracleDML_OracleDMLKeys::upper_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID485 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID485_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2257:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2257:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "UPPER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"UPPER\"" );
                    ex->set_ruleName( "upper_key" );


            }

            REGULAR_ID485 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_upper_key12557);
            if  (this->hasException())
            {
                goto ruleupper_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID485_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID485));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID485_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleupper_keyEx; /* Prevent compiler warnings */
    ruleupper_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end upper_key */

/**
 * $ANTLR start lower_key
 * OracleDMLKeys.g:2260:1: lower_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::lower_key_return
OracleDML_OracleDMLKeys::lower_key()
{
    OracleDML_OracleDMLKeys::lower_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID486 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID486_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2261:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2261:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "LOWER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LOWER\"" );
                    ex->set_ruleName( "lower_key" );


            }

            REGULAR_ID486 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_lower_key12579);
            if  (this->hasException())
            {
                goto rulelower_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID486_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID486));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID486_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelower_keyEx; /* Prevent compiler warnings */
    rulelower_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end lower_key */

/**
 * $ANTLR start convert_key
 * OracleDMLKeys.g:2264:1: convert_key :{...}? REGULAR_ID -> CONVERT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::convert_key_return
OracleDML_OracleDMLKeys::convert_key()
{
    OracleDML_OracleDMLKeys::convert_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID487 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID487_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2265:5: ({...}? REGULAR_ID -> CONVERT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2265:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CONVERT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CONVERT\"" );
                    ex->set_ruleName( "convert_key" );


            }

            REGULAR_ID487 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_convert_key12601);
            if  (this->hasException())
            {
                goto ruleconvert_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID487);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2265:63: -> CONVERT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CONVERT_VK, REGULAR_ID487));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconvert_keyEx; /* Prevent compiler warnings */
    ruleconvert_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end convert_key */

/**
 * $ANTLR start translate_key
 * OracleDMLKeys.g:2268:1: translate_key :{...}? REGULAR_ID -> TRANSLATE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::translate_key_return
OracleDML_OracleDMLKeys::translate_key()
{
    OracleDML_OracleDMLKeys::translate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID488 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID488_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2269:5: ({...}? REGULAR_ID -> TRANSLATE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2269:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TRANSLATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TRANSLATE\"" );
                    ex->set_ruleName( "translate_key" );


            }

            REGULAR_ID488 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_translate_key12628);
            if  (this->hasException())
            {
                goto ruletranslate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID488);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2269:65: -> TRANSLATE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TRANSLATE_VK, REGULAR_ID488));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletranslate_keyEx; /* Prevent compiler warnings */
    ruletranslate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end translate_key */

/**
 * $ANTLR start trim_key
 * OracleDMLKeys.g:2272:1: trim_key :{...}? REGULAR_ID -> TRIM_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::trim_key_return
OracleDML_OracleDMLKeys::trim_key()
{
    OracleDML_OracleDMLKeys::trim_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID489 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID489_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2273:5: ({...}? REGULAR_ID -> TRIM_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2273:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TRIM")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TRIM\"" );
                    ex->set_ruleName( "trim_key" );


            }

            REGULAR_ID489 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trim_key12655);
            if  (this->hasException())
            {
                goto ruletrim_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID489);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2273:60: -> TRIM_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TRIM_VK, REGULAR_ID489));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletrim_keyEx; /* Prevent compiler warnings */
    ruletrim_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end trim_key */

/**
 * $ANTLR start leading_key
 * OracleDMLKeys.g:2276:1: leading_key :{...}? REGULAR_ID -> LEADING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::leading_key_return
OracleDML_OracleDMLKeys::leading_key()
{
    OracleDML_OracleDMLKeys::leading_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID490 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID490_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2277:5: ({...}? REGULAR_ID -> LEADING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2277:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LEADING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LEADING\"" );
                    ex->set_ruleName( "leading_key" );


            }

            REGULAR_ID490 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_leading_key12682);
            if  (this->hasException())
            {
                goto ruleleading_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID490);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2277:63: -> LEADING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LEADING_VK, REGULAR_ID490));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleleading_keyEx; /* Prevent compiler warnings */
    ruleleading_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end leading_key */

/**
 * $ANTLR start trailing_key
 * OracleDMLKeys.g:2280:1: trailing_key :{...}? REGULAR_ID -> TRAILING_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::trailing_key_return
OracleDML_OracleDMLKeys::trailing_key()
{
    OracleDML_OracleDMLKeys::trailing_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID491 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID491_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2281:5: ({...}? REGULAR_ID -> TRAILING_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2281:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TRAILING")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TRAILING\"" );
                    ex->set_ruleName( "trailing_key" );


            }

            REGULAR_ID491 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trailing_key12709);
            if  (this->hasException())
            {
                goto ruletrailing_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID491);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2281:64: -> TRAILING_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TRAILING_VK, REGULAR_ID491));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletrailing_keyEx; /* Prevent compiler warnings */
    ruletrailing_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end trailing_key */

/**
 * $ANTLR start both_key
 * OracleDMLKeys.g:2284:1: both_key :{...}? REGULAR_ID -> BOTH_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::both_key_return
OracleDML_OracleDMLKeys::both_key()
{
    OracleDML_OracleDMLKeys::both_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID492 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID492_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2285:5: ({...}? REGULAR_ID -> BOTH_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2285:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BOTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BOTH\"" );
                    ex->set_ruleName( "both_key" );


            }

            REGULAR_ID492 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_both_key12736);
            if  (this->hasException())
            {
                goto ruleboth_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID492);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2285:60: -> BOTH_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BOTH_VK, REGULAR_ID492));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleboth_keyEx; /* Prevent compiler warnings */
    ruleboth_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end both_key */

/**
 * $ANTLR start collate_key
 * OracleDMLKeys.g:2288:1: collate_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::collate_key_return
OracleDML_OracleDMLKeys::collate_key()
{
    OracleDML_OracleDMLKeys::collate_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID493 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID493_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2289:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2289:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "COLLATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"COLLATE\"" );
                    ex->set_ruleName( "collate_key" );


            }

            REGULAR_ID493 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_collate_key12763);
            if  (this->hasException())
            {
                goto rulecollate_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID493_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID493));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID493_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecollate_keyEx; /* Prevent compiler warnings */
    rulecollate_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end collate_key */

/**
 * $ANTLR start position_key
 * OracleDMLKeys.g:2292:1: position_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::position_key_return
OracleDML_OracleDMLKeys::position_key()
{
    OracleDML_OracleDMLKeys::position_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID494 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID494_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2293:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2293:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "POSITION")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"POSITION\"" );
                    ex->set_ruleName( "position_key" );


            }

            REGULAR_ID494 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_position_key12785);
            if  (this->hasException())
            {
                goto ruleposition_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID494_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID494));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID494_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleposition_keyEx; /* Prevent compiler warnings */
    ruleposition_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end position_key */

/**
 * $ANTLR start extract_key
 * OracleDMLKeys.g:2296:1: extract_key :{...}? REGULAR_ID -> EXTRACT_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::extract_key_return
OracleDML_OracleDMLKeys::extract_key()
{
    OracleDML_OracleDMLKeys::extract_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID495 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID495_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2297:5: ({...}? REGULAR_ID -> EXTRACT_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2297:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "EXTRACT")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"EXTRACT\"" );
                    ex->set_ruleName( "extract_key" );


            }

            REGULAR_ID495 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_extract_key12807);
            if  (this->hasException())
            {
                goto ruleextract_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID495);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2297:63: -> EXTRACT_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(EXTRACT_VK, REGULAR_ID495));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleextract_keyEx; /* Prevent compiler warnings */
    ruleextract_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end extract_key */

/**
 * $ANTLR start second_key
 * OracleDMLKeys.g:2300:1: second_key :{...}? REGULAR_ID -> SECOND_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::second_key_return
OracleDML_OracleDMLKeys::second_key()
{
    OracleDML_OracleDMLKeys::second_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID496 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID496_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2301:5: ({...}? REGULAR_ID -> SECOND_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2301:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SECOND")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SECOND\"" );
                    ex->set_ruleName( "second_key" );


            }

            REGULAR_ID496 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_second_key12834);
            if  (this->hasException())
            {
                goto rulesecond_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID496);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2301:62: -> SECOND_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SECOND_VK, REGULAR_ID496));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesecond_keyEx; /* Prevent compiler warnings */
    rulesecond_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end second_key */

/**
 * $ANTLR start timezone_hour_key
 * OracleDMLKeys.g:2304:1: timezone_hour_key :{...}? REGULAR_ID -> TIMEZONE_HOUR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timezone_hour_key_return
OracleDML_OracleDMLKeys::timezone_hour_key()
{
    OracleDML_OracleDMLKeys::timezone_hour_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID497 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID497_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2305:5: ({...}? REGULAR_ID -> TIMEZONE_HOUR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2305:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMEZONE_HOUR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMEZONE_HOUR\"" );
                    ex->set_ruleName( "timezone_hour_key" );


            }

            REGULAR_ID497 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_hour_key12861);
            if  (this->hasException())
            {
                goto ruletimezone_hour_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID497);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2305:69: -> TIMEZONE_HOUR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMEZONE_HOUR_VK, REGULAR_ID497));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimezone_hour_keyEx; /* Prevent compiler warnings */
    ruletimezone_hour_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timezone_hour_key */

/**
 * $ANTLR start timezone_minute_key
 * OracleDMLKeys.g:2308:1: timezone_minute_key :{...}? REGULAR_ID -> TIMEZONE_MINUTE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::timezone_minute_key_return
OracleDML_OracleDMLKeys::timezone_minute_key()
{
    OracleDML_OracleDMLKeys::timezone_minute_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID498 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID498_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2309:5: ({...}? REGULAR_ID -> TIMEZONE_MINUTE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2309:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "TIMEZONE_MINUTE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"TIMEZONE_MINUTE\"" );
                    ex->set_ruleName( "timezone_minute_key" );


            }

            REGULAR_ID498 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_minute_key12888);
            if  (this->hasException())
            {
                goto ruletimezone_minute_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID498);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2309:71: -> TIMEZONE_MINUTE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(TIMEZONE_MINUTE_VK, REGULAR_ID498));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletimezone_minute_keyEx; /* Prevent compiler warnings */
    ruletimezone_minute_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end timezone_minute_key */

/**
 * $ANTLR start char_length_key
 * OracleDMLKeys.g:2312:1: char_length_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::char_length_key_return
OracleDML_OracleDMLKeys::char_length_key()
{
    OracleDML_OracleDMLKeys::char_length_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID499 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID499_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2313:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2313:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CHAR_LENGTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CHAR_LENGTH\"" );
                    ex->set_ruleName( "char_length_key" );


            }

            REGULAR_ID499 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_length_key12915);
            if  (this->hasException())
            {
                goto rulechar_length_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID499_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID499));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID499_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulechar_length_keyEx; /* Prevent compiler warnings */
    rulechar_length_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end char_length_key */

/**
 * $ANTLR start octet_length_key
 * OracleDMLKeys.g:2316:1: octet_length_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::octet_length_key_return
OracleDML_OracleDMLKeys::octet_length_key()
{
    OracleDML_OracleDMLKeys::octet_length_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID500 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID500_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2317:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2317:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "OCTET_LENGTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"OCTET_LENGTH\"" );
                    ex->set_ruleName( "octet_length_key" );


            }

            REGULAR_ID500 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_octet_length_key12937);
            if  (this->hasException())
            {
                goto ruleoctet_length_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID500_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID500));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID500_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleoctet_length_keyEx; /* Prevent compiler warnings */
    ruleoctet_length_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end octet_length_key */

/**
 * $ANTLR start character_length_key
 * OracleDMLKeys.g:2320:1: character_length_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::character_length_key_return
OracleDML_OracleDMLKeys::character_length_key()
{
    OracleDML_OracleDMLKeys::character_length_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID501 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID501_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2321:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2321:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CHARACTER_LENGTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CHARACTER_LENGTH\"" );
                    ex->set_ruleName( "character_length_key" );


            }

            REGULAR_ID501 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_character_length_key12959);
            if  (this->hasException())
            {
                goto rulecharacter_length_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID501_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID501));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID501_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecharacter_length_keyEx; /* Prevent compiler warnings */
    rulecharacter_length_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end character_length_key */

/**
 * $ANTLR start bit_length_key
 * OracleDMLKeys.g:2324:1: bit_length_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::bit_length_key_return
OracleDML_OracleDMLKeys::bit_length_key()
{
    OracleDML_OracleDMLKeys::bit_length_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID502 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID502_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2325:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2325:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "BIT_LENGTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BIT_LENGTH\"" );
                    ex->set_ruleName( "bit_length_key" );


            }

            REGULAR_ID502 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bit_length_key12981);
            if  (this->hasException())
            {
                goto rulebit_length_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID502_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID502));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID502_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebit_length_keyEx; /* Prevent compiler warnings */
    rulebit_length_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end bit_length_key */

/**
 * $ANTLR start local_key
 * OracleDMLKeys.g:2328:1: local_key :{...}? REGULAR_ID -> LOCAL_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::local_key_return
OracleDML_OracleDMLKeys::local_key()
{
    OracleDML_OracleDMLKeys::local_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID503 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID503_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2329:5: ({...}? REGULAR_ID -> LOCAL_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2329:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "LOCAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"LOCAL\"" );
                    ex->set_ruleName( "local_key" );


            }

            REGULAR_ID503 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_local_key13003);
            if  (this->hasException())
            {
                goto rulelocal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID503);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2329:61: -> LOCAL_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(LOCAL_VK, REGULAR_ID503));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelocal_keyEx; /* Prevent compiler warnings */
    rulelocal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end local_key */

/**
 * $ANTLR start current_timestamp_key
 * OracleDMLKeys.g:2332:1: current_timestamp_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::current_timestamp_key_return
OracleDML_OracleDMLKeys::current_timestamp_key()
{
    OracleDML_OracleDMLKeys::current_timestamp_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID504 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID504_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2333:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2333:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CURRENT_TIMESTAMP")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CURRENT_TIMESTAMP\"" );
                    ex->set_ruleName( "current_timestamp_key" );


            }

            REGULAR_ID504 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_timestamp_key13030);
            if  (this->hasException())
            {
                goto rulecurrent_timestamp_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID504_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID504));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID504_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecurrent_timestamp_keyEx; /* Prevent compiler warnings */
    rulecurrent_timestamp_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end current_timestamp_key */

/**
 * $ANTLR start current_date_key
 * OracleDMLKeys.g:2336:1: current_date_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::current_date_key_return
OracleDML_OracleDMLKeys::current_date_key()
{
    OracleDML_OracleDMLKeys::current_date_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID505 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID505_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2337:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2337:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CURRENT_DATE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CURRENT_DATE\"" );
                    ex->set_ruleName( "current_date_key" );


            }

            REGULAR_ID505 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_date_key13052);
            if  (this->hasException())
            {
                goto rulecurrent_date_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID505_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID505));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID505_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecurrent_date_keyEx; /* Prevent compiler warnings */
    rulecurrent_date_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end current_date_key */

/**
 * $ANTLR start current_time_key
 * OracleDMLKeys.g:2340:1: current_time_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::current_time_key_return
OracleDML_OracleDMLKeys::current_time_key()
{
    OracleDML_OracleDMLKeys::current_time_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID506 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID506_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2341:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2341:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "CURRENT_TIME")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CURRENT_TIME\"" );
                    ex->set_ruleName( "current_time_key" );


            }

            REGULAR_ID506 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_time_key13074);
            if  (this->hasException())
            {
                goto rulecurrent_time_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID506_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID506));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID506_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecurrent_time_keyEx; /* Prevent compiler warnings */
    rulecurrent_time_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end current_time_key */

/**
 * $ANTLR start module_key
 * OracleDMLKeys.g:2344:1: module_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::module_key_return
OracleDML_OracleDMLKeys::module_key()
{
    OracleDML_OracleDMLKeys::module_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID507 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID507_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2345:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2345:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "MODULE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MODULE\"" );
                    ex->set_ruleName( "module_key" );


            }

            REGULAR_ID507 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_module_key13096);
            if  (this->hasException())
            {
                goto rulemodule_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID507_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID507));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID507_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodule_keyEx; /* Prevent compiler warnings */
    rulemodule_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end module_key */

/**
 * $ANTLR start global_key
 * OracleDMLKeys.g:2348:1: global_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::global_key_return
OracleDML_OracleDMLKeys::global_key()
{
    OracleDML_OracleDMLKeys::global_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID508 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID508_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2349:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2349:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "GLOBAL")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"GLOBAL\"" );
                    ex->set_ruleName( "global_key" );


            }

            REGULAR_ID508 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_global_key13118);
            if  (this->hasException())
            {
                goto ruleglobal_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID508_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID508));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID508_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleglobal_keyEx; /* Prevent compiler warnings */
    ruleglobal_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end global_key */

/**
 * $ANTLR start year_key
 * OracleDMLKeys.g:2352:1: year_key :{...}? => REGULAR_ID -> YEAR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::year_key_return
OracleDML_OracleDMLKeys::year_key()
{
    OracleDML_OracleDMLKeys::year_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID509 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID509_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2353:5: ({...}? => REGULAR_ID -> YEAR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2353:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "YEAR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"YEAR\"" );
                    ex->set_ruleName( "year_key" );


            }

            REGULAR_ID509 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_year_key13141);
            if  (this->hasException())
            {
                goto ruleyear_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID509);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2353:62: -> YEAR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(YEAR_VK, REGULAR_ID509));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleyear_keyEx; /* Prevent compiler warnings */
    ruleyear_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end year_key */

/**
 * $ANTLR start month_key
 * OracleDMLKeys.g:2356:1: month_key :{...}? REGULAR_ID -> MONTH_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::month_key_return
OracleDML_OracleDMLKeys::month_key()
{
    OracleDML_OracleDMLKeys::month_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID510 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID510_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2357:5: ({...}? REGULAR_ID -> MONTH_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2357:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MONTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MONTH\"" );
                    ex->set_ruleName( "month_key" );


            }

            REGULAR_ID510 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_month_key13168);
            if  (this->hasException())
            {
                goto rulemonth_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID510);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2357:61: -> MONTH_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MONTH_VK, REGULAR_ID510));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemonth_keyEx; /* Prevent compiler warnings */
    rulemonth_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end month_key */

/**
 * $ANTLR start day_key
 * OracleDMLKeys.g:2360:1: day_key :{...}? => REGULAR_ID -> DAY_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::day_key_return
OracleDML_OracleDMLKeys::day_key()
{
    OracleDML_OracleDMLKeys::day_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID511 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID511_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2361:5: ({...}? => REGULAR_ID -> DAY_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2361:10: {...}? => REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DAY")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DAY\"" );
                    ex->set_ruleName( "day_key" );


            }

            REGULAR_ID511 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_day_key13196);
            if  (this->hasException())
            {
                goto ruleday_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID511);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2361:61: -> DAY_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DAY_VK, REGULAR_ID511));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleday_keyEx; /* Prevent compiler warnings */
    ruleday_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end day_key */

/**
 * $ANTLR start hour_key
 * OracleDMLKeys.g:2364:1: hour_key :{...}? REGULAR_ID -> HOUR_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::hour_key_return
OracleDML_OracleDMLKeys::hour_key()
{
    OracleDML_OracleDMLKeys::hour_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID512 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID512_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2364:9: ({...}? REGULAR_ID -> HOUR_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2364:14: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "HOUR")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"HOUR\"" );
                    ex->set_ruleName( "hour_key" );


            }

            REGULAR_ID512 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hour_key13218);
            if  (this->hasException())
            {
                goto rulehour_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID512);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2364:64: -> HOUR_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(HOUR_VK, REGULAR_ID512));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulehour_keyEx; /* Prevent compiler warnings */
    rulehour_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end hour_key */

/**
 * $ANTLR start minute_key
 * OracleDMLKeys.g:2367:1: minute_key :{...}? REGULAR_ID -> MINUTE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::minute_key_return
OracleDML_OracleDMLKeys::minute_key()
{
    OracleDML_OracleDMLKeys::minute_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID513 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID513_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2368:5: ({...}? REGULAR_ID -> MINUTE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2368:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "MINUTE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"MINUTE\"" );
                    ex->set_ruleName( "minute_key" );


            }

            REGULAR_ID513 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_minute_key13245);
            if  (this->hasException())
            {
                goto ruleminute_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID513);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2368:62: -> MINUTE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(MINUTE_VK, REGULAR_ID513));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleminute_keyEx; /* Prevent compiler warnings */
    ruleminute_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end minute_key */

/**
 * $ANTLR start whenever_key
 * OracleDMLKeys.g:2371:1: whenever_key :{...}? REGULAR_ID ;
 */
OracleDML_OracleDMLKeys::whenever_key_return
OracleDML_OracleDMLKeys::whenever_key()
{
    OracleDML_OracleDMLKeys::whenever_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID514 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID514_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2372:5: ({...}? REGULAR_ID )
        // OracleDMLKeys.g:2372:10: {...}? REGULAR_ID
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            if ( !((toUpper(LT(1)->getText()) == "WHENEVER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"WHENEVER\"" );
                    ex->set_ruleName( "whenever_key" );


            }

            REGULAR_ID514 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_whenever_key13272);
            if  (this->hasException())
            {
                goto rulewhenever_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            REGULAR_ID514_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID514));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID514_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewhenever_keyEx; /* Prevent compiler warnings */
    rulewhenever_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end whenever_key */

/**
 * $ANTLR start is_key
 * OracleDMLKeys.g:2375:1: is_key : SQL92_RESERVED_IS ;
 */
OracleDML_OracleDMLKeys::is_key_return
OracleDML_OracleDMLKeys::is_key()
{
    OracleDML_OracleDMLKeys::is_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_IS515 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_IS515_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2376:5: ( SQL92_RESERVED_IS )
        // OracleDMLKeys.g:2376:10: SQL92_RESERVED_IS
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_IS515 =  this->matchToken(SQL92_RESERVED_IS, &FOLLOW_SQL92_RESERVED_IS_in_is_key13292);
            if  (this->hasException())
            {
                goto ruleis_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_IS515_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_IS515));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_IS515_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleis_keyEx; /* Prevent compiler warnings */
    ruleis_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end is_key */

/**
 * $ANTLR start else_key
 * OracleDMLKeys.g:2379:1: else_key : SQL92_RESERVED_ELSE ;
 */
OracleDML_OracleDMLKeys::else_key_return
OracleDML_OracleDMLKeys::else_key()
{
    OracleDML_OracleDMLKeys::else_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_ELSE516 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_ELSE516_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2380:5: ( SQL92_RESERVED_ELSE )
        // OracleDMLKeys.g:2380:10: SQL92_RESERVED_ELSE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_ELSE516 =  this->matchToken(SQL92_RESERVED_ELSE, &FOLLOW_SQL92_RESERVED_ELSE_in_else_key13312);
            if  (this->hasException())
            {
                goto ruleelse_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_ELSE516_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_ELSE516));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_ELSE516_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleelse_keyEx; /* Prevent compiler warnings */
    ruleelse_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end else_key */

/**
 * $ANTLR start table_key
 * OracleDMLKeys.g:2383:1: table_key : SQL92_RESERVED_TABLE ;
 */
OracleDML_OracleDMLKeys::table_key_return
OracleDML_OracleDMLKeys::table_key()
{
    OracleDML_OracleDMLKeys::table_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_TABLE517 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_TABLE517_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2384:5: ( SQL92_RESERVED_TABLE )
        // OracleDMLKeys.g:2384:10: SQL92_RESERVED_TABLE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_TABLE517 =  this->matchToken(SQL92_RESERVED_TABLE, &FOLLOW_SQL92_RESERVED_TABLE_in_table_key13332);
            if  (this->hasException())
            {
                goto ruletable_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_TABLE517_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_TABLE517));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_TABLE517_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_keyEx; /* Prevent compiler warnings */
    ruletable_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_key */

/**
 * $ANTLR start the_key
 * OracleDMLKeys.g:2387:1: the_key : SQL92_RESERVED_THE ;
 */
OracleDML_OracleDMLKeys::the_key_return
OracleDML_OracleDMLKeys::the_key()
{
    OracleDML_OracleDMLKeys::the_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_THE518 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_THE518_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2388:5: ( SQL92_RESERVED_THE )
        // OracleDMLKeys.g:2388:10: SQL92_RESERVED_THE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_THE518 =  this->matchToken(SQL92_RESERVED_THE, &FOLLOW_SQL92_RESERVED_THE_in_the_key13352);
            if  (this->hasException())
            {
                goto rulethe_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_THE518_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_THE518));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_THE518_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulethe_keyEx; /* Prevent compiler warnings */
    rulethe_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end the_key */

/**
 * $ANTLR start then_key
 * OracleDMLKeys.g:2391:1: then_key : SQL92_RESERVED_THEN ;
 */
OracleDML_OracleDMLKeys::then_key_return
OracleDML_OracleDMLKeys::then_key()
{
    OracleDML_OracleDMLKeys::then_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_THEN519 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_THEN519_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2392:5: ( SQL92_RESERVED_THEN )
        // OracleDMLKeys.g:2392:10: SQL92_RESERVED_THEN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_THEN519 =  this->matchToken(SQL92_RESERVED_THEN, &FOLLOW_SQL92_RESERVED_THEN_in_then_key13372);
            if  (this->hasException())
            {
                goto rulethen_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_THEN519_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_THEN519));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_THEN519_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulethen_keyEx; /* Prevent compiler warnings */
    rulethen_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end then_key */

/**
 * $ANTLR start end_key
 * OracleDMLKeys.g:2395:1: end_key : SQL92_RESERVED_END ;
 */
OracleDML_OracleDMLKeys::end_key_return
OracleDML_OracleDMLKeys::end_key()
{
    OracleDML_OracleDMLKeys::end_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_END520 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_END520_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2396:5: ( SQL92_RESERVED_END )
        // OracleDMLKeys.g:2396:10: SQL92_RESERVED_END
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_END520 =  this->matchToken(SQL92_RESERVED_END, &FOLLOW_SQL92_RESERVED_END_in_end_key13392);
            if  (this->hasException())
            {
                goto ruleend_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_END520_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_END520));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_END520_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleend_keyEx; /* Prevent compiler warnings */
    ruleend_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end end_key */

/**
 * $ANTLR start all_key
 * OracleDMLKeys.g:2399:1: all_key : SQL92_RESERVED_ALL ;
 */
OracleDML_OracleDMLKeys::all_key_return
OracleDML_OracleDMLKeys::all_key()
{
    OracleDML_OracleDMLKeys::all_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_ALL521 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_ALL521_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2400:5: ( SQL92_RESERVED_ALL )
        // OracleDMLKeys.g:2400:10: SQL92_RESERVED_ALL
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_ALL521 =  this->matchToken(SQL92_RESERVED_ALL, &FOLLOW_SQL92_RESERVED_ALL_in_all_key13412);
            if  (this->hasException())
            {
                goto ruleall_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_ALL521_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_ALL521));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_ALL521_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleall_keyEx; /* Prevent compiler warnings */
    ruleall_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end all_key */

/**
 * $ANTLR start on_key
 * OracleDMLKeys.g:2403:1: on_key : SQL92_RESERVED_ON ;
 */
OracleDML_OracleDMLKeys::on_key_return
OracleDML_OracleDMLKeys::on_key()
{
    OracleDML_OracleDMLKeys::on_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_ON522 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_ON522_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2404:5: ( SQL92_RESERVED_ON )
        // OracleDMLKeys.g:2404:10: SQL92_RESERVED_ON
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_ON522 =  this->matchToken(SQL92_RESERVED_ON, &FOLLOW_SQL92_RESERVED_ON_in_on_key13432);
            if  (this->hasException())
            {
                goto ruleon_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_ON522_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_ON522));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_ON522_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleon_keyEx; /* Prevent compiler warnings */
    ruleon_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end on_key */

/**
 * $ANTLR start or_key
 * OracleDMLKeys.g:2407:1: or_key : SQL92_RESERVED_OR ;
 */
OracleDML_OracleDMLKeys::or_key_return
OracleDML_OracleDMLKeys::or_key()
{
    OracleDML_OracleDMLKeys::or_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_OR523 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_OR523_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2408:5: ( SQL92_RESERVED_OR )
        // OracleDMLKeys.g:2408:10: SQL92_RESERVED_OR
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_OR523 =  this->matchToken(SQL92_RESERVED_OR, &FOLLOW_SQL92_RESERVED_OR_in_or_key13452);
            if  (this->hasException())
            {
                goto ruleor_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_OR523_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_OR523));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_OR523_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleor_keyEx; /* Prevent compiler warnings */
    ruleor_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end or_key */

/**
 * $ANTLR start and_key
 * OracleDMLKeys.g:2411:1: and_key : SQL92_RESERVED_AND ;
 */
OracleDML_OracleDMLKeys::and_key_return
OracleDML_OracleDMLKeys::and_key()
{
    OracleDML_OracleDMLKeys::and_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_AND524 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_AND524_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2412:5: ( SQL92_RESERVED_AND )
        // OracleDMLKeys.g:2412:10: SQL92_RESERVED_AND
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_AND524 =  this->matchToken(SQL92_RESERVED_AND, &FOLLOW_SQL92_RESERVED_AND_in_and_key13472);
            if  (this->hasException())
            {
                goto ruleand_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_AND524_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_AND524));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_AND524_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleand_keyEx; /* Prevent compiler warnings */
    ruleand_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end and_key */

/**
 * $ANTLR start not_key
 * OracleDMLKeys.g:2415:1: not_key : SQL92_RESERVED_NOT ;
 */
OracleDML_OracleDMLKeys::not_key_return
OracleDML_OracleDMLKeys::not_key()
{
    OracleDML_OracleDMLKeys::not_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_NOT525 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_NOT525_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2416:5: ( SQL92_RESERVED_NOT )
        // OracleDMLKeys.g:2416:10: SQL92_RESERVED_NOT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_NOT525 =  this->matchToken(SQL92_RESERVED_NOT, &FOLLOW_SQL92_RESERVED_NOT_in_not_key13492);
            if  (this->hasException())
            {
                goto rulenot_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_NOT525_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_NOT525));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_NOT525_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenot_keyEx; /* Prevent compiler warnings */
    rulenot_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end not_key */

/**
 * $ANTLR start true_key
 * OracleDMLKeys.g:2419:1: true_key : SQL92_RESERVED_TRUE ;
 */
OracleDML_OracleDMLKeys::true_key_return
OracleDML_OracleDMLKeys::true_key()
{
    OracleDML_OracleDMLKeys::true_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_TRUE526 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_TRUE526_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2420:5: ( SQL92_RESERVED_TRUE )
        // OracleDMLKeys.g:2420:10: SQL92_RESERVED_TRUE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_TRUE526 =  this->matchToken(SQL92_RESERVED_TRUE, &FOLLOW_SQL92_RESERVED_TRUE_in_true_key13512);
            if  (this->hasException())
            {
                goto ruletrue_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_TRUE526_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_TRUE526));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_TRUE526_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletrue_keyEx; /* Prevent compiler warnings */
    ruletrue_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end true_key */

/**
 * $ANTLR start false_key
 * OracleDMLKeys.g:2423:1: false_key : SQL92_RESERVED_FALSE ;
 */
OracleDML_OracleDMLKeys::false_key_return
OracleDML_OracleDMLKeys::false_key()
{
    OracleDML_OracleDMLKeys::false_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_FALSE527 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_FALSE527_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2424:5: ( SQL92_RESERVED_FALSE )
        // OracleDMLKeys.g:2424:10: SQL92_RESERVED_FALSE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_FALSE527 =  this->matchToken(SQL92_RESERVED_FALSE, &FOLLOW_SQL92_RESERVED_FALSE_in_false_key13532);
            if  (this->hasException())
            {
                goto rulefalse_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_FALSE527_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_FALSE527));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_FALSE527_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefalse_keyEx; /* Prevent compiler warnings */
    rulefalse_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end false_key */

/**
 * $ANTLR start default_key
 * OracleDMLKeys.g:2427:1: default_key : SQL92_RESERVED_DEFAULT ;
 */
OracleDML_OracleDMLKeys::default_key_return
OracleDML_OracleDMLKeys::default_key()
{
    OracleDML_OracleDMLKeys::default_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_DEFAULT528 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_DEFAULT528_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2428:5: ( SQL92_RESERVED_DEFAULT )
        // OracleDMLKeys.g:2428:10: SQL92_RESERVED_DEFAULT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_DEFAULT528 =  this->matchToken(SQL92_RESERVED_DEFAULT, &FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key13552);
            if  (this->hasException())
            {
                goto ruledefault_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_DEFAULT528_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_DEFAULT528));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_DEFAULT528_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledefault_keyEx; /* Prevent compiler warnings */
    ruledefault_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end default_key */

/**
 * $ANTLR start distinct_key
 * OracleDMLKeys.g:2431:1: distinct_key : SQL92_RESERVED_DISTINCT ;
 */
OracleDML_OracleDMLKeys::distinct_key_return
OracleDML_OracleDMLKeys::distinct_key()
{
    OracleDML_OracleDMLKeys::distinct_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_DISTINCT529 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_DISTINCT529_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2432:5: ( SQL92_RESERVED_DISTINCT )
        // OracleDMLKeys.g:2432:10: SQL92_RESERVED_DISTINCT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_DISTINCT529 =  this->matchToken(SQL92_RESERVED_DISTINCT, &FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key13572);
            if  (this->hasException())
            {
                goto ruledistinct_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_DISTINCT529_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_DISTINCT529));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_DISTINCT529_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledistinct_keyEx; /* Prevent compiler warnings */
    ruledistinct_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end distinct_key */

/**
 * $ANTLR start into_key
 * OracleDMLKeys.g:2435:1: into_key : SQL92_RESERVED_INTO ;
 */
OracleDML_OracleDMLKeys::into_key_return
OracleDML_OracleDMLKeys::into_key()
{
    OracleDML_OracleDMLKeys::into_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_INTO530 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_INTO530_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2436:5: ( SQL92_RESERVED_INTO )
        // OracleDMLKeys.g:2436:10: SQL92_RESERVED_INTO
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_INTO530 =  this->matchToken(SQL92_RESERVED_INTO, &FOLLOW_SQL92_RESERVED_INTO_in_into_key13592);
            if  (this->hasException())
            {
                goto ruleinto_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_INTO530_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_INTO530));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_INTO530_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinto_keyEx; /* Prevent compiler warnings */
    ruleinto_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end into_key */

/**
 * $ANTLR start by_key
 * OracleDMLKeys.g:2439:1: by_key : SQL92_RESERVED_BY ;
 */
OracleDML_OracleDMLKeys::by_key_return
OracleDML_OracleDMLKeys::by_key()
{
    OracleDML_OracleDMLKeys::by_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_BY531 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_BY531_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2440:5: ( SQL92_RESERVED_BY )
        // OracleDMLKeys.g:2440:10: SQL92_RESERVED_BY
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_BY531 =  this->matchToken(SQL92_RESERVED_BY, &FOLLOW_SQL92_RESERVED_BY_in_by_key13612);
            if  (this->hasException())
            {
                goto ruleby_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_BY531_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_BY531));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_BY531_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleby_keyEx; /* Prevent compiler warnings */
    ruleby_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end by_key */

/**
 * $ANTLR start as_key
 * OracleDMLKeys.g:2443:1: as_key : SQL92_RESERVED_AS ;
 */
OracleDML_OracleDMLKeys::as_key_return
OracleDML_OracleDMLKeys::as_key()
{
    OracleDML_OracleDMLKeys::as_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_AS532 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_AS532_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2444:5: ( SQL92_RESERVED_AS )
        // OracleDMLKeys.g:2444:10: SQL92_RESERVED_AS
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_AS532 =  this->matchToken(SQL92_RESERVED_AS, &FOLLOW_SQL92_RESERVED_AS_in_as_key13632);
            if  (this->hasException())
            {
                goto ruleas_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_AS532_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_AS532));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_AS532_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleas_keyEx; /* Prevent compiler warnings */
    ruleas_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end as_key */

/**
 * $ANTLR start in_key
 * OracleDMLKeys.g:2447:1: in_key : SQL92_RESERVED_IN ;
 */
OracleDML_OracleDMLKeys::in_key_return
OracleDML_OracleDMLKeys::in_key()
{
    OracleDML_OracleDMLKeys::in_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_IN533 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_IN533_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2448:5: ( SQL92_RESERVED_IN )
        // OracleDMLKeys.g:2448:10: SQL92_RESERVED_IN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_IN533 =  this->matchToken(SQL92_RESERVED_IN, &FOLLOW_SQL92_RESERVED_IN_in_in_key13652);
            if  (this->hasException())
            {
                goto rulein_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_IN533_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_IN533));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_IN533_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulein_keyEx; /* Prevent compiler warnings */
    rulein_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end in_key */

/**
 * $ANTLR start of_key
 * OracleDMLKeys.g:2451:1: of_key : SQL92_RESERVED_OF ;
 */
OracleDML_OracleDMLKeys::of_key_return
OracleDML_OracleDMLKeys::of_key()
{
    OracleDML_OracleDMLKeys::of_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_OF534 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_OF534_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2452:5: ( SQL92_RESERVED_OF )
        // OracleDMLKeys.g:2452:10: SQL92_RESERVED_OF
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_OF534 =  this->matchToken(SQL92_RESERVED_OF, &FOLLOW_SQL92_RESERVED_OF_in_of_key13672);
            if  (this->hasException())
            {
                goto ruleof_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_OF534_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_OF534));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_OF534_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleof_keyEx; /* Prevent compiler warnings */
    ruleof_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end of_key */

/**
 * $ANTLR start null_key
 * OracleDMLKeys.g:2455:1: null_key : SQL92_RESERVED_NULL ;
 */
OracleDML_OracleDMLKeys::null_key_return
OracleDML_OracleDMLKeys::null_key()
{
    OracleDML_OracleDMLKeys::null_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_NULL535 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_NULL535_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2456:5: ( SQL92_RESERVED_NULL )
        // OracleDMLKeys.g:2456:10: SQL92_RESERVED_NULL
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_NULL535 =  this->matchToken(SQL92_RESERVED_NULL, &FOLLOW_SQL92_RESERVED_NULL_in_null_key13692);
            if  (this->hasException())
            {
                goto rulenull_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_NULL535_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_NULL535));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_NULL535_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenull_keyEx; /* Prevent compiler warnings */
    rulenull_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end null_key */

/**
 * $ANTLR start for_key
 * OracleDMLKeys.g:2459:1: for_key : SQL92_RESERVED_FOR ;
 */
OracleDML_OracleDMLKeys::for_key_return
OracleDML_OracleDMLKeys::for_key()
{
    OracleDML_OracleDMLKeys::for_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_FOR536 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_FOR536_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2460:5: ( SQL92_RESERVED_FOR )
        // OracleDMLKeys.g:2460:10: SQL92_RESERVED_FOR
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_FOR536 =  this->matchToken(SQL92_RESERVED_FOR, &FOLLOW_SQL92_RESERVED_FOR_in_for_key13712);
            if  (this->hasException())
            {
                goto rulefor_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_FOR536_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_FOR536));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_FOR536_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefor_keyEx; /* Prevent compiler warnings */
    rulefor_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end for_key */

/**
 * $ANTLR start select_key
 * OracleDMLKeys.g:2463:1: select_key : SQL92_RESERVED_SELECT ;
 */
OracleDML_OracleDMLKeys::select_key_return
OracleDML_OracleDMLKeys::select_key()
{
    OracleDML_OracleDMLKeys::select_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_SELECT537 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_SELECT537_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2464:5: ( SQL92_RESERVED_SELECT )
        // OracleDMLKeys.g:2464:10: SQL92_RESERVED_SELECT
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_SELECT537 =  this->matchToken(SQL92_RESERVED_SELECT, &FOLLOW_SQL92_RESERVED_SELECT_in_select_key13732);
            if  (this->hasException())
            {
                goto ruleselect_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_SELECT537_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_SELECT537));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_SELECT537_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleselect_keyEx; /* Prevent compiler warnings */
    ruleselect_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end select_key */

/**
 * $ANTLR start when_key
 * OracleDMLKeys.g:2467:1: when_key : SQL92_RESERVED_WHEN ;
 */
OracleDML_OracleDMLKeys::when_key_return
OracleDML_OracleDMLKeys::when_key()
{
    OracleDML_OracleDMLKeys::when_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_WHEN538 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_WHEN538_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2468:5: ( SQL92_RESERVED_WHEN )
        // OracleDMLKeys.g:2468:10: SQL92_RESERVED_WHEN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_WHEN538 =  this->matchToken(SQL92_RESERVED_WHEN, &FOLLOW_SQL92_RESERVED_WHEN_in_when_key13752);
            if  (this->hasException())
            {
                goto rulewhen_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_WHEN538_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_WHEN538));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_WHEN538_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewhen_keyEx; /* Prevent compiler warnings */
    rulewhen_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end when_key */

/**
 * $ANTLR start delete_key
 * OracleDMLKeys.g:2471:1: delete_key : SQL92_RESERVED_DELETE ;
 */
OracleDML_OracleDMLKeys::delete_key_return
OracleDML_OracleDMLKeys::delete_key()
{
    OracleDML_OracleDMLKeys::delete_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_DELETE539 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_DELETE539_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2472:5: ( SQL92_RESERVED_DELETE )
        // OracleDMLKeys.g:2472:10: SQL92_RESERVED_DELETE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_DELETE539 =  this->matchToken(SQL92_RESERVED_DELETE, &FOLLOW_SQL92_RESERVED_DELETE_in_delete_key13772);
            if  (this->hasException())
            {
                goto ruledelete_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_DELETE539_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_DELETE539));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_DELETE539_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledelete_keyEx; /* Prevent compiler warnings */
    ruledelete_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end delete_key */

/**
 * $ANTLR start between_key
 * OracleDMLKeys.g:2475:1: between_key : SQL92_RESERVED_BETWEEN ;
 */
OracleDML_OracleDMLKeys::between_key_return
OracleDML_OracleDMLKeys::between_key()
{
    OracleDML_OracleDMLKeys::between_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_BETWEEN540 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_BETWEEN540_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2476:5: ( SQL92_RESERVED_BETWEEN )
        // OracleDMLKeys.g:2476:10: SQL92_RESERVED_BETWEEN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_BETWEEN540 =  this->matchToken(SQL92_RESERVED_BETWEEN, &FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key13792);
            if  (this->hasException())
            {
                goto rulebetween_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_BETWEEN540_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_BETWEEN540));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_BETWEEN540_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebetween_keyEx; /* Prevent compiler warnings */
    rulebetween_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end between_key */

/**
 * $ANTLR start like_key
 * OracleDMLKeys.g:2479:1: like_key : SQL92_RESERVED_LIKE ;
 */
OracleDML_OracleDMLKeys::like_key_return
OracleDML_OracleDMLKeys::like_key()
{
    OracleDML_OracleDMLKeys::like_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* SQL92_RESERVED_LIKE541 = NULL;

    ImplTraits::TreeTypePtr SQL92_RESERVED_LIKE541_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2480:5: ( SQL92_RESERVED_LIKE )
        // OracleDMLKeys.g:2480:10: SQL92_RESERVED_LIKE
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            SQL92_RESERVED_LIKE541 =  this->matchToken(SQL92_RESERVED_LIKE, &FOLLOW_SQL92_RESERVED_LIKE_in_like_key13812);
            if  (this->hasException())
            {
                goto rulelike_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            SQL92_RESERVED_LIKE541_tree = std::move(get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_LIKE541));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, SQL92_RESERVED_LIKE541_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelike_keyEx; /* Prevent compiler warnings */
    rulelike_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end like_key */

/**
 * $ANTLR start from_key
 * OracleDMLKeys.g:2483:1: from_key : s= SQL92_RESERVED_FROM -> SQL92_RESERVED_FROM[$s,ToraType(T_FROM)] ;
 */
OracleDML_OracleDMLKeys::from_key_return
OracleDML_OracleDMLKeys::from_key()
{
    OracleDML_OracleDMLKeys::from_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* s = NULL;

    ImplTraits::TreeTypePtr s_tree;
    RewriteRuleTokenStream<ImplTraits> stream_SQL92_RESERVED_FROM(get_psrstate()->get_treeAdaptor(), "token SQL92_RESERVED_FROM");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2484:5: (s= SQL92_RESERVED_FROM -> SQL92_RESERVED_FROM[$s,ToraType(T_FROM)] )
        // OracleDMLKeys.g:2484:10: s= SQL92_RESERVED_FROM
        {
            s =  this->matchToken(SQL92_RESERVED_FROM, &FOLLOW_SQL92_RESERVED_FROM_in_from_key13834);
            if  (this->hasException())
            {
                goto rulefrom_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_SQL92_RESERVED_FROM.add(s);


            // AST REWRITE
            // elements: SQL92_RESERVED_FROM
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2484:32: -> SQL92_RESERVED_FROM[$s,ToraType(T_FROM)]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_FROM, s, ToraType(T_FROM)));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefrom_keyEx; /* Prevent compiler warnings */
    rulefrom_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end from_key */

/**
 * $ANTLR start where_key
 * OracleDMLKeys.g:2487:1: where_key : s= SQL92_RESERVED_WHERE -> SQL92_RESERVED_WHERE[$s,ToraType(T_WHERE)] ;
 */
OracleDML_OracleDMLKeys::where_key_return
OracleDML_OracleDMLKeys::where_key()
{
    OracleDML_OracleDMLKeys::where_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* s = NULL;

    ImplTraits::TreeTypePtr s_tree;
    RewriteRuleTokenStream<ImplTraits> stream_SQL92_RESERVED_WHERE(get_psrstate()->get_treeAdaptor(), "token SQL92_RESERVED_WHERE");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2488:5: (s= SQL92_RESERVED_WHERE -> SQL92_RESERVED_WHERE[$s,ToraType(T_WHERE)] )
        // OracleDMLKeys.g:2488:10: s= SQL92_RESERVED_WHERE
        {
            s =  this->matchToken(SQL92_RESERVED_WHERE, &FOLLOW_SQL92_RESERVED_WHERE_in_where_key13861);
            if  (this->hasException())
            {
                goto rulewhere_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_SQL92_RESERVED_WHERE.add(s);


            // AST REWRITE
            // elements: SQL92_RESERVED_WHERE
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2488:33: -> SQL92_RESERVED_WHERE[$s,ToraType(T_WHERE)]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SQL92_RESERVED_WHERE, s, ToraType(T_WHERE)));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewhere_keyEx; /* Prevent compiler warnings */
    rulewhere_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end where_key */

/**
 * $ANTLR start sequence_key
 * OracleDMLKeys.g:2491:1: sequence_key :{...}? REGULAR_ID -> SEQUENCE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::sequence_key_return
OracleDML_OracleDMLKeys::sequence_key()
{
    OracleDML_OracleDMLKeys::sequence_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID542 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID542_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2492:5: ({...}? REGULAR_ID -> SEQUENCE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2492:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SEQUENCE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SEQUENCE\"" );
                    ex->set_ruleName( "sequence_key" );


            }

            REGULAR_ID542 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sequence_key13888);
            if  (this->hasException())
            {
                goto rulesequence_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID542);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2492:64: -> SEQUENCE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SEQUENCE_VK, REGULAR_ID542));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesequence_keyEx; /* Prevent compiler warnings */
    rulesequence_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sequence_key */

/**
 * $ANTLR start noorder_key
 * OracleDMLKeys.g:2495:1: noorder_key :{...}? REGULAR_ID -> NOORDER_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::noorder_key_return
OracleDML_OracleDMLKeys::noorder_key()
{
    OracleDML_OracleDMLKeys::noorder_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID543 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID543_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2496:5: ({...}? REGULAR_ID -> NOORDER_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2496:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOORDER")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOORDER\"" );
                    ex->set_ruleName( "noorder_key" );


            }

            REGULAR_ID543 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noorder_key13915);
            if  (this->hasException())
            {
                goto rulenoorder_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID543);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2496:63: -> NOORDER_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOORDER_VK, REGULAR_ID543));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenoorder_keyEx; /* Prevent compiler warnings */
    rulenoorder_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end noorder_key */

/**
 * $ANTLR start cycle_key
 * OracleDMLKeys.g:2499:1: cycle_key :{...}? REGULAR_ID -> CYCLE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::cycle_key_return
OracleDML_OracleDMLKeys::cycle_key()
{
    OracleDML_OracleDMLKeys::cycle_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID544 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID544_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2500:5: ({...}? REGULAR_ID -> CYCLE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2500:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CYCLE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CYCLE\"" );
                    ex->set_ruleName( "cycle_key" );


            }

            REGULAR_ID544 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cycle_key13942);
            if  (this->hasException())
            {
                goto rulecycle_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID544);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2500:61: -> CYCLE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CYCLE_VK, REGULAR_ID544));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecycle_keyEx; /* Prevent compiler warnings */
    rulecycle_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cycle_key */

/**
 * $ANTLR start cache_key
 * OracleDMLKeys.g:2503:1: cache_key :{...}? REGULAR_ID -> CACHE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::cache_key_return
OracleDML_OracleDMLKeys::cache_key()
{
    OracleDML_OracleDMLKeys::cache_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID545 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID545_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2504:5: ({...}? REGULAR_ID -> CACHE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2504:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "CACHE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"CACHE\"" );
                    ex->set_ruleName( "cache_key" );


            }

            REGULAR_ID545 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cache_key13969);
            if  (this->hasException())
            {
                goto rulecache_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID545);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2504:61: -> CACHE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(CACHE_VK, REGULAR_ID545));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecache_keyEx; /* Prevent compiler warnings */
    rulecache_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cache_key */

/**
 * $ANTLR start nocache_key
 * OracleDMLKeys.g:2507:1: nocache_key :{...}? REGULAR_ID -> NOCACHE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nocache_key_return
OracleDML_OracleDMLKeys::nocache_key()
{
    OracleDML_OracleDMLKeys::nocache_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID546 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID546_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2508:5: ({...}? REGULAR_ID -> NOCACHE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2508:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOCACHE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOCACHE\"" );
                    ex->set_ruleName( "nocache_key" );


            }

            REGULAR_ID546 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocache_key13996);
            if  (this->hasException())
            {
                goto rulenocache_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID546);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2508:63: -> NOCACHE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOCACHE_VK, REGULAR_ID546));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenocache_keyEx; /* Prevent compiler warnings */
    rulenocache_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nocache_key */

/**
 * $ANTLR start nomaxvalue_key
 * OracleDMLKeys.g:2511:1: nomaxvalue_key :{...}? REGULAR_ID -> NOMAXVALUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nomaxvalue_key_return
OracleDML_OracleDMLKeys::nomaxvalue_key()
{
    OracleDML_OracleDMLKeys::nomaxvalue_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID547 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID547_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2512:5: ({...}? REGULAR_ID -> NOMAXVALUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2512:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOMAXVALUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOMAXVALUE\"" );
                    ex->set_ruleName( "nomaxvalue_key" );


            }

            REGULAR_ID547 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nomaxvalue_key14023);
            if  (this->hasException())
            {
                goto rulenomaxvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID547);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2512:66: -> NOMAXVALUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOMAXVALUE_VK, REGULAR_ID547));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenomaxvalue_keyEx; /* Prevent compiler warnings */
    rulenomaxvalue_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nomaxvalue_key */

/**
 * $ANTLR start nominvalue_key
 * OracleDMLKeys.g:2515:1: nominvalue_key :{...}? REGULAR_ID -> NOMINVALUE_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::nominvalue_key_return
OracleDML_OracleDMLKeys::nominvalue_key()
{
    OracleDML_OracleDMLKeys::nominvalue_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID548 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID548_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2516:5: ({...}? REGULAR_ID -> NOMINVALUE_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2516:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "NOMINVALUE")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"NOMINVALUE\"" );
                    ex->set_ruleName( "nominvalue_key" );


            }

            REGULAR_ID548 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nominvalue_key14050);
            if  (this->hasException())
            {
                goto rulenominvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID548);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2516:66: -> NOMINVALUE_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(NOMINVALUE_VK, REGULAR_ID548));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenominvalue_keyEx; /* Prevent compiler warnings */
    rulenominvalue_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end nominvalue_key */

/**
 * $ANTLR start search_key
 * OracleDMLKeys.g:2519:1: search_key :{...}? REGULAR_ID -> SEARCH_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::search_key_return
OracleDML_OracleDMLKeys::search_key()
{
    OracleDML_OracleDMLKeys::search_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID549 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID549_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2520:5: ({...}? REGULAR_ID -> SEARCH_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2520:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "SEARCH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"SEARCH\"" );
                    ex->set_ruleName( "search_key" );


            }

            REGULAR_ID549 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_search_key14077);
            if  (this->hasException())
            {
                goto rulesearch_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID549);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2520:62: -> SEARCH_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(SEARCH_VK, REGULAR_ID549));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesearch_keyEx; /* Prevent compiler warnings */
    rulesearch_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end search_key */

/**
 * $ANTLR start depth_key
 * OracleDMLKeys.g:2523:1: depth_key :{...}? REGULAR_ID -> DEPTH_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::depth_key_return
OracleDML_OracleDMLKeys::depth_key()
{
    OracleDML_OracleDMLKeys::depth_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID550 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID550_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2524:5: ({...}? REGULAR_ID -> DEPTH_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2524:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "DEPTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"DEPTH\"" );
                    ex->set_ruleName( "depth_key" );


            }

            REGULAR_ID550 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_depth_key14104);
            if  (this->hasException())
            {
                goto ruledepth_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID550);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2524:61: -> DEPTH_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(DEPTH_VK, REGULAR_ID550));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledepth_keyEx; /* Prevent compiler warnings */
    ruledepth_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end depth_key */

/**
 * $ANTLR start breadth_key
 * OracleDMLKeys.g:2527:1: breadth_key :{...}? REGULAR_ID -> BREADTH_VK[$REGULAR_ID] ;
 */
OracleDML_OracleDMLKeys::breadth_key_return
OracleDML_OracleDMLKeys::breadth_key()
{
    OracleDML_OracleDMLKeys::breadth_key_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID551 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID551_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLKeys.g:2528:5: ({...}? REGULAR_ID -> BREADTH_VK[$REGULAR_ID] )
        // OracleDMLKeys.g:2528:10: {...}? REGULAR_ID
        {
            if ( !((toUpper(LT(1)->getText()) == "BREADTH")) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "toUpper(LT(1)->getText()) == \"BREADTH\"" );
                    ex->set_ruleName( "breadth_key" );


            }

            REGULAR_ID551 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_breadth_key14131);
            if  (this->hasException())
            {
                goto rulebreadth_keyEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID551);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 2528:63: -> BREADTH_VK[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(BREADTH_VK, REGULAR_ID551));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebreadth_keyEx; /* Prevent compiler warnings */
    rulebreadth_keyEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end breadth_key */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
